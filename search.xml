<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2023HBCPC游记</title>
    <url>/2023/05/23/2023HBCPC%E6%B8%B8%E8%AE%B0/</url>
    <content><![CDATA[<p>原本痛苦于比完赛后冗杂繁多的事情来着，但是干活干了一天还在实验室里，想休息又不能说像在宿舍一样躺在床上，干脆趁现在记录下HBCPC的游记。在我本就短暂的竞赛生涯经历过了大学两年线上赛后，我终于迎来了第一次的线下比赛机会。说不激动是假的，但是成绩对我来说仍然有些不尽人意，省二对于一个想要冲锋ICPC的选手还是太渺茫了。</p>
<h1 id="5-x2F-19-DAY1"><a href="#5-x2F-19-DAY1" class="headerlink" title="5&#x2F;19 DAY1"></a>5&#x2F;19 DAY1</h1><p>首先要炫耀的就是成功翘掉了两节课！我们是中午出发坐客车，1个小时后转火车硬卧，晚上7点半左右就到宾馆了。然后就开始讨论吃什么的问题，最后的决定是汉堡。结果走了40分钟到了地方的时候看到老旧的招牌跟上二楼昏黄的灯光，小作坊无疑，然后就直接不敢进去了…于是乎转战商场去吃KFC，之后我用实际行动证明了“即使你有10年没有骑过车子了但是只要一上车你还是会骑”这件事。接着就是理所当然的骑车到了商场吃汉堡王（？），然后回宾馆还打了一场CF div3，冲着一道写对了的题检查了20分钟…最后死活搞到2点才睡的，不过这个点对于我平时的作息规律倒也不算很晚。</p>
<p>去汉堡王路过的很大的商场：</p>
<p><img src="/2023/05/23/2023HBCPC%E6%B8%B8%E8%AE%B0/%E8%B7%AF%E8%BF%87%E8%80%8C%E5%B7%B2.jpg" alt="img"></p>
<p>很像摸老师：</p>
<p><img src="/2023/05/23/2023HBCPC%E6%B8%B8%E8%AE%B0/%E5%BE%88%E5%83%8F%E6%91%B8%E8%80%81%E5%B8%88.jpg" alt="img"></p>
<h1 id="5-x2F-20-DAY2"><a href="#5-x2F-20-DAY2" class="headerlink" title="5&#x2F;20 DAY2"></a>5&#x2F;20 DAY2</h1><p>起床，领资源，线下赛的衣服可比线上时潦草的衣服正规多了，穿上去还是挺舒服的。中午吃饭感受了一下东秦的食堂，比较小同时也比我们学校贵一些，不过饭也是要更好吃的，环境也更好一些，有点羡慕。</p>
<p>参加赛前宣讲，场馆很大，老师很正式，我甚至还看到了老队友wjq！聊了聊他提到自己已经三银退役了，十分羡慕。</p>
<p>然后是训练赛，快速秒掉一个二分一个质因数，然后在一道和蓝桥杯岛屿的题十分类似的题上卡了好久，但是在最后20分钟抖机灵搞了出来，还是很激动的。线下赛的气球确实很有意思，<del>尤其是我们的气球会伸到对面队伍那边去的恶意</del>。</p>
<p>晚上骑车去海边！看完海去秦皇小巷吃东西！全是小吃，然后房子也挺好看的，感觉对于景点来讲，只有这种地方人挤人才能让人讨厌不起来吧。</p>
<p>这一天的安排实在是太满了，以至于现在回想起来好像是好几天的事情一样。</p>
<p>比赛的楼，非常大：</p>
<p><img src="/2023/05/23/2023HBCPC%E6%B8%B8%E8%AE%B0/%E6%A5%BC.jpg" alt="img"></p>
<p>食堂（把右边的队友截掉了）：</p>
<p><img src="/2023/05/23/2023HBCPC%E6%B8%B8%E8%AE%B0/%E9%A3%9F%E5%A0%82.jpg" alt="img"></p>
<p>开幕式：</p>
<p><img src="/2023/05/23/2023HBCPC%E6%B8%B8%E8%AE%B0/%E5%BC%80%E5%B9%95%E5%BC%8F.jpg" alt="img"></p>
<p>海边：</p>
<p><img src="/2023/05/23/2023HBCPC%E6%B8%B8%E8%AE%B0/%E6%B5%B7%E8%BE%B9.jpg" alt="img"></p>
<p>巷外：</p>
<p><img src="/2023/05/23/2023HBCPC%E6%B8%B8%E8%AE%B0/%E5%B7%B7%E5%A4%96.jpg" alt="img"></p>
<p>巷里：</p>
<p><img src="/2023/05/23/2023HBCPC%E6%B8%B8%E8%AE%B0/%E5%B7%B7%E9%87%8C.jpg" alt="img"></p>
<h1 id="5-x2F-21-DAY3"><a href="#5-x2F-21-DAY3" class="headerlink" title="5&#x2F;21 DAY3"></a>5&#x2F;21 DAY3</h1><p>开赛！今年的签到是真的签到了，直接输出比赛名称。之后快速做完另一个签到，卡在了二维格雷码，当时的脑子里使劲回忆当年打CSP的那道格雷码，最后用两重dfs写出来了。然后就是两个半小时的痛苦面具解奇偶树…但我严重怀疑这是道原题，我在CF上打到过和它十分类似的题目，也万幸是打过类似的题目，这道题才能够最后得以解决。之后一个小时本来都要摆了，结果仔细看了看最后一题发现并不是博弈论，而是一个类似树上LCA的题目，强忍疲惫竟然在最后一小时解决了，通过的时候我自己都有点难以置信，然后就是激动，再然后就是气球。最终战绩5题，省二。</p>
<p>最后又去了趟海边，老师又请我们吃了饭，这是一次很珍贵美好的回忆，但到最后坐上返途的车时又有点惆怅。一方面是这段时间过的实在很快，3点回到学校后睡醒，就如同一切都未发送过一样…另一方面是ICPC获奖相较于我现在的水平来说，仍然是一种奢求。我又能怎么办呢？总会有人谈到队友的重要性，但在农大目前的情况来看，找到两个水平相当的队友几乎不可能。不过，我必须在我的生涯中拿到一次铜，这没有退让的余地。</p>
]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>OI 比赛</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 编译器相关</title>
    <url>/2023/12/07/C-%E7%BC%96%E8%AF%91%E5%99%A8%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<h1 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h1><p>在开始之前我们先放一段 Hello World：hello.c</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后就是一段老生常谈的描述了：</p>
<p>要想让这段代码在 Linux 上运行，我们需要使用 GCC：</p>
<ol>
<li><strong>预编译</strong>：将 hello.c 和 stdio.h 预编译为 hello.i</li>
<li><strong>编译</strong>：将 hello.i 编译为 hello.s</li>
<li><strong>汇编</strong>：将 hello.s 翻译为机器指令 hello.o（.o 目标文件）</li>
<li><strong>链接</strong>：链接各种需要的库和其他目标文件（该 hello 程序不需要）得到可执行文件 hello.out（相当于 Windows 的 .exe）</li>
</ol>
<p>整个过程将高级语言翻译成了机器语言，而<strong>编译器</strong>，就是这样的一个工具。GCC 可以完成从预编译编译，汇编，链接整个过程。</p>
<p>但是平时使用 Visual Studio 等软件时并没有接触到这个过程，因为 VS 是高度集成开发环境（IDE、Integrated Development Environment），集成了代码编辑器，编译器，调试器和图像化用户界面，上述所有程序编译和链接过程都用一步 <strong>build 构建</strong>带过了。</p>
<h1 id="GNU"><a href="#GNU" class="headerlink" title="GNU"></a>GNU</h1><p><strong>GNU 计划</strong>，又称革奴计划，是由 Richard Stallman 在 1983 年 9 月 27 日公开发起的。它的目标是创建一套完全自由的操作系统。因为当时 1969 年在贝尔实验室诞生的 Unix 是商业操作系统。因此 <strong>Stallman 便是开源运动的先驱</strong>。而他最初的目标”创建一套完全自由的操作系统”也实现了，就是 GNU&#x2F;Linux，简称 Linux。</p>
<p>Linux 内核最初是由 Linus Torvalds 在赫尔辛基大学读书时出于个人爱好而编写的，第一版于 1991 年发布，当时仅一万行代码。1992 年 Linux 与<strong>其他 GNU 软件结合（自然包括 GCC）</strong>，完全自由的操作系统正式诞生。</p>
<h1 id="GCC-x2F-G"><a href="#GCC-x2F-G" class="headerlink" title="GCC&#x2F;G++"></a>GCC&#x2F;G++</h1><p>首先我们可以将 GCC&#x2F;G++ 看成一个整体，不存在 GCC 专门编译 C 语言，G++ 专门编译 C++ 语言这种分别，因为编程语言发展至今是非常复杂的，编译器同样也是。我们将两者都看成 GCC，GCC 支持 C、C++ 和 Fortran 语言。</p>
<p>而 GCC（GNU Compiler Collection，GNU 编译器集合），就是 GNU 运动的代表性成果，它的初衷是为 GNU 的自由系统开发完整的编译器。</p>
<p><strong>所以，在 Linux 甚至 Windows 上各种涉及开发环境配置，源码编译的地方，都离不开 GCC 和 G++。</strong></p>
<h1 id="MinGW-w64-x2F-MSVC"><a href="#MinGW-w64-x2F-MSVC" class="headerlink" title="MinGW(-w64)&#x2F;MSVC"></a>MinGW(-w64)&#x2F;MSVC</h1><p>MinGW(Minimalist GNUfor Windows)，它是一个可自由使用和自由发布的 Windows 特定头文件和使用 GNU 工具集导入库的集合，允许你在 Windows 平台生成本地的 Windows 程序而不需要第三方 C 运行时(C Runtime)库。通俗来讲 GCC 本身是 Linux 上的编译器套件，不能在 Windows 上运行，而 MinGW 则是 GCC 在 Windows 上的移植。</p>
<p>运行时库：支持程序运行的基本函数的集合，一般是静态库 lib 或动态库 dll。</p>
<p>最早的 MinGW 项目只支持编译 32 位程序，后来分支出的 MinGW-w64 项目则同时支持编译 32&#x2F;64 位程序。MinGW-w64 项目目前的状况比较复杂，有多个发行分支，具体可以参看<a href="https://link.zhihu.com/?target=https://www.mingw-w64.org/downloads/">官网的下载页</a>。目前 Windows 上最新、最靠谱的发行分支就是 <strong>MSYS2</strong>（GCC 版本 12.2.0-6）。关于 MinGW 和 MinGW-w64 的渊源，可以看<a href="https://link.zhihu.com/?target=https://github.com/FrankHB/pl-docs/blob/master/zh-CN/mingw-vs-mingw-v64.md%23:~:text=MinGW%20%E5%92%8C%20MinGW-W64%20%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F">这篇科普</a>。</p>
<p>而 MSVC，就是上文所说的第三方 C 运行时库：由微软开发的 VC 运行时库，被 Visual Studio IDE 所集成。所以我们使用 VS 时会附带 MSVC 编译器。</p>
<p>所以可以看到，MinGW 和 MSVC 都是 Windows C&#x2F;C++ 语言编译支持，配置环境时遇到两者择其一即可。</p>
<h1 id="MSYS2"><a href="#MSYS2" class="headerlink" title="MSYS2"></a>MSYS2</h1><p><strong>MSYS2</strong>(Minimal SYStem 2)是与 MinGW-w64 配套的<strong>命令行环境</strong>，它为 Windows 提供了类似 Linux 的命令和<strong>包管理器</strong> pacman，可以直接在命令行查找、安装和卸载各种第三方库和开发工具。</p>
<p>MSYS2 实际上是由 6 个独立的子环境组成的。每个子环境会有一个单独的文件夹，和一个专门的命令行界面入口。</p>
<ul>
<li>MSYS 环境是基础环境，包含各种 Linux 命令行工具（例如 pacman 等），其它子环境都继承于它。但在这个子环境里编译的程序<strong>依赖于 MSYS2 的动态库</strong>，因此直接把编译出来的 .exe 发给其他人的话会无法运行，需要带上 &#x2F;usr&#x2F;bin 文件夹下的 MSYS-2.0.dll 等依赖库才行。<strong>一般不建议使用</strong>。（需要完整 Linux 环境的请考虑 <strong>WSL</strong> 或者虚拟机）</li>
<li>MINGW64 环境编译的程序不依赖 MSYS2，只依赖于 Windows 自带的 C 语言库 msvcrt，较为通用。</li>
<li>UCRT64 与 MINGW64 类似，但依赖于比较新的 C 语言库 ucrt，这个库 Win10&#x2F;11 自带，也是目前微软家的 <a href="https://link.zhihu.com/?target=https://visualstudio.microsoft.com/zh-hans/">Visual Studio</a> 使用的库，但 Win7&#x2F;XP 可能需要手动安装。未来将会替代 MINGW64。</li>
<li>CLANG64 环境使用 LLVM 工具链而非 GCC 工具链，所有配套环境都是基于 LLVM 的（比如这个环境里的 gcc.exe 其实是 clang.exe 的重命名）。</li>
<li>MINGW32 和 CLANG32 顾名思义，使用 32 位的 MinGW&#x2F;clang 工具链，如果没有特殊需求基本不用考虑，用 64 位版本就好。</li>
</ul>
<p>最早只有 MSYS，MINGW64 和 MINGW32 三个子环境，子环境数量由于开发的需要正在增加，将来可能还会加入 CLANGARM64（可用于 Android 程序编译）。</p>
<h1 id="LLVM-的-Clang-x2F-Clang"><a href="#LLVM-的-Clang-x2F-Clang" class="headerlink" title="LLVM 的 Clang&#x2F;Clang++"></a>LLVM 的 Clang&#x2F;Clang++</h1><p>LLVM（Low Level Virtual Machine，底层虚拟机)） 是构架编译器(compiler)的框架系统，以 C++ 编写而成，用于优化以任意程序语言编写的程序的编译时间(compile-time)、链接时间(link-time)、运行时间(run-time)以及空闲时间(idle-time)，对开发者保持开放，并兼容已有脚本。</p>
<p>Clang 可以用来编译 C，C++，ObjectiveC 等语言，是以 LLVM 为后端的一款高效易用，并且与 IDE 结合很好的编译前端。它的目标是提供一个 GNU 编译器套装(GCC)的替代品，支持了 GNU 编译器大多数的编译设置以及非官方语言的扩展。</p>
<p>LLVM 计划启动于 2000 年，最初由美国 UIUC 大学的 Chris Lattner 博士主持开展。2006 年 Chris Lattner 加盟 Apple Inc. 并致力于 LLVM 在 Apple 开发体系中的应用。Apple 也是 LLVM 计划的主要资助者。目前 LLVM 已经被苹果 IOS 开发工具、Xilinx Vivado、Facebook、Google 等各大公司采用。</p>
<p>严格来讲，LLVM 不是一个编译器或编译器后端，而是编译器基础设施框架(The LLVM Compiler Infrastructure)。但是很多语境会把 LLVM 当作后端。在理解 LLVM 时，可以认为它包括了一个狭义的 LLVM 和一个广义的 LLVM。广义的 LLVM 就是指 The LLVM Compiler Infrastructure，可以理解为这是一个用来构造编译器的工具；而狭义的 LLVM 其实就是聚焦于编译器后端功能（代码生成、代码优化、JIT 等）的一系列模块和库。</p>
<p>从功能上讲，GCC &#x3D; Clang + 狭义的 LLVM。GCC 包括前端部分、中间优化部分和后端部分；而 Clang 负责前端，狭义的 LLVM 负责优化和后端部分。</p>
<h1 id="Make-x2F-CMake"><a href="#Make-x2F-CMake" class="headerlink" title="Make&#x2F;CMake"></a>Make&#x2F;CMake</h1><p>有了编译器 GCC 等等， <strong>为什么要有 make 这个构建生成器</strong>，同样是老生常谈的内容。</p>
<p>编译 hello.c 非常简单，只需要</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">$ gcc hello.c</span><br></pre></td></tr></table></figure>

<p>就可以了，但当项目庞大起来后，假设 hello.c 依赖与 a.c、b.c，而 a.c 又依赖于库 w.lib，每一次编译，我们都要重新编写一次 gcc 编译命令行吗？</p>
<p>所以，GNU 发明了 make 这个工具软件，可以编写 makefile 文件来指定特定的项目构建过程，当项目一个文件的代码更改时，我们只需要重新 make 一下就可以了。</p>
<p>但 make 依然有很多不足，比如</p>
<ol>
<li>make 对于类 unix 系统是通用的，但对 windows 系统并不友好(不能跨平台)</li>
<li>make 语法简单，也就导致了它功能的限制</li>
<li>不同编译器的语法规则不同，编写的 makefile 语法如果适合 GCC 则不适合 MSVC</li>
</ol>
<p>所以，CMake 就应运而生啦。</p>
<p><strong>CMake 是比 Make 更高一层的工具</strong>，Make 是编写对应编译器的 makefile 从而实现编译，而 CMake 是写一份独立的 CmakeList.txt 文件，然后该文件会根据当前系统环境选择适合的构建生成器（如 VS 或者 make），然后将 CmakeList.txt 翻译为适合的文件，再进一步调用系统编译器进行项目构建。</p>
<h1 id="参考内容"><a href="#参考内容" class="headerlink" title="参考内容"></a>参考内容</h1><p><a href="https://zhuanlan.zhihu.com/p/401188789">给萌新的C&#x2F;C++环境搭建攻略（VSCode和MSYS2） - 知乎 (zhihu.com)</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/448884264">捋一捋gcc&#x2F;g++&#x2F;MingW&#x2F;MSVC与make&#x2F;CMake的关系 - 知乎 (zhihu.com)</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/357803433">详解三大编译器：gcc、llvm 和 clang - 知乎 (zhihu.com)</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/424081696">GCC和clang&#x2F;LLVM - 知乎 (zhihu.com)</a></p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux screen基本用法</title>
    <url>/2022/06/13/Linux-screen%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<h1 id="创建-screen"><a href="#创建-screen" class="headerlink" title="创建 screen"></a>创建 screen</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">screen -S screen名称</span><br></pre></td></tr></table></figure>

<h1 id="进入-screen"><a href="#进入-screen" class="headerlink" title="进入 screen"></a>进入 screen</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">screen -r screen名称/ID</span><br><span class="line">screen -d -r screen名称/ID</span><br></pre></td></tr></table></figure>

<h1 id="展示-screen-列表"><a href="#展示-screen-列表" class="headerlink" title="展示 screen 列表"></a>展示 screen 列表</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">screen -ls</span><br></pre></td></tr></table></figure>

<h1 id="关闭-screen"><a href="#关闭-screen" class="headerlink" title="关闭 screen"></a>关闭 screen</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">screen -S screenID -X quit</span><br></pre></td></tr></table></figure>

<h1 id="切回主屏幕"><a href="#切回主屏幕" class="headerlink" title="切回主屏幕"></a>切回主屏幕</h1><p>ctrl + A + D</p>
<p><a href="https://www.runoob.com/linux/linux-comm-screen.html">菜鸟教程上的Linux screen命令</a></p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>知识备忘</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux问题指南</title>
    <url>/2022/08/05/Linux%E9%97%AE%E9%A2%98%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<h1 id="Screen"><a href="#Screen" class="headerlink" title="Screen"></a>Screen</h1><p>以前写过了，可以搜索”Linux screen基本用法”查看。</p>
<h1 id="统计文件数量"><a href="#统计文件数量" class="headerlink" title="统计文件数量"></a>统计文件数量</h1><h2 id="一般统计方法"><a href="#一般统计方法" class="headerlink" title="一般统计方法"></a>一般统计方法</h2><ul>
<li>统计当前目录下文件的个数（不包括目录）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ls -l | grep &quot;^-&quot; | wc -l</span><br></pre></td></tr></table></figure>

<ul>
<li>统计当前目录下文件的个数（包括子目录）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ls -lR| grep &quot;^-&quot; | wc -l</span><br></pre></td></tr></table></figure>

<ul>
<li>查看某目录下文件夹(目录)的个数（包括子目录）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ls -lR | grep &quot;^d&quot; | wc -l</span><br></pre></td></tr></table></figure>

<ul>
<li>统计当前文件夹下叫某某的文件的数量</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find . -name filename | wc -l</span><br></pre></td></tr></table></figure>

<ul>
<li>统计当前文件夹下指定类型的文件的数量</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find -name &quot;*.js&quot; | wc -l</span><br></pre></td></tr></table></figure>

<p><strong>命令的解释</strong></p>
<ul>
<li>ls -l</li>
</ul>
<p>长列表输出该目录下文件信息(注意这里的文件是指目录、链接、设备文件等)，每一行对应一个文件或目录，ls -lR 是列出所有文件，包括子目录。</p>
<ul>
<li>grep “^-“</li>
</ul>
<p>过滤ls的输出信息，只保留一般文件，只保留目录是 grep “^d”。</p>
<ul>
<li>wc -l</li>
</ul>
<p>统计输出信息的行数，统计结果就是输出信息的行数，一行信息对应一个文件，所以就是文件的个数。</p>
<h2 id="文件数量太多的统计方法"><a href="#文件数量太多的统计方法" class="headerlink" title="文件数量太多的统计方法"></a>文件数量太多的统计方法</h2><p>原文中有处理方法，我暂时用不到，不补充了。</p>
<p><a href="https://laowangblog.com/linux-check-the-number-of-files.html">原文：Linux 统计文件夹目录下文件数量教程</a></p>
<h1 id="CentOS7安装java17"><a href="#CentOS7安装java17" class="headerlink" title="CentOS7安装java17"></a>CentOS7安装java17</h1><p>这个是开 MC 高版本服务器的时候弄的，具体会写在建服的文章里。待补充</p>
<h1 id="文件传输"><a href="#文件传输" class="headerlink" title="文件传输"></a>文件传输</h1><p>由于本人暂时只使用过 lrzsz 与简单尝试过 ftp ，因此暂时不打算整理，只是先将当初的2篇参考文章列一下。</p>
<p><a href="https://blog.csdn.net/qq_19734597/article/details/120331359">Linux 几种文件传输方式</a></p>
<p><a href="https://www.runoob.com/linux/linux-comm-ftp.html">Linux ftp命令</a></p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>知识备忘</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Numpy 三维数组索引问题</title>
    <url>/2022/06/13/Numpy-%E4%B8%89%E7%BB%B4%E6%95%B0%E7%BB%84%E7%B4%A2%E5%BC%95%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>我不用说话，这里借用别人博客（<a href="https://blog.csdn.net/king52113141314/article/details/108405364">原博客</a>）里的几张图就很清楚啦。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a1 = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">              [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>],</span><br><span class="line">              [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]])</span><br></pre></td></tr></table></figure>

<p><img src="/2022/06/13/Numpy-%E4%B8%89%E7%BB%B4%E6%95%B0%E7%BB%84%E7%B4%A2%E5%BC%95%E9%97%AE%E9%A2%98/1.png" alt="img"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a2 = np.array([[[<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>], [<span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>], [<span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>]],</span><br><span class="line">               [[<span class="number">20</span>, <span class="number">21</span>, <span class="number">22</span>], [<span class="number">23</span>, <span class="number">24</span>, <span class="number">25</span>], [<span class="number">26</span>, <span class="number">27</span>, <span class="number">28</span>]],</span><br><span class="line">               [[<span class="number">30</span>, <span class="number">31</span>, <span class="number">32</span>], [<span class="number">33</span>, <span class="number">34</span>, <span class="number">35</span>], [<span class="number">36</span>, <span class="number">37</span>, <span class="number">38</span>]]])</span><br></pre></td></tr></table></figure>

<p><img src="/2022/06/13/Numpy-%E4%B8%89%E7%BB%B4%E6%95%B0%E7%BB%84%E7%B4%A2%E5%BC%95%E9%97%AE%E9%A2%98/2.png" alt="img"></p>
<p><img src="/2022/06/13/Numpy-%E4%B8%89%E7%BB%B4%E6%95%B0%E7%BB%84%E7%B4%A2%E5%BC%95%E9%97%AE%E9%A2%98/3.png" alt="img"></p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>知识备忘</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>O(nlogn)数组寻找差值</title>
    <url>/2022/03/25/O-nlogn-%E6%95%B0%E7%BB%84%E5%AF%BB%E6%89%BE%E5%B7%AE%E5%80%BC/</url>
    <content><![CDATA[<p>设一个长度为$n$的数组$a$，与一个数$k$，问数组中是否存在$2$个数$a$、$b$使得$| a - b | &#x3D; k$。</p>
<ol>
<li>对原数组排序。</li>
<li>对原数组去重得到数组$b$，长度为$len$。</li>
<li>扩充数组$b$至长度为$2 \cdot len$使得$b_{i + len} &#x3D; b_i - k$。</li>
<li>对扩充后的数组排序。</li>
<li>寻找是否有相邻的相同元素。若有，则存在；反之不存在。</li>
</ol>
<p>会有更简单的办法，但我暂时是想出来了这个。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[<span class="number">200010</span>];</span><br><span class="line"><span class="type">int</span> b[<span class="number">400010</span>],len;</span><br><span class="line">   </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solv</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">  </span><br><span class="line">    <span class="built_in">sort</span>(a+<span class="number">1</span>,a+n+<span class="number">1</span>);</span><br><span class="line">  </span><br><span class="line">    len=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n*<span class="number">2</span>;i++) b[i]=<span class="number">0</span>;</span><br><span class="line">    b[len]=<span class="number">1000000010</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">if</span>(a[i]!=b[len]) b[++len]=a[i];</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=len;i++) b[i+len]=b[i]-k;</span><br><span class="line">  </span><br><span class="line">    <span class="built_in">sort</span>(b+<span class="number">1</span>,b+len*<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=len*<span class="number">2</span><span class="number">-1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="keyword">if</span>(b[i]==b[i+<span class="number">1</span>])</span><br><span class="line">    	&#123;</span><br><span class="line">    		<span class="built_in">printf</span>(<span class="string">&quot;YES\n&quot;</span>);</span><br><span class="line">    		<span class="keyword">return</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;NO\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>OI 知识</tag>
      </tags>
  </entry>
  <entry>
    <title>PyTorch问题指南</title>
    <url>/2022/08/09/PyTorch%E9%97%AE%E9%A2%98%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<p><strong>写在前面</strong></p>
<p>2022&#x2F;8&#x2F;9</p>
<p>本人水平还较弱，没有足够的项目经验，因此内容里很可能有含糊不清和错误之处，请谨慎参考。</p>
<h1 id="train、eval模式"><a href="#train、eval模式" class="headerlink" title="train、eval模式"></a>train、eval模式</h1><p><code>model.train()</code>和 <code>model.eval()</code>分别要在训练和测试中写，它们的作用如下：</p>
<ul>
<li><p><code>model.train()</code></p>
<p>启用 BatchNormalization 和 Dropout，将两者置为 True 。</p>
</li>
<li><p><code>model.eval()</code></p>
<p>不启用 BatchNormalization 和 Dropout，将两者置为 False 。</p>
</li>
</ul>
<p><strong>总结</strong></p>
<ol>
<li>在训练模块中一定要写 <code>model.train()</code>。</li>
<li>在评估（或测试）模块中一定要写 <code>model.eval()</code>。</li>
</ol>
<p><a href="https://blog.csdn.net/sinat_36618660/article/details/100147506?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-1-100147506-blog-122145651.pc_relevant_default&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-1-100147506-blog-122145651.pc_relevant_default&utm_relevant_index=2">原文</a></p>
<h1 id="forward"><a href="#forward" class="headerlink" title="forward"></a>forward</h1><p>在使用 PyTorch 进行模型训练时，我们可以通过直接向实例化的对象内直接传参即可实现 forward 函数的自动调用，即 <code>model(data)</code>等价于 <code>model.forward(data)</code>，这很方便，<strong>其原理是在类（class）中使用了 __call__ 函数</strong>。有关 __call__ 的内容我在另一篇名为“Python问题指南”的文中有抄录，可以搜索查看。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, param</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;I can called like a function&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;传入参数的类型是：&#123;&#125;   值为： &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">type</span>(param), param))</span><br><span class="line"></span><br><span class="line">        res = self.forward(param)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, input_</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;forward 函数被调用了&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;in  forward, 传入参数类型是：&#123;&#125;  值为: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">type</span>(input_), input_))</span><br><span class="line">        <span class="keyword">return</span> input_</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = Student()</span><br><span class="line"></span><br><span class="line">input_param = a(<span class="string">&#x27;data&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;对象a传入的参数是：&quot;</span>, input_param)</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">I can called like a function</span><br><span class="line">传入参数的类型是：&lt;class &#x27;str&#x27;&gt;   值为： data</span><br><span class="line">forward 函数被调用了</span><br><span class="line">in  forward, 传入参数类型是：&lt;class &#x27;str&#x27;&gt;  值为: data</span><br><span class="line">对象a传入的参数是： data</span><br></pre></td></tr></table></figure>

<p><a href="https://zhuanlan.zhihu.com/p/357021687">原文</a></p>
<h1 id="F-pad"><a href="#F-pad" class="headerlink" title="F.pad"></a>F.pad</h1><p>暂未深入研究，贴一篇<a href="https://blog.csdn.net/qq_36998053/article/details/123702623">文章</a>。</p>
<h1 id="优化器Optimizer"><a href="#优化器Optimizer" class="headerlink" title="优化器Optimizer"></a>优化器Optimizer</h1><p><strong>优化器</strong>主要用在模型训练阶段，用于更新模型中可学习的参数。<code>torch.optim</code>提供了多种优化器<strong>接口</strong>，比如 Adam 、 RAdam 、 SGD 、 ASGD 、 LBFGS 等，<code>Optimizer</code>是所有这些优化器的<strong>父类</strong>。</p>
<p><strong>主要方法</strong></p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>官方注解</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>add_param_group</td>
<td>Add a param group to the Optimizer’s param_groups.</td>
<td>给优化器添加模型中可学习的参数组。</td>
</tr>
<tr>
<td>step</td>
<td>Performs a single optimization step (parameter update).</td>
<td>进行一次参数更新。</td>
</tr>
<tr>
<td>zero_grad</td>
<td>Sets the gradients of all optimized torch.Tensor to zero.</td>
<td>将上次记录的梯度信息置零，避免梯度累加。</td>
</tr>
<tr>
<td>state_dict</td>
<td>Returns the state of the optimizer as a dict.</td>
<td>以字典形式返回优化器的状态信息。</td>
</tr>
<tr>
<td>load_state_dict</td>
<td>Loads the optimizer state.</td>
<td>加载以字典形式存储的优化器状态信息。</td>
</tr>
</tbody></table>
<p><a href="https://blog.csdn.net/hottie_xiaomiao/article/details/124392847">原文在这里</a>，我现在的水平后面看不懂了……以后补。同时还有一篇<a href="https://zhuanlan.zhihu.com/p/445009191">相关文章</a>。</p>
<h1 id="with-torch-no-grad"><a href="#with-torch-no-grad" class="headerlink" title="with torch.no_grad()"></a>with torch.no_grad()</h1><p><code>torch.no_grad()</code> 是一个上下文管理器，被该语句 wrap（包裹） 起来的部分将不会 track（跟踪） 梯度。</p>
<p>例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = torch.tensor([<span class="number">1.1</span>], requires_grad=<span class="literal">True</span>)</span><br><span class="line">b = a * <span class="number">2</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">b</span><br><span class="line">Out[<span class="number">63</span>]: tensor([<span class="number">2.2000</span>], grad_fn=&lt;MulBackward0&gt;)</span><br></pre></td></tr></table></figure>

<p>打印b可看到其 grad_fn 为 mulbackward 表示是做的乘法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">b.add_(<span class="number">2</span>)</span><br><span class="line">Out[<span class="number">64</span>]: tensor([<span class="number">4.2000</span>], grad_fn=&lt;AddBackward0&gt;)</span><br></pre></td></tr></table></figure>

<p>可以看到不被 wrap 的情况下， b.grad_fn 为 addbackward ，表示这个 add 操作被 track 了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> torch.no_grad():</span><br><span class="line">    b.mul_(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">b</span><br><span class="line">Out[<span class="number">66</span>]: tensor([<span class="number">8.4000</span>], grad_fn=&lt;AddBackward0&gt;)</span><br></pre></td></tr></table></figure>

<p>在被包裹的情况下可以看到 b.grad_fn 还是为 add ， mul 操作没有被 track 。但是注意，乘法操作是被执行了的。</p>
<p>所以如果有不想被 track 的计算部分可以通过这么一个上下文管理器包裹起来。这样可以执行计算，但该计算不会在反向传播中被记录。</p>
<p><a href="https://blog.csdn.net/weixin_46559271/article/details/105658654">原文</a></p>
<h1 id="torch-optim-lr-scheduler-ReduceLROnPlateau"><a href="#torch-optim-lr-scheduler-ReduceLROnPlateau" class="headerlink" title="torch.optim.lr_scheduler.ReduceLROnPlateau"></a>torch.optim.lr_scheduler.ReduceLROnPlateau</h1><p>当网络的<a href="https://so.csdn.net/so/search?q=%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87&spm=1001.2101.3001.7020">评价指标</a>不在提升的时候，可以通过降低网络的学习率来提高网络性能。所使用的类：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">torch</span>.optim.lr_scheduler.ReduceLROnPlateau(optimizer, mode=<span class="string">&#x27;min&#x27;</span>, factor=<span class="number">0.1</span>, patience=<span class="number">10</span>,</span><br><span class="line"> verbose=<span class="literal">False</span>, threshold=<span class="number">0.0001</span>, threshold_mode=<span class="string">&#x27;rel&#x27;</span>, cooldown=<span class="number">0</span>, min_lr=<span class="number">0</span>, eps=<span class="number">1e-08</span>)</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li>optimer指的是网络的优化器</li>
<li>mode (str) ，可选择‘min’或者‘max’，min表示当监控量停止下降的时候，学习率将减小，max表示当监控量停止上升的时候，学习率将减小。默认值为‘min’</li>
<li>factor 学习率每次降低多少，new_lr &#x3D; old_lr * factor</li>
<li>patience&#x3D;10，容忍网路的性能不提升的次数，高于这个次数就降低学习率</li>
<li>verbose（bool） - 如果为True，则为每次更新向stdout输出一条消息。 默认值：False</li>
<li>threshold（float） - 测量新最佳值的阈值，仅关注重大变化。 默认值：1e-4</li>
<li>cooldown： 减少lr后恢复正常操作之前要等待的时期数。 默认值：0</li>
<li>min_lr,学习率的下限</li>
<li>eps ，适用于lr的最小衰减。 如果新旧lr之间的差异小于eps，则忽略更新。 默认值：1e-8。</li>
</ul>
<p><strong>注意</strong></p>
<p>使用的时候需要选择网络的度量指标，使用如下类的step方法实现，例子如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">optimizer = torch.optim.SGD(model.parameters(), lr=<span class="number">0.01</span>)</span><br><span class="line">scheduler = ReduceLROnPlateau(optimizer, <span class="string">&#x27;min&#x27;</span>,factor=<span class="number">0.5</span>, patience=<span class="number">4</span>, verbose=<span class="literal">True</span>)</span><br><span class="line">.....</span><br><span class="line">scheduler.step(train_loss)</span><br><span class="line"><span class="comment"># scheduler.step(val_loss)</span></span><br></pre></td></tr></table></figure>

<p><a href="https://blog.csdn.net/weixin_40100431/article/details/84311430">原文</a></p>
<h1 id="自动混合精度（AMP）"><a href="#自动混合精度（AMP）" class="headerlink" title="自动混合精度（AMP）"></a>自动混合精度（AMP）</h1><p>先贴文章：</p>
<p><a href="https://www.cnblogs.com/jimchen1218/p/14315008.html">文章1</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/165152789">文章2</a></p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>知识备忘</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python问题指南</title>
    <url>/2022/08/05/Python%E9%97%AE%E9%A2%98%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<h1 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h1><p><code>_</code>在 python 中可以作为一个<strong>标识符</strong>，用于定义变量和方法唯一名称。同时它也是 Python 中的一个<strong>软关键字</strong>，指在某些特定上下文中保留的关键字。截至 python3.10 共有3个软关键字：<code>match</code>，<code>case</code>和 <code>_</code>。</p>
<p><strong>直接使用</strong></p>
<p><code>_</code>可直接当作变量名使用，也可做变量单词间的分隔符（如 <code>student_num</code>）。</p>
<p><code>_*</code><strong>格式</strong></p>
<p>当使用 <code>from &lt;module&gt; import *</code> 语句调用某个模块中的所有变量和方法时，以 <code>_</code>开头的变量和方法不会被导入进脚本中，不属于 API。</p>
<p>这类似于其他语言中的私有变量 private ，意味着<strong>该方法或属性不应该被从外部直接调用</strong>。</p>
<p>不过，如果使用对test2.py的引用格式（<code>import test2</code>），则可以使用其中 _* 格式的变量，不过<strong>不建议这样使用（作者将其封装为私有变量就是不想让我们随意调用他们）</strong>。</p>
<p><code>__*</code><strong>格式</strong></p>
<p>通常会作为类中的私有变量的名称，访问该类时无法直接通过变量名访问。不过也并不是真的不能访问，使用 <code>__*</code> 命名的变量会在类中被重写为形如 <code>_类名__*</code> 的格式。</p>
<p>这被称为<strong>私有名称转换</strong>：这样做是为了避免基类及派生类的 “私有” 属性之间产生名称冲突。我们可以通过转换后的变量名称来访问变量。<br> 但是并不推荐这样做，他们<strong>应该只在该类内被访问和使用</strong>。</p>
<p><code>__*__</code><strong>格式</strong></p>
<p><strong>在类中使用并重写</strong>的方法或变量，如 <code>__init__(self)</code>。</p>
<p>他们是系统定义的特殊方法名称，通常称为‘dunder’，这些名称由解释器和标准库定义。所有特殊方法可见：<a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#specialnames">https://docs.python.org/zh-cn/3/reference/datamodel.html#specialnames</a> 。</p>
<p>可以使用 <code>__dir__()</code> 方法查看一个对象的所有方法和变量，其中包括特殊方法。</p>
<p><a href="https://blog.csdn.net/weixin_43863487/article/details/125056015">参考</a></p>
<h2 id="if-name-x3D-x3D-‘-main-’"><a href="#if-name-x3D-x3D-‘-main-’" class="headerlink" title="if __name__ &#x3D;&#x3D; ‘__main__’:"></a>if __name__ &#x3D;&#x3D; ‘__main__’:</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br></pre></td></tr></table></figure>

<p>解释这句话的含义：</p>
<p>同一目录下创建两个文件：</p>
<p>candf.py</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">摄氏度和华氏度的相互转换模块</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">c2f</span>(<span class="params">cel</span>):</span><br><span class="line">    fah = cel * <span class="number">1.8</span> + <span class="number">32</span></span><br><span class="line">    <span class="keyword">return</span> fah</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f2c</span>(<span class="params">fah</span>):</span><br><span class="line">    cel = (fah - <span class="number">32</span>) / <span class="number">1.8</span></span><br><span class="line">    <span class="keyword">return</span> cel</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;测试数据：0 摄氏度 = %.2f 华氏度&quot;</span> % c2f(<span class="number">0</span>))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;测试数据：0 华氏度 = %.2f 摄氏度&quot;</span> % f2c(<span class="number">0</span>))</span><br><span class="line">test()</span><br></pre></td></tr></table></figure>

<p>demo.py</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> candf</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;32 摄氏度 = %.2f 华氏度&quot;</span> % candf.c2f(<span class="number">32</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;99 华氏度 = %.2f 摄氏度&quot;</span> % candf.f2c(<span class="number">99</span>))</span><br></pre></td></tr></table></figure>

<p>运行 demo.py ，看到结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">测试数据：0 摄氏度 = 32.00 华氏度</span><br><span class="line">测试数据：0 华氏度 = -17.78 摄氏度</span><br><span class="line">32 摄氏度 = 89.60 华氏度</span><br><span class="line">99 华氏度 = 37.22 摄氏度</span><br></pre></td></tr></table></figure>

<p>可见 python 将 candf.py 中的测试内容也执行了，这不是我们想要的。想要避免这种情况的关键在于，要让 Python 解释器知道，当前要运行的程度代码，是模块文件本身，还是导入模块的其它程序。</p>
<p>因此在 demo.py 中增添如下代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(__name__)</span><br><span class="line"><span class="built_in">print</span>(candf.__name__)</span><br></pre></td></tr></table></figure>

<p>看到结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__main__</span><br><span class="line">candf</span><br></pre></td></tr></table></figure>

<p>可以看到，当前运行的程序，其 <code>__name__</code>的值为 <code>__main__</code>，而导入到当前程序中的模块，其 <code>__name__</code>值为自己的模块名。</p>
<p> 因此，<code>if __name__ == &#39;__main__&#39;:</code> 的作用是确保只有单独运行该模块时，此表达式才成立，才可以进入此判断语法，执行其中的测试代码；反之，如果只是作为模块导入到其他程序文件中，则此表达式将不成立，运行其它程序时，也就不会执行该判断语句中的测试代码。</p>
<p><a href="http://c.biancheng.net/view/4643.html">参考</a></p>
<h2 id="call"><a href="#call" class="headerlink" title="__call__"></a>__call__</h2><p>该方法的功能类似于在类中重载 () 运算符，使得类实例对象可以像调用普通函数那样，以“对象名()”的形式使用。</p>
<p><strong>作用：</strong>为了将<strong>类的实例对象</strong>变为可调用对象。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>:</span><br><span class="line">    <span class="comment"># 定义__call__方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self,<span class="built_in">str</span></span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;调用__call__()方法&quot;</span>,<span class="built_in">str</span>)</span><br><span class="line"></span><br><span class="line">t = Test()</span><br><span class="line">t(<span class="string">&quot;Hello&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">调用__call__()方法 Hello</span><br></pre></td></tr></table></figure>

<p>可以看到，通过在 Test 类中实现 __call__() 方法，使得 t 实例对象变为了可调用对象。</p>
<blockquote>
<p>Python 中，凡是可以将 () 直接应用到自身并执行，都称为可调用对象。可调用对象包括自定义的函数、Python 内置函数以及本节所讲的类实例对象。</p>
</blockquote>
<p>对于可调用对象，实际上“名称()”可以理解为是“名称.__call__()”的简写。仍以上面程序中定义的 t 实例对象为例，其最后一行代码还可以改写为如下形式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">t.__call__(<span class="string">&quot;Hello&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>运行程序会发现，其运行结果和之前完全相同。</p>
<p><a href="https://zhuanlan.zhihu.com/p/356059224">参考</a></p>
<h1 id="super"><a href="#super" class="headerlink" title="super()"></a>super()</h1><p><strong>简单理解</strong></p>
<ul>
<li><code>super()</code>的作用是按照 MRO 寻找最近的来执行</li>
<li>可以简单理解成「寻找父类的方法」</li>
<li>类的 <strong>init</strong> 中非常常见，为了防止父类未被按照合适的方法被初始化</li>
</ul>
<p><strong>详细一点解释</strong></p>
<p><code>super()</code>解决了子类调用父类方法的一些问题， 父类多次被调用时只执行一次， 优化了执行逻辑。</p>
<p>当存在继承关系的时候，有时候需要在子类中调用父类的方法，此时最简单的方法是把对象调用转换成类调用，需要注意的是这时self参数需要显式传递，例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FooParent</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">bar</span>(<span class="params">self, message</span>):</span><br><span class="line">    <span class="built_in">print</span>(message)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FooChild</span>(<span class="title class_ inherited__">FooParent</span>):</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">bar</span>(<span class="params">self, message</span>):</span><br><span class="line">    FooParent.bar(self, message)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; FooChild().bar(&quot;Hello, Python.&quot;)</span><br><span class="line">Hello, Python.</span><br></pre></td></tr></table></figure>

<p>这样做有一些缺点，比如说如果修改了父类名称，那么在子类中会涉及多处修改，另外， Python 是允许多继承的语言，如上所示的方法在多继承时就需要重复写多次，显得累赘。为了解决这些问题， Python 引入了 <code>super()</code>机制，例子代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FooParent</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">bar</span>(<span class="params">self, message</span>):</span><br><span class="line">    <span class="built_in">print</span>(message)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FooChild</span>(<span class="title class_ inherited__">FooParent</span>):</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">bar</span>(<span class="params">self, message</span>):</span><br><span class="line">    <span class="built_in">super</span>(FooChild, self).bar(message)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; FooChild().bar(&quot;Hello, Python.&quot;)</span><br><span class="line">Hello, Python.</span><br></pre></td></tr></table></figure>

<p>表面上看 <code>super(FooChild, self).bar(message)</code>方法和 <code>FooParent.bar(self, message)</code>方法的结果是一致的，实际上这两种方法的内部处理机制大大不同，不能理解为<strong>“<code>super()</code>就是用来调用父类的方法的”，</strong>当涉及多继承情况时，就会表现出明显的差异来。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;A&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>(<span class="title class_ inherited__">A</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;B&quot;</span>)</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>(<span class="title class_ inherited__">A</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;C&quot;</span>)</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>(B, C):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;D&quot;</span>)</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">D() </span><br></pre></td></tr></table></figure>

<p>理论执行结果：D B A C A</p>
<p>实际执行结果：D B C A</p>
<p>在 <code>super()</code>机制里可以保证公共父类仅被执行一次，其调用顺序是遵循 Python 的 <strong>MRO （方法解析顺序）</strong>来执行的，在 Python3 中，MRO 是基于 C3 算法来实现的。</p>
<p><strong>参考</strong></p>
<p><a href="https://segmentfault.com/q/1010000013475016">https://segmentfault.com/q/1010000013475016</a></p>
<p><a href="https://www.jianshu.com/p/45619cf50aa7">https://www.jianshu.com/p/45619cf50aa7</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/415729655">https://zhuanlan.zhihu.com/p/415729655</a></p>
<h1 id="符号"><a href="#符号" class="headerlink" title="@符号"></a>@符号</h1><h2 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h2><p>简单理解为把@函数下面的函数作为参数传入了@函数，即在函数外面套上了@函数进行“修饰”。</p>
<p>可以在模块或者类的定义层内对函数进行修饰。出现在函数定义的前一行，不允许和函数定义在同一行。</p>
<p><strong>单次使用</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">funcB</span>(<span class="params">funa</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;function B&quot;</span>)</span><br><span class="line">    funa()</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;test&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@funcB</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">funcA</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;function A&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(funcA)</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function B</span><br><span class="line">function A</span><br><span class="line">test</span><br></pre></td></tr></table></figure>

<p>可以理解为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">funcA = funcB(funcA)</span><br><span class="line"># 如果没有print(funcA)那句便会执行funcA</span><br></pre></td></tr></table></figure>

<p>使用 <code>funcB</code>修饰 <code>funcA</code>。</p>
<p><strong>多次使用</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">funcA</span>(<span class="params">A</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;function A&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(A)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">funcB</span>(<span class="params">B</span>):</span><br><span class="line">    <span class="built_in">print</span>(B(<span class="number">2</span>))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;function B&quot;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="meta">@funcA</span></span><br><span class="line"><span class="meta">@funcB</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">funcC</span>(<span class="params">C</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;function C&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> C ** <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function C</span><br><span class="line">4</span><br><span class="line">function B</span><br><span class="line">function A</span><br><span class="line">None</span><br></pre></td></tr></table></figure>

<p>可以理解为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">funcC = funcB(funcA(func))</span><br><span class="line"><span class="comment"># 这里就是没有使用funcC的情况，会自动执行funcC</span></span><br><span class="line">funcC</span><br></pre></td></tr></table></figure>

<p>先把 <code>funcA</code>修饰 <code>funcC</code>，之后用 <code>funcB</code>修饰这个整体，最后执行。</p>
<p><strong>带有参数</strong></p>
<p>更多的看<a href="https://www.jianshu.com/p/7a644520418b">这篇文章</a>吧，我水平不足还不能完全理解。</p>
<h2 id="staticmethod-和-classmethod"><a href="#staticmethod-和-classmethod" class="headerlink" title="@staticmethod 和  @classmethod"></a>@staticmethod 和  @classmethod</h2><p>@staticmethod 相当于 C++ 里的静态函数。</p>
<p>@classmethod 相当于 C++ 里常用的一个类调用 Create 来创建自身的用法。</p>
<h2 id="property"><a href="#property" class="headerlink" title="@property"></a>@property</h2><p>看<a href="https://zhuanlan.zhihu.com/p/64487092">这篇文章</a>。</p>
<h2 id="矩阵乘法"><a href="#矩阵乘法" class="headerlink" title="矩阵乘法"></a>矩阵乘法</h2><p>如题，但不常用。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.jianshu.com/p/7a644520418b">https://www.jianshu.com/p/7a644520418b</a></p>
<p><a href="https://www.jb51.net/article/231703.htm">https://www.jb51.net/article/231703.htm</a></p>
<p><a href="https://guoleida.blog.csdn.net/article/details/85001493?spm=1001.2101.3001.6661.1&amp;utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~default-1-85001493-blog-89333359.pc_relevant_multi_platform_whitelistv3&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~default-1-85001493-blog-89333359.pc_relevant_multi_platform_whitelistv3&amp;utm_relevant_index=1">https://guoleida.blog.csdn.net/article/details/85001493?spm=1001.2101.3001.6661.1&amp;utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1-85001493-blog-89333359.pc_relevant_multi_platform_whitelistv3&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1-85001493-blog-89333359.pc_relevant_multi_platform_whitelistv3&amp;utm_relevant_index=1</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/162352611">https://zhuanlan.zhihu.com/p/162352611</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/64487092">https://zhuanlan.zhihu.com/p/64487092</a></p>
<h1 id="pass"><a href="#pass" class="headerlink" title="pass"></a>pass</h1><p><code>pass</code>是空语句，是为了保持程序结构的完整性，它不做任何事情，一般用做占位语句。</p>
<p>在 Python 中有时候会看到一个 def 函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sample</span>(<span class="params">n_samples</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p>该处的 <code>pass</code>便是占据一个位置，因为如果定义一个空函数程序会报错，当你没有想好函数的内容是可以用 pass 填充，使程序可以正常运行。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>知识备忘</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity学习笔记-日记</title>
    <url>/2022/07/16/Unity%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>你在浏览的“Unity学习笔记”由三大板块组成：</p>
<ul>
<li>Unity学习笔记-索引</li>
</ul>
<p>用来按知识索引日记与笔记，属于“十字路口”下的一部分。</p>
<ul>
<li>Unity学习笔记-日记</li>
</ul>
<p>用来按日期记录日常，属于“悠哉日常”下的一部分。</p>
<ul>
<li>Unity学习笔记-笔记</li>
</ul>
<p>用来按日期记录知识，属于“游戏开发”下的一部分。</p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="2022-07-16"><a href="#2022-07-16" class="headerlink" title="2022-07-16"></a>2022-07-16</h2><p>在大概 1 年前，我狠下心克制了自己的懒癌晚期，跟随 <a href="https://space.bilibili.com/370283072?from=search&seid=12449235407068253111&spm_id_from=333.337.0.0">M_Studio 老师</a>免费学习了许多 2D 开发所需的知识，建立了初步的知识框架并完成了“小狐狸”等项目，随后又利用学到的知识自己开发了一个劣质的“打飞机”游戏和仿作了经典的“合成大西瓜”游戏。但随后伴随着上学和懒癌发作，在 1 年内都没有后续了，直到最近我重燃了做游戏的想法，并且脑子里又有了几个以我的实力也许能够实现的游戏蓝图。因为在今年我创立了自己的博客，是一个很好的记笔记的地方，于是我打算把学习的过程记录下来。</p>
<p>最近在跟学 M_Studio 老师的<a href="https://www.bilibili.com/video/BV1jg4y1v7qC?spm_id_from=333.999.0.0&vd_source=6f67cf3df36c1099236303f99c042178">开发2D手机游戏并获得收益(新版)</a>这个付费项目，会把过程中学习到的知识点记录下来。</p>
]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>Unity3D</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity学习笔记-笔记</title>
    <url>/2022/07/16/Unity%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>你在浏览的“Unity学习笔记”由三大板块组成：</p>
<ul>
<li>Unity学习笔记-索引</li>
</ul>
<p>用来按知识索引日记与笔记，属于“十字路口”下的一部分。</p>
<ul>
<li>Unity学习笔记-日记</li>
</ul>
<p>用来按日期记录日常，属于“悠哉日常”下的一部分。</p>
<ul>
<li>Unity学习笔记-笔记</li>
</ul>
<p>用来按日期记录知识，属于“游戏开发”下的一部分。</p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="2022-07-16"><a href="#2022-07-16" class="headerlink" title="2022-07-16"></a>2022-07-16</h2><p><strong>像素图素材修改注意</strong></p>
<p>调整像素图时，一般不止修改 <strong>Pixels Per Unit</strong> ，还要连带修改其它两项：</p>
<p>Pixels Per Unit &#x3D;&gt; 32</p>
<p>Filter Mode &#x3D;&gt; Point(no filter)</p>
<p>Compression &#x3D;&gt; None</p>
<p><strong>update函数与fixedupdate函数的区别</strong></p>
<p><strong>update：</strong>每帧被调用一次</p>
<p><strong>fixedupdate：</strong>每隔 Time.fixedDeltaTime 被调用一次。 Time.fixedDeltaTime 默认是0.02s，可以通过 Edit-&gt;ProjectSettings-&gt;Time 来设置。</p>
<p>因此可以说 update 不稳定， fixedupdate 稳定。</p>
<p><strong>使用 GetAxis 设计2D角色移动</strong></p>
<p>Input.GetAxis() &#x3D;&gt; 数值 -1 到 1 ，包括小数，在移动时有滑动的效果</p>
<p>Input.GetAxisRaw() &#x3D;&gt; 数值 -1 到 1 ，不包括小数，移动直来直去</p>
<p><strong>使用Header语法让变量更清晰</strong></p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">Header(<span class="string">&quot;States Check&quot;</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">bool</span> isGround;</span><br></pre></td></tr></table></figure>

<p><strong>显示一个范围</strong></p>
<p>这个函数是官方自带的。（？）</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnDrawGizmos</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    Gizmos.DrawWireSphere(groundCheck.position, checkRadius);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>知识备忘</tag>
        <tag>Unity3D</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity学习笔记-索引</title>
    <url>/2022/07/16/Unity%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>你在浏览的“Unity学习笔记”由三大板块组成：</p>
<ul>
<li>Unity学习笔记-索引</li>
</ul>
<p>用来按知识索引日记与笔记，属于“十字路口”下的一部分。</p>
<ul>
<li>Unity学习笔记-日记</li>
</ul>
<p>用来按日期记录日常，属于“悠哉日常”下的一部分。</p>
<ul>
<li>Unity学习笔记-笔记</li>
</ul>
<p>用来按日期记录知识，属于“游戏开发”下的一部分。</p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>2022-07-16</p>
<p>像素图素材修改注意</p>
<p>update函数与fixedupdate函数的区别</p>
<p>使用 GetAxis 设计2D角色移动</p>
<p>使用Header语法让变量更清晰b</p>
<p>显示一个范围</p>
]]></content>
      <categories>
        <category>规则</category>
      </categories>
      <tags>
        <tag>Unity3D</tag>
      </tags>
  </entry>
  <entry>
    <title>UwU-net论文第一部分阅读，U-net介绍</title>
    <url>/2022/07/15/UwU-net%E8%AE%BA%E6%96%87%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%E9%98%85%E8%AF%BB%EF%BC%8CU-net%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<p>先附链接：</p>
<p><a href="s42256-021-00309-y.pdf">UwU-net原文</a></p>
<p><a href="UwU-net%E8%AE%BA%E6%96%87%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%E4%BB%8B%E7%BB%8D.pdf">UwU-net论文第一部分介绍</a></p>
<p><a href="U-net%E4%BB%8B%E7%BB%8D.pdf">U-net介绍</a></p>
<p>在搞暑假的煤矿项目的过程中开会的时候我需要报告些东西，第一次报告的是读 UwU-net 这篇论文然后总结标题 <strong>indian Pines classification</strong> 前的部分。本来我是把前面这部分翻译了的（虽然大部分是靠机翻），结果我之前手残弄没了。不过没关系，好在我的总结还在；因为 UwU-net 是基于 U-net 搞出来的，于是我的第二次报告是介绍 U-net ，然后也写了些东西。</p>
<p><strong>免责声明</strong>：这两篇文章因为是我用来讲解的辅助稿，所以内容难免会显草率，很多重要的地方可能是我口述的而在文章上并没有体现，因此如果你打算看了，要抱有图一乐的精神。另外一点是，这里面的图片全是我从别人博客或视频中弄来的（这真的很抱歉），目的是完善我写的内容。我会在下面贴一下被我借鉴图的视频&#x2F;文章的链接。</p>
<p><a href="https://blog.csdn.net/qq_33924470/article/details/106891015">从零开始的U-net入门</a></p>
<p><a href="https://www.bilibili.com/video/BV1Di4y1o7vX?from=search&seid=12747115051071942608&spm_id_from=333.337.0.0&vd_source=6f67cf3df36c1099236303f99c042178">【卷积】直观形象的实例，10分钟彻底搞懂</a></p>
<p><a href="https://blog.csdn.net/Formlsl/article/details/80373200?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~default-1-80373200-blog-106891015.pc_relevant_multi_platform_whitelistv1&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~default-1-80373200-blog-106891015.pc_relevant_multi_platform_whitelistv1&utm_relevant_index=1">深入理解深度学习分割网络Ｕnet——U-Net: Convolutional Networks for Biomedical Image Segmentation</a></p>
<p><a href="https://blog.csdn.net/quiet_girl/article/details/84579038?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165769608716782248599590%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=165769608716782248599590&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-84579038-null-null.142%5Ev32%5Enew_blog_fixed_pos,185%5Ev2%5Econtrol&utm_term=%E6%B1%A0%E5%8C%96&spm=1018.2226.3001.4187">[CNN] 卷积、反卷积、池化、反池化</a></p>
<p><a href="https://blog.csdn.net/weixin_45928096/article/details/123481747?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-1-123481747-blog-82152149.pc_relevant_aa&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-1-123481747-blog-82152149.pc_relevant_aa&utm_relevant_index=1">全卷积神经网络（FCN）和卷积神经网络（CNN）的主要区别</a></p>
<p><a href="https://blog.csdn.net/qq_42722197/article/details/123220252">FCN、Unet、Unet++：医学图像分割网络一览</a></p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>gcd&amp;lcm（待完善）</title>
    <url>/2022/03/10/gcd-lcm/</url>
    <content><![CDATA[<h1 id="gcd"><a href="#gcd" class="headerlink" title="gcd"></a>gcd</h1><p><strong>辗转相除法（欧几里得）：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">gcd</span>(b,a%b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="lcm"><a href="#lcm" class="headerlink" title="lcm"></a>lcm</h1><p>$$<br>a \cdot b &#x3D; \gcd(a, b) * lcm(a, b)<br>$$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lcm</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a/<span class="built_in">gcd</span>(a,b)*b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="一些性质"><a href="#一些性质" class="headerlink" title="一些性质"></a>一些性质</h1><p>设两个数$i &#x3D; p_1^{a_1} * p_2^{a_2} * p_3^{a_3} * … * p_s^{a_s}$，$j &#x3D; p_1^{b_1} * p_2^{b_2} * p_3^{b_3} * … * p_s^{b_s}$，则由算术基本定理（又叫整数惟一分解定理）得到：</p>
<p>$\gcd(i, j) &#x3D; p_1^{\min(a_1, b_1)} * p_2^{\min(a_2, b_2)} * p_3^{\min(a_3, b_3)} * … * p_s^{\min(a_s, b_s)}$</p>
<p>$lcm(i,j) &#x3D; p_1^{\max(a_1, b_1)} * p_2^{\max(a_2, b_2)} * p_3^{\max(a_3,b_3)} * … * p_s^{\max(a_s, b_s)}$</p>
<p>简写一下：</p>
<p>设两个数$i &#x3D; \prod^s_{k &#x3D; 1} p_k^{a_k}$，$j &#x3D; \prod^s_{k &#x3D; 1} p_k^{b_k}$，则由算术基本定理（又叫整数惟一分解定理）得到：</p>
<p>$\gcd(i, j) &#x3D; \prod^s_{k &#x3D; 1} p_k^{\min(a_k, b_k)}$</p>
<p>$lcm(i,j) &#x3D; \prod^s_{k &#x3D; 1} p_k^{\max(a_k, b_k)}$</p>
<p><strong>此性质经常与数的质因数分解一起使用。</strong>一些质因数分解的方法请看我的另一篇文章。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>OI 知识</tag>
      </tags>
  </entry>
  <entry>
    <title>OI 【总览】模板与知识索引</title>
    <url>/2024/05/01/%E3%80%90%E6%80%BB%E8%A7%88%E3%80%91OI-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E7%9F%A5%E8%AF%86%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这是一篇动态更新的博客，用于整理自己现有的 OI 知识体系。要注意的是，这篇博客的核心在于整理体系，而不会专注于某内容的具体解释，例如规则详细介绍、算法原理讲解。对于自己已经梳理清楚的内容，将会采用相关链接的方式引导读者自己前去详细学习。</p>
<h1 id="比赛相关"><a href="#比赛相关" class="headerlink" title="比赛相关"></a>比赛相关</h1><h2 id="网站推荐"><a href="#网站推荐" class="headerlink" title="网站推荐"></a>网站推荐</h2><ul>
<li><a href="https://cyanoii.github.io/">渔塘 （逃）</a></li>
<li><a href="https://oi-wiki.org/">OI Wiki</a></li>
<li><a href="https://www.luogu.com.cn/">洛谷</a></li>
<li><a href="https://codeforces.com/">Codeforces</a></li>
<li><a href="https://studyingfather.com/archives/841">一个动态更新的洛谷综合题单 – Studying Father&#39;s blog</a></li>
</ul>
<h1 id="算法基础"><a href="#算法基础" class="headerlink" title="算法基础"></a>算法基础</h1><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p><strong>【简介】</strong></p>
<p>排序算法是一种将一组特定的数据按某种顺序进行排列的算法。排序算法多种多样，性质也大多不同。</p>
<p><strong>【相关链接】</strong></p>
<ul>
<li><a href="https://cyanoii.github.io/2022/02/11/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/">归并排序 | 渔塘</a></li>
</ul>
<p><strong>【模板】</strong></p>
<p>归并排序：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[<span class="number">100010</span>];</span><br><span class="line"><span class="type">int</span> temp[<span class="number">100010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">psort</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> i=l,j=mid+<span class="number">1</span>,k=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(i&lt;=mid||j&lt;=r)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(i&lt;=mid&amp;&amp;j&lt;=r)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(a[i]&lt;=a[j]) temp[++k]=a[i++];</span><br><span class="line">			<span class="keyword">else</span> temp[++k]=a[j++];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(i&lt;=mid) temp[++k]=a[i++];</span><br><span class="line">			<span class="keyword">else</span> temp[++k]=a[j++];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	k=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=l;i&lt;=r;i++) a[i]=temp[++k];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">msort</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(r-l&gt;<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">msort</span>(l,mid);</span><br><span class="line">		<span class="built_in">msort</span>(mid+<span class="number">1</span>,r);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">psort</span>(l,r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">msort</span>(<span class="number">1</span>,n);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,a[i]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h2><p><strong>【简介】</strong></p>
<p>二分查找可以在长度为 $n$ 的<strong>有序数组</strong>中使用 $O(\log n)$ 的效率查找某一元素。其衍生算法有三分法与二分答案。在使用二分法时，要注意自锁问题与边界问题。</p>
<p><strong>【相关链接】</strong></p>
<ul>
<li><a href="https://cyanoii.github.io/2024/04/08/%E4%BA%8C%E5%88%86%E7%9A%84%E8%87%AA%E9%94%81%E9%97%AE%E9%A2%98%E7%AD%89%E7%BB%86%E8%8A%82%E9%97%AE%E9%A2%98/">二分的自锁问题等细节问题 | 渔塘</a></li>
</ul>
<p><strong>【模板】</strong></p>
<p>答案记录法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> ans;</span><br><span class="line"><span class="type">int</span> l=<span class="number">1</span>,r=n;</span><br><span class="line"><span class="keyword">while</span>(l&lt;=r)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">check</span>(mid))</span><br><span class="line">    &#123;</span><br><span class="line">        ans=mid;</span><br><span class="line">        r=mid<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans);</span><br></pre></td></tr></table></figure>

<p>边界重合法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> l=<span class="number">1</span>,r=n;</span><br><span class="line"><span class="keyword">while</span>(l&lt;r)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">check</span>(mid)) r=mid;</span><br><span class="line">    <span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,l);</span><br></pre></td></tr></table></figure>

<h1 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h1><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h1 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h1><h2 id="求和公式"><a href="#求和公式" class="headerlink" title="求和公式"></a>求和公式</h2><p><strong>【简介】</strong></p>
<ul>
<li>$1 + 2 + \dots + i &#x3D; {i \times (i + 1) \over 2}$</li>
<li>$1 + (1 + 2) + \dots + (1 + 2 + \dots + i) &#x3D; {i \times (i + 1) \times (i + 2) \over 6}$</li>
</ul>
<p><strong>【相关链接】</strong></p>
<ul>
<li><a href="https://cyanoii.github.io/2024/03/29/%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%89%8D%E7%BC%80%E5%92%8C%E7%9A%84%E5%92%8C%E5%85%AC%E5%BC%8F/">前缀和与前缀和的和公式 | 渔塘</a></li>
</ul>
<p><strong>【模板】</strong></p>
<p>暂无。</p>
<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h1 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h1><h1 id="计算几何"><a href="#计算几何" class="headerlink" title="计算几何"></a>计算几何</h1><h1 id="解题专题"><a href="#解题专题" class="headerlink" title="解题专题"></a>解题专题</h1><h2 id="串寻找子串数量"><a href="#串寻找子串数量" class="headerlink" title="串寻找子串数量"></a>串寻找子串数量</h2><ul>
<li>利用前缀和降一维。</li>
<li>特殊变化性质引起的特殊记录方式。</li>
<li>左边界加右边二分确定范围。</li>
</ul>
<h2 id="决定执行顺序的贪心"><a href="#决定执行顺序的贪心" class="headerlink" title="决定执行顺序的贪心"></a>决定执行顺序的贪心</h2><ul>
<li>国王问题</li>
<li>梅深不见冬</li>
<li>皇后问题</li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>OI 知识</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2022/05/11/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>【题解】2023HBCPC C. 路径计数</title>
    <url>/2023/06/07/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%912023HBCPC-C-%E8%B7%AF%E5%BE%84%E8%AE%A1%E6%95%B0/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><strong>Problem C. 路径计数</strong></p>
<p>有一个 $n$ 个点 $n - 1$ 条无向边的树，每条边的长度可能并不相同。</p>
<p>我们定义 $dis(u, v)$ 为从点 $u$ 到点 $v$ 所有边的长度之和。</p>
<p>你需要求出满足 $dis(u, v)$ 为奇数的无序点对 $(u, v)$ 的数量。</p>
<p><strong>Input</strong></p>
<p>第一行为一个整数 $n(2 \leq n \leq 10^5)$ 。表示树的点数。</p>
<p>之后 $n - 1$ 行每行包括三个整数 $u_i, v_i, w_i(1 \leq u_i, v_i \leq n, u_i \neq v_i, 1 \leq w_i \leq 10^9)$ ，表示一条连接点 $u_i$ 和点 $v_i$ 长度为 $w_i$ 的边。</p>
<p><strong>Output</strong></p>
<p>一个整数，表示答案。</p>
<p><strong>Examples</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">1 2 1</span><br><span class="line">1 3 1</span><br><span class="line">2 4 1</span><br><span class="line">2 5 2</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10</span><br><span class="line">5 7 1</span><br><span class="line">10 3 1</span><br><span class="line">4 2 5</span><br><span class="line">5 1 7</span><br><span class="line">4 9 10</span><br><span class="line">1 4 5</span><br><span class="line">8 7 6</span><br><span class="line">5 10 5</span><br><span class="line">6 9 4</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">25</span><br></pre></td></tr></table></figure>

<p><strong>Note</strong></p>
<p>第一个样例中， $6$ 条无序点对为 $(1, 2), (1, 3), (1, 5), (2, 4), (3, 4), (4, 5)$ 。</p>
<h1 id="我的题解"><a href="#我的题解" class="headerlink" title="我的题解"></a>我的题解</h1><p>当时在考场上看到这道题目的时候有一种莫名的熟悉感，也因此即使在赛场上用了近乎 2 个多小时解决它，我仍觉得我其中有些地方的思路过于清晰与熟悉，似乎之前在 CF 或者洛谷上做过它的原题。不过后来寻找后并没有找到，而是找到了两个类似的题目，我估计就是这两道题目给我的启发：</p>
<p><a href="https://codeforces.com/contest/1654/problem/D">Problem - D - Codeforces</a></p>
<p><a href="https://codeforces.com/gym/104128/problem/J">Problem - J - Codeforces</a></p>
<p>同时我还觉得其中有关拼接数优化的部分我想出的有些过于快了，我认为是我曾经搜到过类似的优化，但是没有记录。下面回到题目本身。</p>
<h2 id="奇偶性问题"><a href="#奇偶性问题" class="headerlink" title="奇偶性问题"></a>奇偶性问题</h2><p>首先考虑奇偶数的性质：由于数的奇偶性变化不由数本身的大小决定，因此可以将题目中所有偶数边长度记为 $0$ ，所有奇数边记为 $1$ 。同时由于奇+奇&#x3D;偶，偶+偶&#x3D;偶，奇+偶&#x3D;奇，我们可以认为<strong>一条奇数长度的路径要么本身长度为奇，要么由一条奇数路径拼接另一偶数路径得到</strong>。</p>
<p>在树上进行遍历，计算<strong>以每个点为路径的一个顶点的，其子树下存在的奇数偶数路径的数量</strong>。具体的计算方法看程序即可，转换关键在于当前点到每个儿子节点的路径的长度是奇是偶的问题。如果是偶的，则奇数边数不变，偶数边数额外加一（只有这条边的路径）；如果是奇的，则首先奇偶互换，其次奇数边额外加一（只有这条边的路径）。</p>
<h2 id="拼接数问题"><a href="#拼接数问题" class="headerlink" title="拼接数问题"></a>拼接数问题</h2><p>在求得了上述值后，其中本身长度为奇的奇数路径可以直接加到答案中，而另一种由奇偶路径拼接而来的奇数路径则需要单独求解。假设某点下有三个儿子节点，其带给本点的奇偶数贡献分别为 $(o_1, e_1), (o_2, e_2), (o_3, e_3)$ ，那么按照上面所述，首先将本身长度为奇的路径加入答案：</p>
<p>$$<br>ans_1 &#x3D; \sum_{i &#x3D; 1}^3 o_i<br>$$</p>
<p>之后，我们要对路径进行拼接，得到第二部分答案：</p>
<p>$$<br>ans_2 &#x3D; o_1 e_2 + o_1 e_3 + o_2 e_1 + o_2 e_3 + o_3 e_1 + o_3 e_2<br>$$</p>
<p>计算效率为 $O(n^2)$ 。我认为这个效率很低，于是乎想到了一种优化方法。将原式改写为如下形式：</p>
<p>$$<br>\begin{align}<br>ans_2 &amp; &#x3D; o_1 e_2 + o_1 e_3 + o_2 e_1 + o_2 e_3 + o_3 e_1 + o_3 e_2 \\<br>  &amp; &#x3D; o_1 e_2 + o_1 e_3 + o_2 e_3 +  e_1 o_2 + e_1 o_3  + e_2 o_3 \\<br> &amp; &#x3D; (o_1 e_2 + (o_1 + o_2) e_3) + (e_1 o_2 + (e_1 + e_2) o_3)<br>\end{align}<br>$$</p>
<p>原式被拆分为两个类似的部分，第一部分中，对于每项乘积，前者为按编号增加的奇数贡献的累加，后者为按编号增加的偶数贡献。第二部分是同理的。此种计算方法的效率为 $O(n)$ ，且与树的遍历过程十分匹配。这种计算方法我总感觉在其它处学习过或者写过，也觉得有些像秦九韶算法，但终究没有搜索到。不过也可能是赛场上我的思考方式导致了我直接看出了这种优化方法。（当时想的是第一个奇数贡献应该跟后续其它的偶数贡献结合，之后第二个奇数贡献再跟它的后续其它偶数贡献结合，偶数贡献同理，于是直接写出了第一步改写后的式子，想想也是有些幸运）</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>由于代码缺乏评测，所以我只能保证下面的代码能够复现我考场上的思路，不能保证其正确性。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">ll ans=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> book[<span class="number">100010</span>],eve[<span class="number">100010</span>],odd[<span class="number">100010</span>];</span><br><span class="line"><span class="type">int</span> a[<span class="number">100010</span>],tot=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">bian</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> to;</span><br><span class="line">	<span class="type">int</span> next;</span><br><span class="line">	<span class="type">int</span> w;</span><br><span class="line">&#125;e[<span class="number">200020</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> from,<span class="type">int</span> to,<span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	tot++;</span><br><span class="line">	e[tot].next=a[from];</span><br><span class="line">	a[from]=tot;</span><br><span class="line">	e[tot].to=to;</span><br><span class="line">	e[tot].w=w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	book[x]=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> sumeve=<span class="number">0</span>,sumodd=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=a[x];i;i=e[i].next)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> tto=e[i].to;</span><br><span class="line">		<span class="type">int</span> ww=e[i].w;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(book[tto]) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="built_in">dfs</span>(tto);</span><br><span class="line"></span><br><span class="line">		<span class="type">int</span> noweve,nowodd;</span><br><span class="line">		<span class="keyword">if</span>(ww==<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			noweve=eve[tto]+<span class="number">1</span>;</span><br><span class="line">			nowodd=odd[tto];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			noweve=odd[tto];</span><br><span class="line">			nowodd=eve[tto]+<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		eve[x]+=noweve;</span><br><span class="line">		odd[x]+=nowodd;</span><br><span class="line"></span><br><span class="line">		ans+=nowodd;</span><br><span class="line">		ans+=sumeve*nowodd;</span><br><span class="line">		ans+=sumodd*noweve;</span><br><span class="line">		sumeve+=noweve;</span><br><span class="line">		sumodd+=nowodd;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> x,y,z;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line">		z%=<span class="number">2</span>;</span><br><span class="line">		<span class="built_in">add</span>(x,y,z);</span><br><span class="line">		<span class="built_in">add</span>(y,x,z);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>OI 比赛</tag>
        <tag>OI 知识</tag>
        <tag>OI 题解</tag>
      </tags>
  </entry>
  <entry>
    <title>【题解】Codeforces 1931F Chat Screenshots</title>
    <url>/2024/04/08/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91Codeforces-1931F-Chat-Screenshots/</url>
    <content><![CDATA[<p><strong>比赛传送门：<a href="https://www.acgo.cn/contest/1838/detail">“码王杯”黑龙江工程学院第十届程序设计竞赛</a></strong></p>
<p><strong>题目传送门：<a href="https://www.acgo.cn/problemset/18842/info">ACGO A18842.序列X</a></strong></p>
<p><strong>题目传送门：<a href="https://codeforces.com/contest/1931/problem/F">Codeforces 1931F Chat Screenshots</a></strong></p>
<p>题目是之前参加“码王杯”黑龙江工程学院第十届程序设计竞赛的时候见到的，当时参赛就觉得很多题应该是 CF 原题，结束一看还真是。这个题在比赛时一直在尝试能否仅使用前两组就推断出原始序列，之后再对后续序列做判断，但最终不可行。</p>
<p>正解是图上判环。将每个数都看作图上的一个点，对于每组数据，除去第一个数后将后续数间都由前向后连接一条有向边，最后判断图上有没有出现环。若出现了环则说明至少存在某两个数在不同序列中前后顺序不定，输出 “NO”，反之输出 “YES”。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> t;</span><br><span class="line"><span class="type">int</span> n,k;</span><br><span class="line"><span class="type">int</span> a[<span class="number">200010</span>],tot;</span><br><span class="line"><span class="type">int</span> ru[<span class="number">200010</span>],num;</span><br><span class="line"><span class="type">int</span> c[<span class="number">200010</span>];</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">bian</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> to,next;</span><br><span class="line">&#125;e[<span class="number">400010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> from,<span class="type">int</span> to)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	tot++;</span><br><span class="line">	e[tot].next=a[from];</span><br><span class="line">	a[from]=tot;</span><br><span class="line">	e[tot].to=to;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">toposort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	num=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) q.<span class="built_in">pop</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(!ru[i])</span><br><span class="line">		&#123;</span><br><span class="line">			q.<span class="built_in">push</span>(i);</span><br><span class="line">			num++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> now=q.<span class="built_in">front</span>();</span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=a[now];i;i=e[i].next)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> tto=e[i].to;</span><br><span class="line">			ru[tto]--;</span><br><span class="line">			<span class="keyword">if</span>(!ru[tto])</span><br><span class="line">			&#123;</span><br><span class="line">				q.<span class="built_in">push</span>(tto);</span><br><span class="line">				num++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solv</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;k);</span><br><span class="line"></span><br><span class="line">	tot=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		a[i]=<span class="number">0</span>;</span><br><span class="line">		ru[i]=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> v=<span class="number">1</span>;v&lt;=k;v++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;c[i]);</span><br><span class="line"></span><br><span class="line">		<span class="type">int</span> now,las=c[<span class="number">2</span>];</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">3</span>;i&lt;=n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			now=c[i];</span><br><span class="line">			<span class="built_in">add</span>(las,now);</span><br><span class="line">			ru[now]++;</span><br><span class="line">			las=now;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">toposort</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(num==n) <span class="built_in">printf</span>(<span class="string">&quot;YES\n&quot;</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;NO\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;t);</span><br><span class="line">	<span class="keyword">while</span>(t--) <span class="built_in">solv</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>OI 比赛</tag>
        <tag>OI 题解</tag>
      </tags>
  </entry>
  <entry>
    <title>【题解】Codeforces Round 778 (Div. 1 + Div. 2, based on Technocup 2022 Final Round) D</title>
    <url>/2022/03/28/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91Codeforces-Round-778-Div-1-Div-2-based-on-Technocup-2022-Final-Round-D/</url>
    <content><![CDATA[<p><strong>比赛传送门：<a href="https://codeforces.com/contest/1654">Codeforces Round 778 (Div. 1 + Div. 2, based on Technocup 2022 Final Round)</a></strong></p>
<h1 id="D-Potion-Brewing-Class"><a href="#D-Potion-Brewing-Class" class="headerlink" title="D. Potion Brewing Class"></a>D. Potion Brewing Class</h1><p>由于有$n-1$组关系，于是可以将结构看成一颗树。</p>
<p>由于知道了各组间的比例，现在假设节点$1$的最后大小为$1$，则其他所有点的大小都能被分数的形式确定出来，例如若$a_1 : a_2 &#x3D; 4 : 3$，则有$a_1 &#x3D; 1, a_2 &#x3D; {3 \over 4}$。现设所有分数为$c_i \over b_i$，则现在只需求得$l &#x3D; lcm(b_1, b_2, …, b_n)$，后求$\sum (l \cdot {c_i \over b_i}) \mod k$即可。于是乎想到可以在dfs树的过程中求出$c_i \over b_i$，后利用公式计算即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> t;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">ll mod=<span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[<span class="number">200010</span>],tot=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> vis[<span class="number">200010</span>];</span><br><span class="line">ll up[<span class="number">200010</span>],down[<span class="number">200010</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">bian</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> to;</span><br><span class="line">	<span class="type">int</span> next;</span><br><span class="line">	ll x,y;</span><br><span class="line">&#125;e[<span class="number">500010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> from,<span class="type">int</span> to,ll x,ll y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	tot++;</span><br><span class="line">	e[tot].next=a[from];</span><br><span class="line">	a[from]=tot;</span><br><span class="line">	e[tot].to=to;</span><br><span class="line">	e[tot].x=x;</span><br><span class="line">	e[tot].y=y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(b==<span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">gcd</span>(b,a%b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">lcm</span><span class="params">(ll a,ll b)</span> </span>&#123;<span class="keyword">return</span> a/<span class="built_in">gcd</span>(a,b)*b;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> now,ll x,ll y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ll g=<span class="built_in">gcd</span>(x,y);</span><br><span class="line"></span><br><span class="line">	x/=g;</span><br><span class="line">	y/=g;</span><br><span class="line"></span><br><span class="line">	up[now]=y;</span><br><span class="line">	down[now]=x;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> v=a[now];v;v=e[v].next)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> tto=e[v].to;</span><br><span class="line">		ll xx=e[v].x,yy=e[v].y;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(vis[tto]) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		vis[tto]=<span class="number">1</span>;</span><br><span class="line">		<span class="built_in">dfs</span>(tto,xx*down[now],yy*up[now]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solv</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x,y;</span><br><span class="line">	ll z,zz;</span><br><span class="line">	ll l=<span class="number">1</span>;</span><br><span class="line">	ll ans=<span class="number">0</span>;</span><br><span class="line">	ll anslin=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	tot=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		a[i]=<span class="number">0</span>;</span><br><span class="line">		vis[i]=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	up[<span class="number">1</span>]=<span class="number">1</span>,down[<span class="number">1</span>]=<span class="number">1</span>,vis[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%lld%lld&quot;</span>,&amp;x,&amp;y,&amp;z,&amp;zz);</span><br><span class="line">		<span class="built_in">add</span>(x,y,z,zz);</span><br><span class="line">		<span class="built_in">add</span>(y,x,zz,z);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//for(int i=1;i&lt;=n;i++) &#123;printf(&quot;%d : %lld/%lld\n&quot;,i,up[i],down[i]);&#125;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;l=<span class="built_in">lcm</span>(l,down[i]);&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		ans+=l/down[i]*up[i];</span><br><span class="line">		ans%=mod;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//printf(&quot;%lld\n&quot;,l);</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;t);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=t;i++) <span class="built_in">solv</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但此时出现了问题：$b_i$的值往往会过大从而无法利用辗转相除法计算$lcm$。即使能够计算，$lcm$本身的值也往往因过大而无法储存。于是乎想到另一个思路：</p>
<p>设两个数$i &#x3D; p_1^{a_1} * p_2^{a_2} * p_3^{a_3} * … * p_s^{a_s}$，$j &#x3D; p_1^{b_1} * p_2^{b_2} * p_3^{b_3} * … * p_s^{b_s}$，则由算术基本定理（又叫整数惟一分解定理）得到：</p>
<p>$lcm(i,j) &#x3D; p_1^{\max(a_1, b_1)} * p_2^{\max(a_2, b_2)} * p_3^{\max(a_3,b_3)} * … * p_s^{\max(a_s, b_s)}$</p>
<p>更多的数同理。于是乎可以利用dfs的过程计算每个质因数的最大值从而得到$l$的质因数分解形式（提前预处理出质因数分解）。后利用另一个dfs在向下的过程中计算每个点的值。</p>
<p>但此时还有一个无法避免的问题：在到达每个点时，要同时进行乘和除的运算，而除运算与模运算间存在冲突。若想要每次都先计算出$lcm$再进行乘除则会不可避免的出现越界问题。于是想到可以将要乘与除的数一起并入质因数分解，但结果就是超时。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> t;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">ll mod=<span class="number">998244353</span>;</span><br><span class="line">ll ans;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[<span class="number">200010</span>],tot=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> vis[<span class="number">200010</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> p[<span class="number">200010</span>],vv[<span class="number">200010</span>];</span><br><span class="line"><span class="type">int</span> f[<span class="number">200010</span>],g[<span class="number">200010</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> len;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">bian</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> to;</span><br><span class="line">	<span class="type">int</span> next;</span><br><span class="line">	ll x,y;</span><br><span class="line">&#125;e[<span class="number">500010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(b==<span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">gcd</span>(b,a%b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> from,<span class="type">int</span> to,ll x,ll y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	tot++;</span><br><span class="line">	e[tot].next=a[from];</span><br><span class="line">	a[from]=tot;</span><br><span class="line">	e[tot].to=to;</span><br><span class="line">	e[tot].x=x;</span><br><span class="line">	e[tot].y=y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> now)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> v=a[now];v;v=e[v].next)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> tto=e[v].to;</span><br><span class="line">		ll xx=e[v].x,yy=e[v].y;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(vis[tto]) <span class="keyword">continue</span>;</span><br><span class="line">		vis[tto]=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span>(yy&gt;<span class="number">1</span>)				<span class="comment">//Order is important!!!</span></span><br><span class="line">		&#123;</span><br><span class="line">			f[vv[yy]]++;</span><br><span class="line">			yy/=vv[yy];</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span>(xx&gt;<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			f[vv[xx]]--;</span><br><span class="line">			g[vv[xx]]=<span class="built_in">min</span>(g[vv[xx]],f[vv[xx]]);</span><br><span class="line"></span><br><span class="line">			xx/=vv[xx];</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">dfs1</span>(tto);</span><br><span class="line"></span><br><span class="line">		xx=e[v].x,yy=e[v].y;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span>(xx&gt;<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			f[vv[xx]]++;</span><br><span class="line">			xx/=vv[xx];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span>(yy&gt;<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			f[vv[yy]]--;</span><br><span class="line">			yy/=vv[yy];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> now,<span class="type">int</span> down,<span class="type">int</span> up)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> lin=up;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(lin&gt;<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		g[vv[lin]]--;</span><br><span class="line">		lin/=vv[lin];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	lin=down;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(lin&gt;<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		g[vv[lin]]++;</span><br><span class="line">		lin/=vv[lin];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ll temp=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=-g[i];j++)</span><br><span class="line">		&#123;</span><br><span class="line">			temp*=i;</span><br><span class="line">			temp%=mod;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ans+=temp;</span><br><span class="line">	ans%=mod;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> v=a[now];v;v=e[v].next)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> tto=e[v].to;</span><br><span class="line">		ll xx=e[v].x,yy=e[v].y;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(vis[tto]) <span class="keyword">continue</span>;</span><br><span class="line">		vis[tto]=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">dfs2</span>(tto,xx,yy);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	lin=up;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(lin&gt;<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		g[vv[lin]]++;</span><br><span class="line">		lin/=vv[lin];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	lin=down;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(lin&gt;<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		g[vv[lin]]--;</span><br><span class="line">		lin/=vv[lin];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solv</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x,y;</span><br><span class="line">	ll z,zz;</span><br><span class="line"></span><br><span class="line">	ans=<span class="number">0</span>;</span><br><span class="line">	tot=<span class="number">0</span>;</span><br><span class="line">	len=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		a[i]=<span class="number">0</span>;</span><br><span class="line">		vis[i]=<span class="number">0</span>;</span><br><span class="line">		f[i]=<span class="number">0</span>;</span><br><span class="line">		g[i]=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	vis[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%lld%lld&quot;</span>,&amp;x,&amp;y,&amp;z,&amp;zz);</span><br><span class="line">		<span class="built_in">add</span>(x,y,z,zz);</span><br><span class="line">		<span class="built_in">add</span>(y,x,zz,z);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">dfs1</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) vis[i]=<span class="number">0</span>;</span><br><span class="line">	vis[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">dfs2</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//printf(&quot;%lld\n&quot;,l);</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;t);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=<span class="number">200000</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		p[i]=<span class="number">1</span>;</span><br><span class="line">		vv[i]=i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=<span class="built_in">sqrt</span>(<span class="number">200000</span>)+<span class="number">0.5</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(p[i])</span><br><span class="line">		&#123;</span><br><span class="line">			vv[i]=i;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=i*<span class="number">2</span>;j&lt;=<span class="number">200000</span>;j+=i)</span><br><span class="line">			&#123;</span><br><span class="line">				p[j]=<span class="number">0</span>;</span><br><span class="line">				vv[j]=i;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=t;i++) <span class="built_in">solv</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>开始我理解错了超时原因，以为是原题解使用vector实现了更高效的并入分解，但理解错了。后看前几名dalao的程序明白了，可以推导费马小定理实现除法取模。于是题目终于被解决了：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> t;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">ll mod=<span class="number">998244353</span>;</span><br><span class="line">ll ans;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[<span class="number">200010</span>],tot=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> vis[<span class="number">200010</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> p[<span class="number">200010</span>],vv[<span class="number">200010</span>];</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; factors;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; f,g;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> len;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">bian</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> to;</span><br><span class="line">	<span class="type">int</span> next;</span><br><span class="line">	ll x,y;</span><br><span class="line">&#125;e[<span class="number">500010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">fpow</span><span class="params">(ll a,ll b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ll ans=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(b&gt;<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(b&amp;<span class="number">1</span>==<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			ans*=a;</span><br><span class="line">			ans%=mod;</span><br><span class="line">		&#125;</span><br><span class="line">		a*=a;</span><br><span class="line">		a%=mod;</span><br><span class="line">		b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> from,<span class="type">int</span> to,ll x,ll y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	tot++;</span><br><span class="line">	e[tot].next=a[from];</span><br><span class="line">	a[from]=tot;</span><br><span class="line">	e[tot].to=to;</span><br><span class="line">	e[tot].x=x;</span><br><span class="line">	e[tot].y=y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> now)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> v=a[now];v;v=e[v].next)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> tto=e[v].to;</span><br><span class="line">		ll xx=e[v].x,yy=e[v].y;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(vis[tto]) <span class="keyword">continue</span>;</span><br><span class="line">		vis[tto]=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> p:factors[yy]) f[p]++;			<span class="comment">//Order is important!!!</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> p:factors[xx])</span><br><span class="line">		&#123;</span><br><span class="line">			f[p]--;</span><br><span class="line">			g[p]=<span class="built_in">min</span>(g[p],f[p]);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">dfs1</span>(tto);</span><br><span class="line"></span><br><span class="line">		xx=e[v].x,yy=e[v].y;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> p:factors[yy]) f[p]--;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> p:factors[xx]) f[p]++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> now,ll temp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ans+=temp;</span><br><span class="line">	ans%=mod;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> v=a[now];v;v=e[v].next)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> tto=e[v].to;</span><br><span class="line">		ll xx=e[v].x,yy=e[v].y;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(vis[tto]) <span class="keyword">continue</span>;</span><br><span class="line">		vis[tto]=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">dfs2</span>(tto,((temp*yy)%mod*<span class="built_in">fpow</span>(xx,mod<span class="number">-2</span>))%mod);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solv</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x,y;</span><br><span class="line">	ll z,zz;</span><br><span class="line"></span><br><span class="line">	ans=<span class="number">0</span>;</span><br><span class="line">	tot=<span class="number">0</span>;</span><br><span class="line">	len=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		a[i]=<span class="number">0</span>;</span><br><span class="line">		vis[i]=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	vis[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%lld%lld&quot;</span>,&amp;x,&amp;y,&amp;z,&amp;zz);</span><br><span class="line">		<span class="built_in">add</span>(x,y,z,zz);</span><br><span class="line">		<span class="built_in">add</span>(y,x,zz,z);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	f.<span class="built_in">assign</span>(n+<span class="number">10</span>,<span class="number">0</span>);</span><br><span class="line">    g.<span class="built_in">assign</span>(n+<span class="number">10</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">dfs1</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) vis[i]=<span class="number">0</span>;</span><br><span class="line">	vis[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	ll l=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span>(g[i]&lt;<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			l*=i;</span><br><span class="line">			l%=mod;</span><br><span class="line">			g[i]++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">dfs2</span>(<span class="number">1</span>,l);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//printf(&quot;%lld\n&quot;,l);</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;t);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=<span class="number">200000</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		p[i]=<span class="number">1</span>;</span><br><span class="line">		vv[i]=i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=<span class="built_in">sqrt</span>(<span class="number">200000</span>)+<span class="number">0.5</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(!p[i]) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=i*<span class="number">2</span>;j&lt;=<span class="number">200000</span>;j+=i)</span><br><span class="line">		&#123;</span><br><span class="line">			p[j]=<span class="number">0</span>;</span><br><span class="line">			vv[j]=i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	factors.<span class="built_in">resize</span>(<span class="number">200010</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=<span class="number">200000</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> temp=i;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span>(temp&gt;<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			factors[i].<span class="built_in">push_back</span>(vv[temp]);</span><br><span class="line">			temp/=vv[temp];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=t;i++) <span class="built_in">solv</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以说在本题中学到很多东西了。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>OI 比赛</tag>
        <tag>OI 题解</tag>
      </tags>
  </entry>
  <entry>
    <title>【题解】Codeforces Round 783 (Div. 2) C（存疑）</title>
    <url>/2022/04/20/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91Codeforces-Round-783-Div-2-C/</url>
    <content><![CDATA[<p><strong>比赛传送门：<a href="https://codeforces.com/contest/1668">Codeforces Round 783 (Div. 2)</a></strong></p>
<h1 id="C-Make-it-Increasing"><a href="#C-Make-it-Increasing" class="headerlink" title="C. Make it Increasing"></a>C. Make it Increasing</h1><p>题目本身比较简单。要想得到递增序列，只需要从$1$到$n$遍历选择不进行增减的点（$0$），后根据递增原则分左右两部分进行搜索计算即可。注意要开long long。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll unsigned long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">ll a[<span class="number">5200</span>],b[<span class="number">5200</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;a[i]);</span><br><span class="line">		b[i]=a[i];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ll ans=<span class="number">1e18</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> v=<span class="number">1</span>;v&lt;=n;v++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) a[i]=b[i];</span><br><span class="line"></span><br><span class="line">		ll num=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=v<span class="number">-1</span>;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">		&#123;</span><br><span class="line">			ll bol=a[i+<span class="number">1</span>];</span><br><span class="line">			<span class="keyword">if</span>(i+<span class="number">1</span>==v) bol=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span>(a[i]&lt;=bol)</span><br><span class="line">			&#123;</span><br><span class="line">				num+=(bol/a[i]+<span class="number">1</span>);</span><br><span class="line">				a[i]*=(bol/a[i]+<span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> num++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=v+<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			ll bol=a[i<span class="number">-1</span>];</span><br><span class="line">			<span class="keyword">if</span>(i<span class="number">-1</span>==v) bol=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span>(a[i]&lt;=bol)</span><br><span class="line">			&#123;</span><br><span class="line">				num+=(bol/a[i]+<span class="number">1</span>);</span><br><span class="line">				a[i]*=(bol/a[i]+<span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> num++;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		ans=<span class="built_in">min</span>(ans,num);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是题解的写法比较巧妙。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> n, a[<span class="number">5005</span>], ans=<span class="number">1e18</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> pos=<span class="number">1</span>; pos&lt;=n; pos++) &#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> prev=<span class="number">0</span>, sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=pos<span class="number">-1</span>; i&gt;=<span class="number">1</span>; i--) &#123;</span><br><span class="line">            prev+=a[i]-prev%a[i];	<span class="comment">//对于模a[i]有余数的情况可以让prev加到刚好被整除的大小，即满足递增条件的最小值</span></span><br><span class="line">            sum+=prev/a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        prev=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=pos+<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">            prev+=a[i]-prev%a[i];</span><br><span class="line">            sum+=prev/a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        ans=<span class="built_in">min</span>(ans, sum);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>题解注意到了一点：若$b_i - a_i &gt; b_{i - 1}$，则可以认为至少多进行了一次没有必要的操作（即多加了一次$a_i$）。因此我们可以认为对于最优答案存在$b_i \leq b_{i - 1} + a_i$。那么我们假设$prev_i &#x3D; b_{i - 1} + a_i$，则对于第$i$个数应该进行$prev_i &#x2F; a_i$次操作。</p>
<p>因为$prev_{i - 1} \geq b_{i - 1}$，所以$prev_i \geq prev_{i - 1} + a_i$。由于我们希望总操作次数小，因此$prev_i$该越小越好，所以我们希望取到等于的情况。因此$prev_i &#x3D; prev_{i - 1} + (a_i - prev_{i - 1} % a_i)$。当后面的数更大时，则直接加$a_i$，否则加到刚好被$a_i$整除的大小，即满足递增条件的最小值。</p>
<p>但我目前还对这种解法存疑。如0 6 7 3，选中0后面进行递增，似乎我的程序是5，题解的程序是7。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>OI 比赛</tag>
        <tag>OI 题解</tag>
      </tags>
  </entry>
  <entry>
    <title>【题解】Codeforces Round 791 (Div. 2) A-C</title>
    <url>/2022/05/15/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91Codeforces-Round-791-Div-2-A-C/</url>
    <content><![CDATA[<p><strong>比赛传送门：<a href="https://codeforces.com/contest/1679">Codeforces Round 791 (Div. 2)</a></strong></p>
<p>可能与正解有出入，只是展示了自己的写法。</p>
<h1 id="A-AvtoBus"><a href="#A-AvtoBus" class="headerlink" title="A. AvtoBus"></a>A. AvtoBus</h1><p>给定一个数 n ，使用 4 和 6 分割这个数，如果不能完美分割输出 -1 ，如果能则输出最小分割数和最大分割数。</p>
<p>有两种情况不能完美分割，即 n 不能被 2 整除和 n 小于 4 的时候，这两种情况都很好理解，输出 -1 即可。</p>
<p>4 和 6 都是 2 的倍数，因此不妨计算 n&#x2F;2 被 2 和 3 分割。分别计算最小分割数和最大分割数。</p>
<p><strong>最小分割数：</strong></p>
<p>由于是最小分割，因此要尽可能分出更多的 3 ，分完之后的余数可能为 0，1，2。余数为 0 ，刚好分割完，分割数不变；余数为 1 ，那么便从分割好的 3 中拿出一个凑成 4 ，再分割为 2 个 2，即分割数 + 1；余数为 2 ，直接多分割一个 2 ，分割数 + 1。若一个 3 都分割不出来，即 n &#x3D; 2 的情况，直接等于最大分割数。</p>
<p><strong>最大分割数：</strong></p>
<p>由于是最小分割，因此要尽可能分出更多的 2 ，分完之后的余数可能为 0，1。余数为 0 ，刚好分割完，分割数不变；余数为 1 ，那么便从分割好的 2 中拿出一个凑成 3 ，即分割 1 个 3 ，分割数不变。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> t;</span><br><span class="line">ll n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solv</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;n);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(n%<span class="number">2</span>||n&lt;<span class="number">4</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	n/=<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">	ll min=n/<span class="number">3</span>,max=n/<span class="number">2</span>;</span><br><span class="line">	ll temp=n-(n/<span class="number">3</span>*<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(temp) min++;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(min==<span class="number">0</span>) min=max;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld %lld\n&quot;</span>,min,max);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;t);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=t;i++) <span class="built_in">solv</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="B-Stone-Age-Problem"><a href="#B-Stone-Age-Problem" class="headerlink" title="B. Stone Age Problem"></a>B. Stone Age Problem</h1><ul>
<li>操作 1 ：指定第 i 个数变为 a。</li>
<li>操作 2 ：所有数变为 b。</li>
</ul>
<p>每次变化后都要输出当前数组的和的值。</p>
<p>每次操作 2 时，sum 值是能直接求解的，因此直接输出。同时定义一个基值base，即下一次修改到来前，每个位置的数的值都该是本值；定义一个操作次数 changenum 用来记录这是第几次操作 2 ，再开一个 change 数组代表这个数是经历了第几次操作 2 后的值，为了配合进行操作 1 。</p>
<p>每次操作 1 时，先利用 change 数组确定本数的值是否正确。设本数值为 x ，编号为 i ，若正确，则 sum 值增加 (a - x) ；若不正确，则说明本数的值应为当前的基值 base ，则 sum 值增加 (a - base) ，同时 change[i] &#x3D; changenum ，表示当前值已经经历过最新的 基值 base 的更新了。 最后记得更新本数的值 x。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> t;</span><br><span class="line"><span class="type">int</span> n,p;</span><br><span class="line"><span class="type">int</span> a[<span class="number">200010</span>],change[<span class="number">200010</span>];</span><br><span class="line"><span class="type">int</span> changenum=<span class="number">0</span>,nowbase;</span><br><span class="line">ll nowans=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x,y,z;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;p);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">		nowans+=a[i];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> v=<span class="number">1</span>;v&lt;=p;v++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">		<span class="keyword">if</span>(x==<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;y,&amp;z);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span>(change[y]==changenum)</span><br><span class="line">			&#123;</span><br><span class="line">				nowans+=(z-a[y]);</span><br><span class="line">				a[y]=z;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				nowans+=(z-nowbase);</span><br><span class="line">				a[y]=z;</span><br><span class="line">				change[y]=changenum;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(x==<span class="number">2</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;y);</span><br><span class="line">			changenum++;</span><br><span class="line">			nowans=(ll)y*n;</span><br><span class="line">			nowbase=y;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,nowans);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="C-Rooks-Defenders"><a href="#C-Rooks-Defenders" class="headerlink" title="C. Rooks Defenders"></a>C. Rooks Defenders</h1><p>若想让检测区域都被攻击，则检测区域每行上有至少一辆车或每列上至少有一辆车。</p>
<p>开两个数组 row 、 col 分别记录某行和某列上有几辆车。为了提高效率，开两个树状数组 bit1 、 bit2 分别记录某行和某列上有没有车。</p>
<ul>
<li><p>操作 1 ：在 (x, y) 处加一辆车。</p>
<p>row[x]++, col[y]++ ；若这次是本行或本列从无车到有车，在 bit1 或 bit2 上更新为 1 。</p>
</li>
<li><p>操作 2 ：在 (x, y) 处去一辆车。</p>
<p>row[x]–, col[y]– ；若这次是本行或本列从有车到无车，在 bit1 或 bit2 上更新为 0 。</p>
</li>
<li><p>操作 3 ：检测 (x1, y1) 到 (x2, y2) 区域是否全被攻击。</p>
<p>对  x1 到 x2 有无车的树状数组求和，对 y1 到 y2 有无车的树状数组求和，若任意一组和其长度相等，说明这些行或列都有车，输出 Yes ；反之输出 No 。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> t;</span><br><span class="line"><span class="type">int</span> n,p;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> bit1[<span class="number">200010</span>],bit2[<span class="number">200010</span>];</span><br><span class="line"><span class="type">int</span> row[<span class="number">200010</span>],col[<span class="number">200010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x&amp;(-x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add1</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(x&lt;=n)</span><br><span class="line">	&#123;</span><br><span class="line">		bit1[x]+=k;</span><br><span class="line">		x+=<span class="built_in">lowbit</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum1</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(x&gt;<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		ans+=bit1[x];</span><br><span class="line">		x-=<span class="built_in">lowbit</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add2</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(x&lt;=n)</span><br><span class="line">	&#123;</span><br><span class="line">		bit2[x]+=k;</span><br><span class="line">		x+=<span class="built_in">lowbit</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum2</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(x&gt;<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		ans+=bit2[x];</span><br><span class="line">		x-=<span class="built_in">lowbit</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x,a,b,c,d;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;p);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> v=<span class="number">1</span>;v&lt;=p;v++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(x==<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line"></span><br><span class="line">			row[a]++;</span><br><span class="line">			<span class="keyword">if</span>(row[a]==<span class="number">1</span>) <span class="built_in">add1</span>(a,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">			col[b]++;</span><br><span class="line">			<span class="keyword">if</span>(col[b]==<span class="number">1</span>) <span class="built_in">add2</span>(b,<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(x==<span class="number">2</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line"></span><br><span class="line">			row[a]--;</span><br><span class="line">			<span class="keyword">if</span>(!row[a]) <span class="built_in">add1</span>(a,<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">			col[b]--;</span><br><span class="line">			<span class="keyword">if</span>(!col[b]) <span class="built_in">add2</span>(b,<span class="number">-1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(x==<span class="number">3</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;c,&amp;d);</span><br><span class="line"></span><br><span class="line">			<span class="type">int</span> rownum=c-a+<span class="number">1</span>,colnum=d-b+<span class="number">1</span>;</span><br><span class="line">			<span class="type">int</span> nowrownum=<span class="built_in">sum1</span>(c)-<span class="built_in">sum1</span>(a<span class="number">-1</span>);</span><br><span class="line">			<span class="type">int</span> nowcolnum=<span class="built_in">sum2</span>(d)-<span class="built_in">sum2</span>(b<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">			<span class="comment">//printf(&quot;%d %d %d %d\n&quot;,rownum,colnum,nowrownum,nowcolnum);</span></span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span>(rownum==nowrownum||colnum==nowcolnum) <span class="built_in">printf</span>(<span class="string">&quot;Yes\n&quot;</span>);</span><br><span class="line">			<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="PS"><a href="#PS" class="headerlink" title="PS"></a>PS</h1><p>上一场比赛因为有不会的题，所以题解慢慢再补……</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>OI 比赛</tag>
        <tag>OI 题解</tag>
      </tags>
  </entry>
  <entry>
    <title>【题解】Codeforces Round 793 (Div. 2) A-C</title>
    <url>/2022/05/23/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91Codeforces-Round-793-Div-2-A-C/</url>
    <content><![CDATA[<p><strong>比赛传送门：<a href="https://codeforces.com/contest/1682">Codeforces Round 793 (Div. 2)</a></strong></p>
<p>只写出一道题，好菜，打完不禁引起了我对人生的大思考…</p>
<h1 id="A-Palindromic-Indices"><a href="#A-Palindromic-Indices" class="headerlink" title="A. Palindromic Indices"></a>A. Palindromic Indices</h1><p>求在一个回文字符串里存在一些位置，在你移除这些位置的字母后字符串还是回文字符串，求这样的位置的个数。显然只有回文字符串最中间位置的同种字母是可以移除的，统计即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> t;</span><br><span class="line"><span class="type">int</span> len;</span><br><span class="line"><span class="type">char</span> s[<span class="number">100010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solv</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;len);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="type">char</span> now=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">	<span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=(len+<span class="number">1</span>)/<span class="number">2</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> j=len-i+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(i==j)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(s[i]==now)</span><br><span class="line">			&#123;</span><br><span class="line">				ans++;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				ans=<span class="number">1</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(s[i]!=now)</span><br><span class="line">		&#123;</span><br><span class="line">			now=s[i];</span><br><span class="line">			ans=<span class="number">2</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> ans+=<span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;t);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=t;i++) <span class="built_in">solv</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="B-AND-Sorting"><a href="#B-AND-Sorting" class="headerlink" title="B. AND Sorting"></a>B. AND Sorting</h1><p>死亡题目，因为理解错了题意而浪费了近2个小时：（</p>
<p>我理解的题意：每次交换时都会得到一个 X ，找到合理的交换方案让本方案里最大的 X 是所有方案中最大的 X 。</p>
<p>实际的题意：有一个 X ，所有的交换都只能等于 X 。找到最大的 X 。</p>
<p>于是乎误入歧途，一去不复返…模拟贪心都试了。下面说正解。</p>
<p>首先一点，只有$p_i \neq i - 1$的数都要至少经历一次交换。</p>
<p>假设 X 已知， X 所在的位置为 pos 。由于 $p_i \land p_j \leq \max (p_i, p_j)$，因此 X 一定在所给的数之中。 因为$p_i \land p_j &#x3D; X$ ，所以$p_i \land X &#x3D; X, p_j \land X &#x3D; X$，于是乎可以找到一种不影响任何其他元素的两元素交换方法：</p>
<ol>
<li>交换 pos 与 i 位置的数</li>
<li>交换 i 与 j 位置的数</li>
<li>交换 j 与 pos 位置的数</li>
</ol>
<p>之后由于每个位置不对的数都要进行至少一次交换，可以得出 X 为所有要交换数的共同掩码。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> t;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solv</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> ans=(<span class="number">1</span>&lt;&lt;<span class="number">18</span>)<span class="number">-1</span>;</span><br><span class="line">	<span class="type">int</span> x;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">		<span class="keyword">if</span>(x!=i<span class="number">-1</span>) ans&amp;=x;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;t);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=t;i++) <span class="built_in">solv</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="C-LIS-or-Reverse-LIS"><a href="#C-LIS-or-Reverse-LIS" class="headerlink" title="C. LIS or Reverse LIS?"></a>C. LIS or Reverse LIS?</h1><p>将一个序列重新排序，使得$\min (LIS(a), LIS(a’))$最大。（$LIS$为严格最长上升子序列）</p>
<p><del>最大的最小竟然不是二分了。</del>首先为了方便书写，定义$LDS$为严格最长下降子序列，即求最大的$\min (LIS(a), LDS(a))$。不妨分别思考 a 数组里出现两次及以上的数与只出现一次的数。</p>
<p><strong>两次及以上的数：</strong></p>
<p>由于序列的上升与下降要求是严格的，因此从中选出两个数，一个为$LIS$做 1 的贡献，一个为$LDS$做 1 的贡献，多的其实就没有用了。</p>
<p><strong>只出现一次的数：</strong></p>
<p>首先思考一件事，$LIS$和$LDS$最多只能有 1 个共同的数。因此应该有一个只出现一次的数为$LIS$和$LDS$同时做 1 的贡献（如果它能做到）。而剩下的就该被$LIS$和$LDS$平分了。</p>
<p>因此，使用 a 记录出现两次及以上的数，使用 b 记录只出现一次的数，答案应该为$a + \lceil {b \over 2} \rceil$。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> t;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[<span class="number">200010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solv</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">sort</span>(a+<span class="number">1</span>,a+n+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> now=<span class="number">-1</span>,num=<span class="number">-1</span>;</span><br><span class="line">	<span class="type">int</span> ans1=<span class="number">0</span>,ans2=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(a[i]!=now)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(num==<span class="number">1</span>) ans1++;</span><br><span class="line">			<span class="keyword">if</span>(num&gt;<span class="number">1</span>) ans2++;</span><br><span class="line"></span><br><span class="line">			num=<span class="number">1</span>;</span><br><span class="line">			now=a[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> num++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(num==<span class="number">1</span>) ans1++;</span><br><span class="line">	<span class="keyword">if</span>(num&gt;<span class="number">1</span>) ans2++;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans2+(ans1+<span class="number">1</span>)/<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;t);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=t;i++) <span class="built_in">solv</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>OI 比赛</tag>
        <tag>OI 题解</tag>
      </tags>
  </entry>
  <entry>
    <title>【题解】Codeforces Round 833 (Div. 2) A-C</title>
    <url>/2022/11/13/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91Codeforces-Round-833-Div-2-A-C/</url>
    <content><![CDATA[<p><strong>比赛传送门：<a href="https://codeforces.com/contest/1748">Codeforces Round 833 (Div. 2)</a></strong></p>
<p>这场的 B 题难想一些，许多人都卡住了。我跳过 B 想出了 C 题，但因为不开 long long 痛失上 1400 的机会，反而掉了 93 分。痛定思痛写一篇题解。</p>
<h1 id="A-The-Ultimate-Square"><a href="#A-The-Ultimate-Square" class="headerlink" title="A. The Ultimate Square"></a>A. The Ultimate Square</h1><p>有宽为 1，长为 1、1、2、2、3、3 的矩形序列，求前 n 个矩形能组成的最大的正方形的边长。</p>
<p>n与组成边长关系如下：</p>
<table>
<thead>
<tr>
<th align="center">n</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
<th align="center">5</th>
<th align="center">6</th>
<th align="center">6</th>
<th align="center">…</th>
</tr>
</thead>
<tbody><tr>
<td align="center">最大边长</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">2</td>
<td align="center">3</td>
<td align="center">3</td>
<td align="center">4</td>
<td align="center">…</td>
</tr>
</tbody></table>
<p>原理不难想象，每多一组长度为$x$和$x+1$的矩形后，就能摆成一个“L”型放在前面组成的正方形外围使其边长加 1。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> t;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solv</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(n%<span class="number">2</span>==<span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,(n/<span class="number">2</span>+<span class="number">1</span>));</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,(n/<span class="number">2</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	 <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;t);</span><br><span class="line">	 <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=t;i++) <span class="built_in">solv</span>();</span><br><span class="line">	 </span><br><span class="line">	 <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="B-Diverse-Substrings"><a href="#B-Diverse-Substrings" class="headerlink" title="B. Diverse Substrings"></a>B. Diverse Substrings</h1><p>当一个字符串里不同字符的个数大于最大的某字符出现次数，我们称这个字符串是“Diverse”的。现在给出一个只由 0 到 9 这 10 个数字组成的字符串，求它的所有子串里有多少是 Diverse 的。</p>
<p>由于只由 10 个数字组成，可以推出字符串里最大不同字符个数为 10，最长 Diverse 字符串长度为 100（每个数字各出现 10 次）。由此可以暴力枚举。我在比赛时想出了这个思路，但没有算好复杂度误认为枚举会超时。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> t;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solv</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	<span class="type">char</span> s[<span class="number">100010</span>];</span><br><span class="line"></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> f[<span class="number">10</span>]&#123;&#125;,distinct=<span class="number">0</span>,ma=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;=n;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> now=s[j]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span>(!f[now]) distinct++;</span><br><span class="line">			f[now]++;</span><br><span class="line"></span><br><span class="line">			ma=<span class="built_in">max</span>(ma,f[now]);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span>(ma&gt;<span class="number">10</span>) <span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">if</span>(ma&lt;=distinct) ans++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	 <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;t);</span><br><span class="line">	 <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=t;i++) <span class="built_in">solv</span>();</span><br><span class="line">	 </span><br><span class="line">	 <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="C-Zero-Sum-Prefixes"><a href="#C-Zero-Sum-Prefixes" class="headerlink" title="C. Zero-Sum Prefixes"></a>C. Zero-Sum Prefixes</h1><p>一个序列的得分定义为其有多少个前缀和为 0。现允许对序列中任意值为 0 的数修改成任意整数（可以仍是 0），找到最优修改方法使序列的得分最高，只输出得分。</p>
<p>对于原数组$a$，考虑前缀和数组$s$。</p>
<table>
<thead>
<tr>
<th align="center">a</th>
<th align="center">1</th>
<th align="center">0</th>
<th align="center">0</th>
<th align="center">1</th>
<th align="center">-1</th>
<th align="center">0</th>
<th align="center">1</th>
<th align="center">0</th>
<th align="center">-1</th>
</tr>
</thead>
<tbody><tr>
<td align="center">s</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">2</td>
<td align="center">1</td>
</tr>
</tbody></table>
<p>我们最后的目标是让$s$里有更多的 0。我们可以修改每个$a_i &#x3D; 0$的$i$位置，可以想到，假设我们修改$a_k$，这个操作会让$s_k$到$s_n$都改变$x$。我们想让更多的$s_i &#x3D; 0$，因此要找$s_k$到$s_n$里出现次数最多的数字，将他们统一修改为 0。这个结论对了一半，继续思考，假如我们在$k$的后方$l$的位置有$a_l &#x3D; 0$，那么$a_l$的修改同样会影响到它以及其后方所有$s_i$的修改。前面$k$处的修改只会数本身的值，而不会影响数之间的相对值，因此从$k$处向后数字最多出现的次数不会改变，也就仍可以找出现次数最多的数，将他们统一修改为 0。至此可以发现，每个$a_i &#x3D; 0$的管辖范围为从它本身开始到下一个$a_j &#x3D; 0$的位置结束。<strong>最后记得因为有前缀和，$a$也不小，开 long long。</strong></p>
<p><img src="/2022/11/13/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91Codeforces-Round-833-Div-2-A-C/1.png" alt="img"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> t;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">ll a[<span class="number">200010</span>],s[<span class="number">200010</span>];</span><br><span class="line"></span><br><span class="line">map&lt;ll,ll&gt; m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solv</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;a[i]);</span><br><span class="line">		s[i]=s[i<span class="number">-1</span>]+a[i];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> ma=<span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> las=<span class="number">-1</span>;</span><br><span class="line">	<span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">	m.<span class="built_in">erase</span>(m.<span class="built_in">begin</span>(),m.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(a[i]==<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			las=i;</span><br><span class="line">			m[s[i]]++;</span><br><span class="line">			<span class="keyword">if</span>(m[s[i]]&gt;ma) ma=m[s[i]];</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(las==<span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(s[i]==<span class="number">0</span>) ans++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;las;i++) <span class="keyword">if</span>(s[i]==<span class="number">0</span>) ans++;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=las+<span class="number">1</span>;i&lt;=n+<span class="number">1</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(a[i]==<span class="number">0</span>||i==n+<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			ans+=ma;</span><br><span class="line">			m.<span class="built_in">erase</span>(m.<span class="built_in">begin</span>(),m.<span class="built_in">end</span>());</span><br><span class="line">			ma=<span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		m[s[i]]++;</span><br><span class="line">		<span class="keyword">if</span>(m[s[i]]&gt;ma) ma=m[s[i]];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	 <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;t);</span><br><span class="line">	 <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=t;i++) <span class="built_in">solv</span>();</span><br><span class="line">	 </span><br><span class="line">	 <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>OI 比赛</tag>
        <tag>OI 题解</tag>
      </tags>
  </entry>
  <entry>
    <title>【题解】Educational Codeforces Round 129 (Rated for Div. 2) A-D</title>
    <url>/2022/05/24/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91Educational-Codeforces-Round-129-Rated-for-Div-2-A-D/</url>
    <content><![CDATA[<p><strong>比赛传送门：<a href="https://codeforces.com/contest/1681">Educational Codeforces Round 129 (Rated for Div. 2)</a></strong></p>
<p>这场感觉良好，似乎找回了一点感觉。不过 D 题差一点写出来还是有点可惜的。</p>
<h1 id="A-Game-with-Cards"><a href="#A-Game-with-Cards" class="headerlink" title="A. Game with Cards"></a>A. Game with Cards</h1><p>由于双方都选择最优策略，于是乎不论出牌先后，哪方拥有最大的点数牌哪方胜。当双方最大的点数牌相等时，哪方先手哪方胜（因为先手出最大点数牌会让对方无牌可出）。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> t;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solv</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x;</span><br><span class="line">	<span class="type">int</span> max1=<span class="number">0</span>,max2=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">		max1=<span class="built_in">max</span>(max1,x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;m);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">		max2=<span class="built_in">max</span>(max2,x);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(max1&gt;max2)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Alice\nAlice\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(max1&lt;max2)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Bob\nBob\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Alice\nBob\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;t);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=t;i++) <span class="built_in">solv</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="B-Card-Trick"><a href="#B-Card-Trick" class="headerlink" title="B. Card Trick"></a>B. Card Trick</h1><p>如果将这一组有顺序排列的牌首尾相接看成一个环，牌顶位置记录标记，那么可以发现“将牌顶 x 张牌置于牌底”这个操作并不会改变环的连接顺序，而只是将记录牌顶位置的标记向后推了 x 位。由此就可以写程序了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> t;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> a[<span class="number">200010</span>];</span><br><span class="line"><span class="type">int</span> b[<span class="number">200010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solv</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;m);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;b[i]);</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> index=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		index+=b[i];</span><br><span class="line">		index%=n;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,a[index+<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;t);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=t;i++) <span class="built_in">solv</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="C-Double-Sort"><a href="#C-Double-Sort" class="headerlink" title="C. Double Sort"></a>C. Double Sort</h1><p>首先可以看出两个数组元素的对应关系是绑定的，因此可以使用结构体存储，利用 sort 排序结构体的技巧对进行排序，后检查是否能够做到完全排列好。若不行，输出“-1”。</p>
<p>此时我们有原数组和排序好的数组。由于数据量很小，于是乎想到一种记录交换的方法：遍历原数组，每当发现本位值和本位排序好的值不同时，向后搜寻与排序好的值相同的值的位置，记录答案并交换。由于$n \leq 100$，因此可以在 $10^4$内完成工作。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> t;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> ans1[<span class="number">10010</span>],ans2[<span class="number">10010</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> a;</span><br><span class="line">	<span class="type">int</span> b;</span><br><span class="line">&#125;d[<span class="number">110</span>],yuan[<span class="number">110</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(node x,node y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x.a==y.a) <span class="keyword">return</span> x.b&lt;y.b; </span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> x.a&lt;y.a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">same</span><span class="params">(node x,node y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x.a==y.a&amp;&amp;x.b==y.b) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(node &amp;x,node &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	node z=x;</span><br><span class="line">	x=y;</span><br><span class="line">	y=z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solv</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;d[i].a);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;d[i].b);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) yuan[i].a=d[i].a;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) yuan[i].b=d[i].b;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">sort</span>(d+<span class="number">1</span>,d+n+<span class="number">1</span>,cmp);</span><br><span class="line"></span><br><span class="line"><span class="comment">//	for(int i=1;i&lt;=n;i++) printf(&quot;%d &quot;,d[i].a);</span></span><br><span class="line"><span class="comment">//	printf(&quot;\n&quot;);</span></span><br><span class="line"><span class="comment">//	for(int i=1;i&lt;=n;i++) printf(&quot;%d &quot;,d[i].b);</span></span><br><span class="line"><span class="comment">//	printf(&quot;\n&quot;);</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(d[i].a&lt;d[i<span class="number">-1</span>].a||d[i].b&lt;d[i<span class="number">-1</span>].b)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(!<span class="built_in">same</span>(yuan[i],d[i]))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> ind1=i;</span><br><span class="line">	</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(<span class="built_in">same</span>(yuan[j],d[i]))</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="type">int</span> ind2=j;</span><br><span class="line">			</span><br><span class="line">					<span class="keyword">if</span>(i!=j)</span><br><span class="line">					&#123;</span><br><span class="line">						ans++;</span><br><span class="line">				</span><br><span class="line">						<span class="keyword">if</span>(ans&gt;<span class="number">10000</span>)</span><br><span class="line">						&#123;</span><br><span class="line">							<span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>);</span><br><span class="line">							<span class="keyword">return</span>;</span><br><span class="line">						&#125;</span><br><span class="line">				</span><br><span class="line">						ans1[ans]=ind1,ans2[ans]=ind2;</span><br><span class="line">						<span class="built_in">swap</span>(yuan[i],yuan[j]);</span><br><span class="line">					&#125;</span><br><span class="line">			</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=ans;i++) <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,ans1[i],ans2[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;t);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=t;i++) <span class="built_in">solv</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="D-Required-Length"><a href="#D-Required-Length" class="headerlink" title="D. Required Length"></a>D. Required Length</h1><p>看了题解，发现确实没写出来也并不可惜，因为似乎使用 map 进行记录是必要的。首先确定不是贪心，因为局部的选取最大的数不一定能够使结果更小，即局部最优不代表全局最优。其次确定数量级，我们可以认为最后的数的值为$x \cdot 2^a \cdot 3^b \cdot 5^c \cdot 7^d$，由于最后的数小于$10^{19}$，因此可以推算出 a 不大于 63 ， b 不大于 39 ， c 不大于 27 ， d 不大于 22 。四者乘积数量级为 $10^6$，这是完全可以接受的，因此可以尝试使用 BFS 或者 DP 进行求解。</p>
<p>本体中使用了 map 作为打标记数组进行了记录，由于我不会这个 STL ，因此才导致了本题的超时。同时也告诉了我有的时候 BFS 在写某些 DP 题的时候也可以考虑。</p>
<p>我写的 DP ：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">ll n,x;</span><br><span class="line"></span><br><span class="line">ll dp[<span class="number">60</span>][<span class="number">800010</span>];</span><br><span class="line"><span class="type">int</span> len[<span class="number">60</span>];</span><br><span class="line"></span><br><span class="line">map&lt;<span class="type">long</span> <span class="type">long</span>,<span class="type">int</span>&gt; dist;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">count</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(x)</span><br><span class="line">	&#123;</span><br><span class="line">		num++;</span><br><span class="line">		x/=<span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,&amp;n,&amp;x);</span><br><span class="line"></span><br><span class="line">	dp[<span class="number">1</span>][<span class="number">1</span>]=x;</span><br><span class="line">	len[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=<span class="number">30</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=len[i<span class="number">-1</span>];j++)</span><br><span class="line">		&#123;</span><br><span class="line">			ll now=dp[i<span class="number">-1</span>][j];</span><br><span class="line">	</span><br><span class="line">			<span class="keyword">while</span>(now)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(now%<span class="number">10</span>&gt;<span class="number">1</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					ll temp=dp[i<span class="number">-1</span>][j]*(now%<span class="number">10</span>);</span><br><span class="line">					<span class="keyword">if</span>(!dist.<span class="built_in">count</span>(temp))</span><br><span class="line">					&#123;</span><br><span class="line">						dp[i][++len[i]]=temp;</span><br><span class="line">						dist[temp]=<span class="number">1</span>;</span><br><span class="line">					&#125;</span><br><span class="line">			</span><br><span class="line">				&#125;</span><br><span class="line">				now/=<span class="number">10</span>;</span><br><span class="line">		</span><br><span class="line">				<span class="keyword">if</span>(<span class="built_in">count</span>(dp[i][len[i]])==n)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,i<span class="number">-1</span>);</span><br><span class="line">					<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>题解的 BFS ：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> v;</span><br><span class="line">    cin &gt;&gt; v;</span><br><span class="line">    queue&lt;<span class="type">long</span> <span class="type">long</span>&gt; q;</span><br><span class="line">    map&lt;<span class="type">long</span> <span class="type">long</span>, <span class="type">int</span>&gt; dist;</span><br><span class="line">    dist[v] = <span class="number">0</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(v);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> k = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        string s = <span class="built_in">to_string</span>(k);</span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">size</span>() == n)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; dist[k] &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x : s)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(x == <span class="string">&#x27;0&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> w = k * <span class="built_in">int</span>(x - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            <span class="keyword">if</span>(!dist.<span class="built_in">count</span>(w))</span><br><span class="line">            &#123;</span><br><span class="line">                dist[w] = dist[k] + <span class="number">1</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(w);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>OI 比赛</tag>
        <tag>OI 题解</tag>
      </tags>
  </entry>
  <entry>
    <title>【题解】洛谷 P1072 Hankson 的趣味题</title>
    <url>/2022/04/03/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91%E6%B4%9B%E8%B0%B7-P1072-Hankson-%E7%9A%84%E8%B6%A3%E5%91%B3%E9%A2%98/</url>
    <content><![CDATA[<p><strong>题目传送门：<a href="https://www.luogu.com.cn/problem/P1072">洛谷 P1072 Hankson 的趣味题</a></strong></p>
<p>第一眼看到这道题直接就想到了质因数分解…然后就用一种很奇怪的方法解出了答案。</p>
<p>总结一下题目：</p>
<p>$$<br>已知：<br>\begin{cases}<br>    \gcd (x, a_0) &#x3D; a_1 \<br>    lcm (x, b_0) &#x3D; b_1 \<br>\end{cases}<br>，求x<br>$$</p>
<p>引入一个定理：</p>
<p>设两个数$i &#x3D; \prod^s_{k &#x3D; 1} p_k^{a_k}$，$j &#x3D; \prod^s_{k &#x3D; 1} p_k^{b_k}$，则由算术基本定理（又叫整数惟一分解定理）得到：</p>
<p>$\gcd(i, j) &#x3D; \prod^s_{k &#x3D; 1} p_k^{\min(a_k, b_k)}$</p>
<p>$lcm(i,j) &#x3D; \prod^s_{k &#x3D; 1} p_k^{\max(a_k, b_k)}$</p>
<p>将定理应用到本题：</p>
<p>$x &#x3D; \prod^s_{m &#x3D; 1} p_m^{i_m}$</p>
<p>$a_0 &#x3D; \prod^s_{m &#x3D; 1} p_m^{j_m}$</p>
<p>$b_0 &#x3D; \prod^s_{m &#x3D; 1} p_m^{k_m}$</p>
<p>$a_1 &#x3D; \gcd(x, a_0) &#x3D; \prod^s_{m &#x3D; 1} p_m^{\min(i_m, j_m)}$</p>
<p>$b_1 &#x3D; lcm(x,b_0) &#x3D; \prod^s_{m &#x3D; 1} p_m^{\max(i_m, k_m)}$</p>
<p>由于$a_0$、$a_1$、$b_0$、$b_1$已知，则对于$m$取任意值时，$j_m$、$k_m$、$\min(i_m, j_m)$、$\max(i_m, k_m)$已知，只要求出$i_m$，即可确定$x$的质因数分解形式，从而求得$x$。实践一下就会发现，根据这4个已知值无法确定$i_m$的具体值，但可以确定$i_m$的取值范围，从而确定任意$i_m$的取值个数$c_m$。易得$ans &#x3D; \prod^s_{m &#x3D; 1} c_m$。于是接下来，分析如何确定$i_m$的取值范围：</p>
<p>由于书写繁琐，将$j_m$、$k_m$、$\min(i_m, j_m)$、$\max(i_m, j_m)$、$c_m$简写为$j$、$k$、$\min(i, j)$、$\max(i, k)$、$c$。</p>
<ol>
<li><p>当$j &lt; k$时</p>
<p>有四个关系可以概括$j &lt; k$时的所有可能：</p>
<ul>
<li>$j &#x3D; \min(i, j)$、$k &#x3D; \max(i, k)$①</li>
<li>$j \neq \min(i, j)$、$k &#x3D; \max(i, k)$②</li>
<li>$j &#x3D; \min(i, j)$、$k \neq \max(i, k)$③</li>
<li>$j \neq \min(i, j)$、$k \neq \max(i, k)$④</li>
</ul>
<p>画出一个数轴，从数轴上尝试$i$的可能取值所导致的结果：</p>
<p><img src="/2022/04/03/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91%E6%B4%9B%E8%B0%B7-P1072-Hankson-%E7%9A%84%E8%B6%A3%E5%91%B3%E9%A2%98/1.png" alt="img"></p>
<p>红色的$i$始终满足②。且可知使②成立的$i$唯一，为$\min(i, j)$，因此$c &#x3D; 1$。</p>
<p>绿色的$i$始终满足③。且可知使③成立的$i$唯一，为$\max(i, k)$，因此$c &#x3D; 1$。</p>
<p><img src="/2022/04/03/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91%E6%B4%9B%E8%B0%B7-P1072-Hankson-%E7%9A%84%E8%B6%A3%E5%91%B3%E9%A2%98/2.png" alt="img"></p>
<p><img src="/2022/04/03/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91%E6%B4%9B%E8%B0%B7-P1072-Hankson-%E7%9A%84%E8%B6%A3%E5%91%B3%E9%A2%98/3.png" alt="img"></p>
<p>$i$始终满足①。且可知使①成立的$i$可取$j$到$k$的任意整数（包括$j$、$k$），因此$c &#x3D; k - j + 1$。</p>
</li>
<li><p>当$j &gt; k$时</p>
<p>与第一种情况的思考方式类似，不再展开。</p>
</li>
<li><p>当$j &#x3D; k$时</p>
<p>与第一种情况的思考方式类似，不再展开。最终可以和第一种情况合并。</p>
</li>
</ol>
<p>最后计算答案即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 50000 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> t;</span><br><span class="line"><span class="type">int</span> isp[N],p[N],len=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solv</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> ab[<span class="number">5</span>];</span><br><span class="line">	<span class="type">int</span> abp[<span class="number">5</span>][<span class="number">50010</span>];</span><br><span class="line">	<span class="type">int</span> ans=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;ab[<span class="number">1</span>],&amp;ab[<span class="number">2</span>],&amp;ab[<span class="number">3</span>],&amp;ab[<span class="number">4</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">4</span>;i++)</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=<span class="number">50000</span>;j++)</span><br><span class="line">		abp[i][j]=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">4</span>;i++)		<span class="comment">//质因数分解</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;p[j]*p[j]&lt;=ab[i];j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">while</span>(ab[i]%p[j]==<span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				ab[i]/=p[j];</span><br><span class="line">				abp[i][p[j]]++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(ab[i]&gt;<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(ab[i]&lt;=<span class="number">50000</span>) abp[i][ab[i]]++;</span><br><span class="line">			<span class="keyword">else</span> abp[i][<span class="number">0</span>]++;	<span class="comment">//只记录了有无大素数，其实可能出问题</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//	测试用的</span></span><br><span class="line"><span class="comment">//	for(int i=1;i&lt;=4;i++)</span></span><br><span class="line"><span class="comment">//	&#123;</span></span><br><span class="line"><span class="comment">//		if(abp[i][0]) printf(&quot;%d &quot;,abp[i][0]);</span></span><br><span class="line"><span class="comment">//		for(int j=1;j&lt;=len;j++)</span></span><br><span class="line"><span class="comment">//		&#123;</span></span><br><span class="line"><span class="comment">//			if(abp[i][p[j]]) printf(&quot;%d/%d &quot;,p[j],abp[i][p[j]]);</span></span><br><span class="line"><span class="comment">//		&#125;</span></span><br><span class="line"><span class="comment">//		printf(&quot;\n&quot;);</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line"></span><br><span class="line">	p[<span class="number">0</span>]=<span class="number">0</span>;		<span class="comment">//为了把abp[i][0]里记录的大素数算在循环里</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=len;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> now=p[i];</span><br><span class="line"></span><br><span class="line">		<span class="type">int</span> a0=abp[<span class="number">1</span>][now];</span><br><span class="line">		<span class="type">int</span> a1=abp[<span class="number">2</span>][now];</span><br><span class="line">		<span class="type">int</span> b0=abp[<span class="number">3</span>][now];</span><br><span class="line">		<span class="type">int</span> b1=abp[<span class="number">4</span>][now];</span><br><span class="line"></span><br><span class="line"><span class="comment">//		一开始的判断方法，虽然对了，但不知道为什么：（</span></span><br><span class="line"><span class="comment">//		if(a1==a0&amp;&amp;b1==b0) ans*=(b0-a0+1);</span></span><br><span class="line"><span class="comment">//		if(a1==b1&amp;&amp;b0&lt;a1&amp;&amp;a1&lt;a0) continue;</span></span><br><span class="line"><span class="comment">//		if(a1!=a0&amp;&amp;b1!=b0)</span></span><br><span class="line"><span class="comment">//		&#123;</span></span><br><span class="line"><span class="comment">//			printf(&quot;0\n&quot;);</span></span><br><span class="line"><span class="comment">//			return;</span></span><br><span class="line"><span class="comment">//		&#125;</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(a0&lt;=b0)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(a1==a0&amp;&amp;b1==b0) ans*=(b0-a0+<span class="number">1</span>);</span><br><span class="line">			<span class="keyword">if</span>(a1!=a0&amp;&amp;b1!=b0) &#123;<span class="built_in">printf</span>(<span class="string">&quot;0\n&quot;</span>); <span class="keyword">return</span>;&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(a0&gt;b0)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(a1==a0&amp;&amp;b1==b0) &#123;<span class="built_in">printf</span>(<span class="string">&quot;0\n&quot;</span>); <span class="keyword">return</span>;&#125;</span><br><span class="line">			<span class="keyword">if</span>(a1!=a0&amp;&amp;b1!=b0&amp;&amp;a1!=b1) &#123;<span class="built_in">printf</span>(<span class="string">&quot;0\n&quot;</span>); <span class="keyword">return</span>;&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=N;i++) isp[i]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=<span class="built_in">sqrt</span>(N);i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(!isp[i]) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=i*<span class="number">2</span>;j&lt;=N;j+=i) isp[j]=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=N;i++) <span class="keyword">if</span>(isp[i]) p[++len]=i;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;t);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=t;i++) <span class="built_in">solv</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后贴一篇应该是正解的题解：<a href="https://blog.csdn.net/nuclearsubmarines/article/details/77603154">题解</a></p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>OI 题解</tag>
      </tags>
  </entry>
  <entry>
    <title>【题解】洛谷 P1080 [NOIP2012 提高组] 国王游戏</title>
    <url>/2024/05/03/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91%E6%B4%9B%E8%B0%B7-P1080-NOIP2012-%E6%8F%90%E9%AB%98%E7%BB%84-%E5%9B%BD%E7%8E%8B%E6%B8%B8%E6%88%8F/</url>
    <content><![CDATA[<p><strong>题目传送门：<a href="https://www.luogu.com.cn/problem/P1080">洛谷 P1080 [NOIP2012 提高组] 国王游戏</a></strong></p>
<p>一道每隔几个月搬出来都会忘记怎么写的题。题目中高精的内容不再赘述，主要探讨其中的贪心思想。</p>
<p>设有相邻的大臣 $1$、$2$，他们左手右手的数字分别为 $a_1$、$b_1$、$a_2$、$b_2$，他们之前国王和所有大臣左手数字的乘积为 $a_0$。那么交换前的答案应为 $\max ({a_0 \over b_1}, {a_0 a_1 \over b_2})$，交换后的答案应为 $\max ({a_0 \over b_2}, {a_0 a_2 \over b_1})$，我们希望不需要交换得到更大的答案，即希望 $\max ({a_0 \over b_1}, {a_0 a_1 \over b_2}) \leq \max ({a_0 \over b_2}, {a_0 a_2 \over b_1})$。因为 ${a_0 \over b_1} &lt; {a_0 a_2 \over b_1}$，${a_0 a_1 \over b_2} &gt; {a_0 \over b_2}$，那么若想原式成立就必须要有 ${a_0 a_1 \over b_2} \leq {a_0 a_2 \over b_1}$，化简有 $a_1 b_1 \leq a_2 b_2$，即相邻的大臣满足此式就可以取得更大的答案。</p>
<p>同时题目中的计算公式满足一些美好的性质。假设现在存在一个队伍顺序 $s_{1 \dots n}$，每个人所能获得的金币数为 $c_{1 \dots n}$。当我们选择其中相邻的两个大臣位置 $x$、$x + 1$ 并进行顺序交换时，只有 $c_x$、$c_{x + 1}$ 会产生变化。我们可以不断的相邻交换直到找到一个不存在任何交换可以让答案变得更优的排列，又因通过相邻的交换可以得到任意排列情况，即按照 $a_x b_x \leq a_{x + 1} b_{x + 1}$ 进行排序。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> ans[<span class="number">100010</span>],lena;</span><br><span class="line"><span class="type">int</span> now[<span class="number">100010</span>],len;</span><br><span class="line"><span class="type">int</span> lin[<span class="number">100010</span>],lenl;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> a;</span><br><span class="line">	<span class="type">int</span> b;</span><br><span class="line">	<span class="type">int</span> w;</span><br><span class="line">&#125;p[<span class="number">1010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span> &amp;x,<span class="type">int</span> &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> z=x;</span><br><span class="line">	x=y;</span><br><span class="line">	y=z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reverse</span><span class="params">(<span class="type">int</span> *x,<span class="type">int</span> &amp;len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=len/<span class="number">2</span>;i++) <span class="built_in">swap</span>(x[i],x[len-i+<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(Person x,Person y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x.w&lt;y.w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;p[i].a,&amp;p[i].b);</span><br><span class="line">		p[i].w=p[i].a*p[i].b;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">sort</span>(p+<span class="number">1</span>,p+n+<span class="number">1</span>,cmp);</span><br><span class="line">	</span><br><span class="line">	now[<span class="number">1</span>]=<span class="number">1</span>,len=<span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> c;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> v=<span class="number">1</span>;v&lt;=n;v++)</span><br><span class="line">	&#123;</span><br><span class="line">		c=p[v<span class="number">-1</span>].a;</span><br><span class="line"><span class="comment">//		for(int i=1;i&lt;=len;i++) printf(&quot;%d&quot;,now[i]);</span></span><br><span class="line"><span class="comment">//		printf(&quot;*%d=&quot;,c);</span></span><br><span class="line">		<span class="built_in">reverse</span>(now,len);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=len;i++) now[i]*=c;</span><br><span class="line">		len+=<span class="number">10</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;len;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(now[i]&gt;<span class="number">9</span>) now[i+<span class="number">1</span>]+=now[i]/<span class="number">10</span>;</span><br><span class="line">			now[i]%=<span class="number">10</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span>(!now[len]&amp;&amp;len&gt;<span class="number">1</span>) len--;</span><br><span class="line">		<span class="built_in">reverse</span>(now,len);</span><br><span class="line"><span class="comment">//		for(int i=1;i&lt;=len;i++) printf(&quot;%d&quot;,now[i]);</span></span><br><span class="line"><span class="comment">//		printf(&quot;\n&quot;);</span></span><br><span class="line">		</span><br><span class="line">		c=p[v].b;</span><br><span class="line">		lenl=len;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=len;i++) lin[i]=now[i];</span><br><span class="line"><span class="comment">//		for(int i=1;i&lt;=lenl;i++) printf(&quot;%d&quot;,lin[i]);</span></span><br><span class="line"><span class="comment">//		printf(&quot;/%d=&quot;,c);</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=lenl;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> mod=lin[i]%c;</span><br><span class="line">			lin[i]/=c;</span><br><span class="line">			lin[i+<span class="number">1</span>]+=mod*<span class="number">10</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> flag=<span class="number">0</span>,num;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=lenl;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(lin[i]&amp;&amp;!flag)</span><br><span class="line">			&#123;</span><br><span class="line">				num=i<span class="number">-1</span>;</span><br><span class="line">				flag=<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(flag) lin[i-num]=lin[i];</span><br><span class="line">		&#125;</span><br><span class="line">		lenl-=num;</span><br><span class="line"><span class="comment">//		for(int i=1;i&lt;=lenl;i++) printf(&quot;%d&quot;,lin[i]);</span></span><br><span class="line"><span class="comment">//		printf(&quot;\n&quot;);</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(lenl&gt;lena)</span><br><span class="line">		&#123;</span><br><span class="line">			lena=lenl;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=lenl;i++) ans[i]=lin[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(lenl==lena)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=lenl;i++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(ans[i]&gt;lin[i]) <span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">if</span>(ans[i]&lt;lin[i])</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=lenl;i++) ans[i]=lin[i];</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=lena;i++) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans[i]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>OI 题解</tag>
      </tags>
  </entry>
  <entry>
    <title>【题解】洛谷 P1280 尼克的任务</title>
    <url>/2024/03/29/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91%E6%B4%9B%E8%B0%B7-P1280-%E5%B0%BC%E5%85%8B%E7%9A%84%E4%BB%BB%E5%8A%A1/</url>
    <content><![CDATA[<p><strong>题目传送门：<a href="https://www.luogu.com.cn/problem/P1280">洛谷 P1280 尼克的任务</a></strong></p>
<p>这个题在我印象中我有反复写它两三次了，但是每次都是因为时间相隔太久而忘记了动规的写法，直到这一次校内新生杯出题我把它抄了过来并写了一份题解，我觉得才能算是完全理解了这个题的解法。</p>
<p>此题将时刻做阶段划分，有正向与反向两种思路。</p>
<p>首先介绍更为直观的反向 DP 思路：</p>
<p><strong>将时刻作为阶段划分的标志，设 $dp[i]$ 为第 $i$ 分钟开始到第 $n$ 分钟结束所能休息的最大时间。</strong>考虑第 $i$ 分钟开始无任务和有任务两种情况：</p>
<ul>
<li>如果没有任务，则第 $i$ 分钟在休息，因此 $dp[i] &#x3D; dp[i + 1] + 1$；</li>
<li>如果有任务，则必须选一个任务做，此时的最大休息时间应和做完任务的最大休息时间相同，即 $dp[i] &#x3D; \max (dp[i + ren[j].t])$，其中 $ren[j].t$ 代表从第 $i$ 分钟开始的所有 $j$ 个任务的持续时间。</li>
</ul>
<p>正向思路不算严格的 DP，更类似于特殊的最长路问题：</p>
<p><strong>将时刻作为阶段划分的标志，设 $dp[i]$ 为在确实可达第 $i$ 分钟开始的前提下（指第 $i$ 分钟开始时不在任务中），第 $1$ 分钟开始到第 $i$ 分钟开始所能休息的最大时间。</strong>设 $dp$ 数组为无穷小代表所有点不可达，初始化 $dp[1] &#x3D; 0$，考虑第 $i$ 分钟开始且可达的情况下无任务和有任务两种情况：</p>
<ul>
<li>如果有任务，则必须选一个任务做，做完每个任务的最大休息时间应被此时的最大休息时间更新，即 $dp[dp[i + ren[j].t]] &#x3D; \max (dp[i + ren[j].t], dp[i])$，其中 $ren[j].t$ 代表从第 $i$ 分钟开始的所有 $j$ 个任务的持续时间；</li>
<li>如果没有任务，则第 $i$ 分钟在休息，<strong>同时注意到该点可能被任务提前更新过</strong>，因此 $dp[i + 1] &#x3D; \max(dp[i + 1], dp[i] + 1)$。</li>
</ul>
<p>要注意的是，在正向思路中 $dp[i]$ 是在遍历到 $i$ 前就被反复更新的，直到遍历到 $i$ 时，$dp[i]$ 的值才为第 $1$ 分钟开始到第 $i$ 分钟开始所能休息的最大时间。</p>
<p>注：在反向思路中，第 $i$ 分钟前开始的任务不会被考虑；在正向思路中，第 $i$ 分钟后才结束的任务会被考虑。</p>
<p><strong>反向思路 标准程序 C++11</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,k;</span><br><span class="line"><span class="type">int</span> num[<span class="number">10010</span>];</span><br><span class="line"><span class="type">int</span> dp[<span class="number">10010</span>];</span><br><span class="line"><span class="type">int</span> whi=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">work</span> &#123;<span class="type">int</span> st,ti;&#125;ren[<span class="number">10010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(work a,work b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a.st&gt;b.st;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> p,t;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;k);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;ren[i].st,&amp;ren[i].ti);</span><br><span class="line">		num[ren[i].st]++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">sort</span>(ren+<span class="number">1</span>,ren+k+<span class="number">1</span>,cmp);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(!num[i]) dp[i]=dp[i+<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=num[i];j++)</span><br><span class="line">			&#123;</span><br><span class="line">				dp[i]=<span class="built_in">max</span>(dp[i],dp[i+ren[whi].ti]);</span><br><span class="line">				whi++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,dp[<span class="number">1</span>]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>正向思路 标准程序 C++11</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,k;</span><br><span class="line"><span class="type">int</span> num[<span class="number">10010</span>];</span><br><span class="line"><span class="type">int</span> dp[<span class="number">10010</span>];</span><br><span class="line"><span class="type">int</span> whi=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">work</span> &#123;<span class="type">int</span> st,ti;&#125;ren[<span class="number">10010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(work a,work b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a.st&lt;b.st;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> p,t;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;k);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;ren[i].st,&amp;ren[i].ti);</span><br><span class="line">		num[ren[i].st]++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">sort</span>(ren+<span class="number">1</span>,ren+k+<span class="number">1</span>,cmp);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) dp[i]=<span class="number">-99999999</span>;</span><br><span class="line">	dp[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(!num[i]) dp[i+<span class="number">1</span>]=<span class="built_in">max</span>(dp[i+<span class="number">1</span>],dp[i]+<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=num[i];j++)</span><br><span class="line">			&#123;</span><br><span class="line">				dp[i+ren[whi].ti]=<span class="built_in">max</span>(dp[i+ren[whi].ti],dp[i]);</span><br><span class="line">				whi++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,dp[n+<span class="number">1</span>]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>OI 题解</tag>
      </tags>
  </entry>
  <entry>
    <title>【题解】洛谷 P1787 [入门赛 #22] 非众数 Hard Version</title>
    <url>/2024/05/02/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91%E6%B4%9B%E8%B0%B7-P1787-%E5%85%A5%E9%97%A8%E8%B5%9B-22-%E9%9D%9E%E4%BC%97%E6%95%B0-Hard-Version/</url>
    <content><![CDATA[<p><strong>题目传送门：<a href="https://www.luogu.com.cn/problem/P1787">P1787 洛谷 [入门赛 #22] 非众数 Hard Version</a></strong></p>
<p><strong>题解传送门：<a href="https://www.luogu.com.cn/article/167o6gpe">洛谷 2024 年 4 月入门赛 H 题加强版题解</a></strong></p>
<p>这道题是<a href="https://www.luogu.com.cn/contest/166340">【LGR-182-Div.4】洛谷入门赛 #22</a>中最后一题的 Hard Version，并不计入本场比赛的排名。比较有趣的是这场比赛似乎是我生涯里第一次网络赛 AK。题目的题解一直找不到，我是过了很久才在 yummy 的博客里发现的。</p>
<p>暴力的话就是遍历区间左边界、右边界、区间本身，就是 $O(n^3)$ 了（忽略了字符数量带来的常数），时间爆炸，于是逐层考虑优化。算一个串没有绝对众数需要考虑所有出现的字母数量都不超过一半，而算一个串有绝对众数可以外层遍历字符，内层遍历判断当前字符在该串是否达到了一半及以上，这种针对字符的遍历让结构更为清晰。因此答案的计算方法为所有非空子串数减去绝对众数子串数。</p>
<p>在计算某个字符 $ch$ 对串的影响时，可以将本字符记为 $+ 1$ 分，其它字符记为 $- 1$ 分，那么一个子串 $s_{l \dots r}$ 以该字符为绝对众数，当且仅当这个子串总分是正数。如果记 $sum_x$ 为 $s_{1 \dots x}$ 的总分（前缀和），则是 $s_{l \dots r}$ 该字符为绝对众数的子串当且仅当 $sum_r - sum_{l - 1} &gt; 0$。此时时间复杂度降至 $O(n^2)$。</p>
<p>由于 $sum_{x + 1}$ 只能可能等于 $sum_x + 1$ 或 $sum_x - 1$，即是连续变化的，因此在从前往后计算 $sum$ 的同时，用一个桶记录当前每种 $sum$ 的个数，在 $sum$ 更新时同时更新当前有多少个前缀和比当前 $sum$ 小（相减后大于 $0$）并记录到答案中。此时时间复杂度降至 $O(n)$。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> s[<span class="number">100010</span>];</span><br><span class="line"><span class="type">int</span> bu[<span class="number">200010</span>];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">ll ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	n=<span class="built_in">strlen</span>(s+<span class="number">1</span>);</span><br><span class="line">	ans=(ll)n*(n+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">char</span> c=<span class="string">&#x27;a&#x27;</span>;c&lt;=<span class="string">&#x27;z&#x27;</span>;c++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> sum=n;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">2</span>*n;i++) bu[i]=<span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">		<span class="type">int</span> les=<span class="number">0</span>;</span><br><span class="line">		bu[sum]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(s[i]==c)</span><br><span class="line">			&#123;</span><br><span class="line">				les+=bu[sum];</span><br><span class="line">				sum++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				sum--;</span><br><span class="line">				les-=bu[sum];</span><br><span class="line">			&#125;</span><br><span class="line">		</span><br><span class="line">			bu[sum]++;</span><br><span class="line">			ans-=les;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>OI 比赛</tag>
        <tag>OI 题解</tag>
      </tags>
  </entry>
  <entry>
    <title>【题解】洛谷 P5521 [yLOI2019] 梅深不见冬</title>
    <url>/2024/05/03/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91%E6%B4%9B%E8%B0%B7-P5521-yLOI2019-%E6%A2%85%E6%B7%B1%E4%B8%8D%E8%A7%81%E5%86%AC/</url>
    <content><![CDATA[<p><strong>题目传送门：<a href="https://www.luogu.com.cn/problem/P5521">洛谷 P5521 [yLOI2019] 梅深不见冬</a></strong></p>
<p>首先介绍一个由于拿了 85 分被我误以为是正解的错误思路，可以举出反例。拿 85 分大概率是因为数据比较水。</p>
<p>简单解释如下：<code>dfs(u)</code> 的返回值为放置好 <code>u</code> 节点的梅花所需的最小梅花数量，它来自三种值中的最大值：</p>
<ol>
<li>同时摆好 <code>u</code> 和其所有子节点所需的梅花数量；</li>
<li>摆好 <code>u</code> 的某个重量级节点 <code>v</code> 所需的梅花数量（因为要摆好 <code>v</code> 后才能撤掉摆 <code>v</code> 花费的梅花，这个值可能很大）；</li>
<li>摆好 <code>u</code> 的最后一个子节点 <code>v</code> 还未撤掉摆 <code>v</code> 花费的梅花的那一刻（要依此尝试最后摆哪个节点才能让本花费最小）。</li>
</ol>
<p>一个反例：</p>
<table>
<thead>
<tr>
<th>$w_i$</th>
<th>$50$</th>
<th>$5$</th>
<th>$3$</th>
</tr>
</thead>
<tbody><tr>
<td>$ans_i$</td>
<td>$100$</td>
<td>$10$</td>
<td>$51$</td>
</tr>
</tbody></table>
<p>以上为节点 <code>u</code> 的 3 个子节点，$w_i$ 是这个节点所需梅花数量，$ans_i$ 是摆这个节点所需最小梅花数量。在这个情况下，使用上述思路，第 2 种值为 $100$，第 3 种值为 $63$，但实际情况是无论怎样排列，最终同时需要的梅花都会超出 $100$。正解的答案来自于两种值的最大值：</p>
<ol>
<li>同时摆好 <code>u</code> 和其所有子节点所需的梅花数量；</li>
<li>同时摆好 <code>u</code> 的所有子节点的所有方案中的最小值。</li>
</ol>
<p>错误思路中的第 2、3 种值并不与正解的第 2 种值一致，因此导致错误。现在要找到一种顺序，使得摆好 <code>u</code> 的所有子节点的花费最小。该思路与<a href="https://www.luogu.com.cn/problem/P1080">国王游戏</a>十分相似，要看相邻两个节点的交换情况。</p>
<p>设有相邻的节点 $1$、$2$，这个节点所需梅花数量和摆这个节点所需最小梅花数量分别为 $w_1$、$ans_1$、$w_2$、$ans_2$，它们之前累计摆好的节点所需梅花数量为 $w_0$。那么交换前的答案应为 $\max (w_0 + ans_1, w_0 + w_1 + ans_2)$，交换后的答案应为 $\max (w_0 + ans_2, w_0 + w_2 + ans_1)$，我们希望不需要交换得到更大的答案，即希望 $\max (w_0 + ans_1, w_0 + w_1 + ans_2) \leq \max (w_0 + ans_2, w_0 + w_2 + ans_1)$。因为 $w_0 + ans_1 &lt; w_0 + w_2 + ans_1$，$w_0 + w_1 + ans_2 &gt; w_0 + ans_2$，那么若想原式成立就必须要有 $w_0 + w_1 + ans_2 \leq w_0 + w_2 + ans_1$，化简有 $w_1 - ans_1 \leq w_2 - ans_2$，即相邻的节点满足此式就可以取得更大的答案。</p>
<p>同时题目中的计算公式满足一些美好的性质。假设现在存在一个遍历顺序 $s_{1 \dots n}$，放置到某节点所需总梅花数为 $c_{1 \dots n}$。当我们选择其中相邻的两个节点位置 $x$、$x + 1$ 并进行顺序交换时，只有 $c_x$、$c_{x + 1}$ 会产生变化。我们可以不断的相邻交换直到找到一个不存在任何交换可以让答案变得更优的排列，又因通过相邻的交换可以得到任意排列情况，即按照 $w_1 - ans_1 \leq w_2 - ans_2$ 进行排序。</p>
<p><strong>开始介绍的错误思路的代码</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> w,ma;</span><br><span class="line">	<span class="type">int</span> fa;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; son;</span><br><span class="line">&#125;d[<span class="number">100010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> totw=<span class="number">0</span>,maa=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;d[u].son.<span class="built_in">size</span>();i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> v=d[u].son[i];</span><br><span class="line">		totw+=d[v].w;</span><br><span class="line">		</span><br><span class="line">		d[v].ma=<span class="built_in">dfs</span>(v);</span><br><span class="line">		maa=<span class="built_in">max</span>(maa,d[v].ma);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> temp=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;d[u].son.<span class="built_in">size</span>();i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> v=d[u].son[i];</span><br><span class="line">		temp=<span class="built_in">min</span>(temp,totw-d[v].w+d[v].ma);<span class="comment">//?</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> ans=<span class="built_in">max</span>(maa,d[u].w+totw);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(temp!=<span class="number">1e9</span>+<span class="number">7</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">max</span>(ans,temp);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	<span class="type">int</span> x;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">		d[i+<span class="number">1</span>].fa=x;</span><br><span class="line">		d[x].son.<span class="built_in">push_back</span>(i+<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;d[i].w);</span><br><span class="line">	</span><br><span class="line">	d[<span class="number">1</span>].ma=<span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,d[i].ma);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>正确代码</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> w,ma;</span><br><span class="line">	<span class="type">int</span> fa;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; son;</span><br><span class="line">&#125;d[<span class="number">100010</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">pai</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> w,ma;</span><br><span class="line">&#125;p[<span class="number">100010</span>];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(pai a,pai b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a.w-a.ma&lt;b.w-b.ma;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> totw=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;d[u].son.<span class="built_in">size</span>();i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> v=d[u].son[i];</span><br><span class="line">		totw+=d[v].w;</span><br><span class="line">		</span><br><span class="line">		d[v].ma=<span class="built_in">dfs</span>(v);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;d[u].son.<span class="built_in">size</span>();i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> v=d[u].son[i];</span><br><span class="line">		p[i+<span class="number">1</span>].w=d[v].w;</span><br><span class="line">		p[i+<span class="number">1</span>].ma=d[v].ma;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">sort</span>(p+<span class="number">1</span>,p+d[u].son.<span class="built_in">size</span>()+<span class="number">1</span>,cmp);</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> temp=<span class="number">0</span>,now=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=d[u].son.<span class="built_in">size</span>();i++)</span><br><span class="line">	&#123;</span><br><span class="line">		temp=<span class="built_in">max</span>(temp,now+p[i].ma);</span><br><span class="line">		now+=p[i].w;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">max</span>(d[u].w+totw,temp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	<span class="type">int</span> x;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">		d[i+<span class="number">1</span>].fa=x;</span><br><span class="line">		d[x].son.<span class="built_in">push_back</span>(i+<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;d[i].w);</span><br><span class="line">	</span><br><span class="line">	d[<span class="number">1</span>].ma=<span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,d[i].ma);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>OI 题解</tag>
      </tags>
  </entry>
  <entry>
    <title>一些 C 的问题</title>
    <url>/2024/01/07/%E4%B8%80%E4%BA%9B-C-%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="lib-dll-h"><a href="#lib-dll-h" class="headerlink" title=".lib .dll .h"></a>.lib .dll .h</h1><p>常见的库文件有 <strong>.lib</strong> 和 <strong>.dll</strong> 两种形式，分别是静态库和动态库。</p>
<ul>
<li>静态库在形成 exe 文件时，全部被打包进去。</li>
<li>动态库只是在运行的时候用到的函数才会被导入到 exe 中，可以动态的加载和卸载。</li>
<li>.lib 和 .dll 都是对 .c 或 .cpp 的打包，而打包者需要写 .h 让使用者了解他们是怎么使用的。</li>
</ul>
<h1 id="多文件编译"><a href="#多文件编译" class="headerlink" title="多文件编译"></a>多文件编译</h1><p>只需要引入 .h，所有 .c 都要编译汇编，链接时利用引入的 .h 将编译汇编好的 .o 文件相互链接联系起来。</p>
<p>include 的内容是被直接复制过去的，这样思考 .h 文件的用途时比较容易理解。</p>
<h1 id="VS-Code-C-环境文件"><a href="#VS-Code-C-环境文件" class="headerlink" title="VS Code C 环境文件"></a>VS Code C 环境文件</h1><ul>
<li><strong>settings.json</strong>：总配置文件，如使用 Code Runner 的话要在这里面配置。</li>
<li><strong>c_cpp_properties.json</strong>：C&#x2F;C++ 拓展的配置文件。</li>
<li><strong>tasks.json</strong>：点击运行之后，VS Code 将从 tasks.json 中查看如何构建并运行程序。</li>
<li><strong>launch.json</strong>：用于自定义调试。</li>
</ul>
<h1 id="VS-Code-CMake"><a href="#VS-Code-CMake" class="headerlink" title="VS Code CMake"></a>VS Code CMake</h1><p>C&#x2F;C++ 与 CMake 的关系可以类比 Java 与 Maven 的关系。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>一篇给校友入门OI的建议</title>
    <url>/2022/07/09/%E4%B8%80%E7%AF%87%E7%BB%99%E6%A0%A1%E5%8F%8B%E5%85%A5%E9%97%A8OI%E7%9A%84%E5%BB%BA%E8%AE%AE/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="2f2ff14e65a5df6836ebdde3bdcc66f670f8a327418e3242395d5188b6b3bd78">6fcf1523ddce79b7eefea9a75525b524e0fd3c3a9782a33381886985e8f59e1e83ab1e2a98743bb66dbe9859233fad48f1abee671cf86662777bcb034ddef3d8358422def259c261e75087df117c167904c51242203d7f459e2932cc53190f2b5b5c34fdad84aa90ff7fd8b801f77c8aa92f6adde52b7f9f00dbd4836515c08e653168c5ae63ec1ab0e11bdfee3fd45e1d239d5d77fc00a4d3d6b65be82a1ad596b83b5833e4c3c7d59d3c1c9ada3918778d7fa6f9ef72060f26dc6a04c67589d7f97c1b72b3be15d021f8b9ee42623eb4e9f581756f3023d82f35f899c90375926a5fbf5354cf7495cd7f69e3334120a309a117ddb3e0264638f445de186e56d32053e5cd9110bff8df27c25813e163c4ad2dc8cb7b45ce30a4f52a1e7dbfa67c46a3f75f37f6b61901c861e3ba677383df1046037a97032dc2b2921cdde3335b76e69d4a33540e3250de19a670b0b23f1c2389aad7c9b9b9d153109ff8726eacb71260145c0496899a2099df38733bc64ad57cb35111a01325c2b0438093a4e4d85f66b4d4bf66d2a3404dc8ca9396813c948cda0903be917da2f49fa57671b1eec6886fd9aca767b27977980542bc99d64cb6f34445c0843b22cc7511f35e02bb84e91aa4d3672ad9d21db1d3b2fb2b350340261314ac85d6b5696166d5f03fd19032437f71257cc65db792248076ead8eb191498c7bdcf90ca1fb738c5d71ee775264540f6d472c058447827d2927ca2216b0a3c036fce80d9decde67401165ffb0e164624036fe6d2015ae508f6c71b0c9e71a8da3976b41d9122ae0e03a3de07c1e01990d533cea2010b66d82f2ab24c519fb0beae110abf6673c8cdb7dcf7d80d72d399d4d439440734e40684c1b486bcb5090abd9303d2e13438ef73b0c256c1e9fa768e82177d3ab42012e0910a26b4372564433d45a74ae1107659737900e38fa5f4201935c8179f4aa798cbacefdd2611a9ac8465033a1501f004c684f06575d414966eeeacec89af8b5a8a7d431f1543100f81c4b71438c34bd25af42049961fb8433c828a94d9b7678545d5c698c4e17d0e8515628b4943989322a5d4330d2a398f2a91ec4a64be534e2985fa829b33eec0a59448e5b25380f607e396f1943c4f7bbf4413f520f500de9611899c9bcca6a15afd619b1d273109f0aca7a76e2ffbc05557ce4296009c1c70135aa0e460a40db7ceec5ec82307844e50d200398b8342944d7a034e8d760b2409b07135a8bf058c228573784f05f5979138afa78f50b78a9dbe816e617129eb14552b3b2ba61d89433ad8b97e462f</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>OI 知识</tag>
      </tags>
  </entry>
  <entry>
    <title>一类通过二分进行优化的子串问题</title>
    <url>/2024/05/03/%E4%B8%80%E7%B1%BB%E9%80%9A%E8%BF%87%E4%BA%8C%E5%88%86%E8%BF%9B%E8%A1%8C%E4%BC%98%E5%8C%96%E7%9A%84%E5%AD%90%E4%B8%B2%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>这应该是一类比较有代表性的题吧，特点就是有一个串，然后要用时间复杂度在 $O(n^2)$ 以下的方法统计满足条件的子串数量。此时有一类实现方式是遍历左边界，之后用两次二分确认当前左边界下右边界的两端范围。</p>
<h1 id="字符串问题"><a href="#字符串问题" class="headerlink" title="字符串问题"></a>字符串问题</h1><p>这个题是其他人问我的，没有题目名称也没有评测，所以不保证代码的正确性。</p>
<h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h2><p>给定一个字符串，请你求出有多少个连续子串包含 ‘r’ 和 ‘e’ 字符，但不包含 ‘d’ 字符？</p>
<p><strong>输入描述</strong></p>
<p>一个仅包含小写字母的字符串，长度不超过 $300000$。</p>
<p><strong>输出描述</strong></p>
<p>满足条件的连续子串数量。</p>
<p><strong>示例</strong></p>
<p>输入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">raefadr</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>枚举左边界，从该左边界开始向右遍历，一定存在两个节点，不同时有 ‘r’、’e’ 和同时有 ‘r’、’e’ 的节点，没有 ‘d’ 和有 ‘d’ 的节点。定左边界位置为 $i$，第一个同时有 ‘r’、’e’ 的位置为 $j_1$，最后一个没有有 ‘d’ 的位置为 $j_2$ ，使用前缀和记录字符数量实现 $O(1)$ 的判断，使用二分实现 $O(\log n)$ 的查找，对于每个左边界 $i$，每对找到的右边界将使答案增加 $\max(0, j_2 - j_1 + 1)$。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> len=<span class="number">0</span>;</span><br><span class="line"><span class="type">char</span> s[<span class="number">300010</span>];</span><br><span class="line"><span class="type">int</span> num[<span class="number">3</span>][<span class="number">300010</span>];	<span class="comment">//0r 1e 2d</span></span><br><span class="line"><span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">can1</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> dnu=num[<span class="number">2</span>][y]-num[<span class="number">2</span>][x<span class="number">-1</span>];</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(!dnu) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">can2</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> rnu=num[<span class="number">0</span>][y]-num[<span class="number">0</span>][x<span class="number">-1</span>];</span><br><span class="line">	<span class="type">int</span> enu=num[<span class="number">1</span>][y]-num[<span class="number">1</span>][x<span class="number">-1</span>];</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(rnu&amp;&amp;enu) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s+<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">while</span>(s[len+<span class="number">1</span>]) len++;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=len;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(s[i]==<span class="string">&#x27;r&#x27;</span>) num[<span class="number">0</span>][i]=num[<span class="number">0</span>][i<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> num[<span class="number">0</span>][i]=num[<span class="number">0</span>][i<span class="number">-1</span>];</span><br><span class="line">		<span class="keyword">if</span>(s[i]==<span class="string">&#x27;e&#x27;</span>) num[<span class="number">1</span>][i]=num[<span class="number">1</span>][i<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> num[<span class="number">1</span>][i]=num[<span class="number">1</span>][i<span class="number">-1</span>];</span><br><span class="line">		<span class="keyword">if</span>(s[i]==<span class="string">&#x27;d&#x27;</span>) num[<span class="number">2</span>][i]=num[<span class="number">2</span>][i<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> num[<span class="number">2</span>][i]=num[<span class="number">2</span>][i<span class="number">-1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=len;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> j1=<span class="number">0</span>,j2=<span class="number">0</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="type">int</span> le=i,ri=len;</span><br><span class="line">		<span class="keyword">while</span>(le&lt;=ri)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> mid=(le+ri)/<span class="number">2</span>;</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">can1</span>(i,mid))</span><br><span class="line">			&#123;</span><br><span class="line">				j2=mid;</span><br><span class="line">				le=mid+<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> ri=mid<span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		le=i,ri=len;</span><br><span class="line">		<span class="keyword">while</span>(le&lt;=ri)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> mid=(le+ri)/<span class="number">2</span>;</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">can2</span>(i,mid))</span><br><span class="line">			&#123;</span><br><span class="line">				j1=mid;</span><br><span class="line">				ri=mid<span class="number">-1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> le=mid+<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(j1&amp;&amp;j2) ans+=<span class="built_in">max</span>(<span class="number">0</span>,j2-j1+<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="小白玩游戏"><a href="#小白玩游戏" class="headerlink" title="小白玩游戏"></a>小白玩游戏</h1><p><strong>题目传送门：<a href="https://ac.nowcoder.com/acm/contest/80793/E">E-小白玩游戏</a></strong></p>
<h2 id="题面-1"><a href="#题面-1" class="headerlink" title="题面"></a>题面</h2><p>小白正在基地训练，忽然看到谷雨学姐在 $qq$ 群里说大礼堂可以玩游戏挣奖品，小白立马冲到大礼堂，首先去做的当然是看问题写代码的游戏了，这对小白来说很简单。他很顺利的拿到了奖品。他还想玩些其他游戏。但是由于他还要给校赛出题，不能玩的太久。所以他决定再玩两次游戏就回基地去出题。现场有很多游戏，每个游戏玩完需要一定的时间。小白到一定的时间一定要回基地，但是小白也不想还没玩就回去。所以小白想在玩了 $[L, R]$ 分钟后回基地，小白想知道在这段时间里。自己玩两次游戏的话有多少种选择的方案。小白刚才刚写完代码已经不想动脑了。现在请聪明的你帮他解决一下这个问题。</p>
<p> 给定 $n$ 个游戏以及玩每个游戏所需要的时间 $a_i$。在玩游戏的时长控制在内，求 $[L, R]$ 小白<strong>玩两次游戏</strong>有多少种选择的方案。<strong>特别的，小白不能选择同一个游戏玩两次</strong>。</p>
<p><strong>输入描述</strong></p>
<p>第一行输入一个整数 $n,L,R(1 \leq n \leq 2 \times 10^5,1 \leq L \leq R \leq 10^9)$，表示游戏的个数。</p>
<p>接下来一行输入 $n$ 个整数 $a_1,a_2,…,a_n(1 \leq a_i \leq 10^9)$ ，表示玩第 $i$ 个游戏需要 $a_i$ 分钟。</p>
<p><strong>输出描述</strong></p>
<p>输出一个整数，表示有多少种方案可供小白选择。                    </p>
<p><strong>示例</strong></p>
<p>输入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 10 15</span><br><span class="line">5 4 8 9 6</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8</span><br></pre></td></tr></table></figure>

<p><strong>说明</strong></p>
<p>可供选择的方案有以下 $8$ 种：</p>
<p>$(1,3),(1,4),(1,5),(2,3),(2,4),(2,5),(3,5),(4,5)$。</p>
<h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>把游戏按时间排序，依次遍历第一个游戏 $i$，此时剩下时间 $[L- a_i， R - a_i]$ 用二分找最小的大于等于 $L- a_i$ 的游戏位置 $j_1$，最大的小于等于 $R - a_i$ 的游戏位置 $j_2$，对于每个游戏 $i$，每对找到的第二个游戏的边界将使答案增加 $\max(0, j_2 - j_1 + 1)$，同时注意找到的第二个游戏区间内可能包含第一个游戏，此时由于两个游戏不能重复需要 $- 1$。最后由于答案的两个游戏是无序的，所以要除以 $2$。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,L,R;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">game</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> id,a;</span><br><span class="line">&#125;g[<span class="number">200010</span>];</span><br><span class="line">ll ans=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(game x,game y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x.a&lt;y.a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;L,&amp;R);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;g[i].a);</span><br><span class="line">		g[i].id=i;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">sort</span>(g+<span class="number">1</span>,g+n+<span class="number">1</span>,cmp);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> nowl=L-g[i].a,nowr=R-g[i].a;</span><br><span class="line">		<span class="type">int</span> le=<span class="number">1</span>,ri=n;</span><br><span class="line">		<span class="type">int</span> ans1=<span class="number">0</span>,ans2=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(le&lt;=ri)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> mid=(le+ri)/<span class="number">2</span>;</span><br><span class="line">			<span class="keyword">if</span>(g[mid].a&gt;=nowl)</span><br><span class="line">			&#123;</span><br><span class="line">				ans1=mid;</span><br><span class="line">				ri=mid<span class="number">-1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> le=mid+<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		le=<span class="number">1</span>,ri=n;</span><br><span class="line">		<span class="keyword">while</span>(le&lt;=ri)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> mid=(le+ri)/<span class="number">2</span>;</span><br><span class="line">			<span class="keyword">if</span>(g[mid].a&lt;=nowr)</span><br><span class="line">			&#123;</span><br><span class="line">				ans2=mid;</span><br><span class="line">				le=mid+<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> ri=mid<span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(ans1&lt;=ans2)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(i&lt;ans1||i&gt;ans2) ans+=(ans2-ans1+<span class="number">1</span>);</span><br><span class="line">			<span class="keyword">else</span> ans+=(ans2-ans1);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,ans/<span class="number">2</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>OI 知识</tag>
      </tags>
  </entry>
  <entry>
    <title>主成分分析法（待完善）</title>
    <url>/2022/05/22/%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90%E6%B3%95/</url>
    <content><![CDATA[<p>下次一定会写的！</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>数学建模竞赛</tag>
      </tags>
  </entry>
  <entry>
    <title>二分的自锁问题等细节问题</title>
    <url>/2024/04/08/%E4%BA%8C%E5%88%86%E7%9A%84%E8%87%AA%E9%94%81%E9%97%AE%E9%A2%98%E7%AD%89%E7%BB%86%E8%8A%82%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>在 21 年的时候我曾经写过一篇有关二分自锁问题的博客：<a href="https://www.cnblogs.com/CYHeimu/p/15319100.html">二分法及其边界问题、自锁问题</a>，现在回看感觉其中的理解有所欠缺，于是结合再次阅读<a href="https://zhuanlan.zhihu.com/p/40579713">【洛谷日报#13】浅谈二分的边界问题</a>得到的理解写了这一篇应该算是最终版的总结。</p>
<h1 id="二分写法"><a href="#二分写法" class="headerlink" title="二分写法"></a>二分写法</h1><p>首先依旧放上曾经一位大犇说的话：看到求最大的最小或是最小的最大，那么就大概率是二分答案。</p>
<p>以下代码均对问题做出如下假设：整个待判断数组是单调递增的，我们想要找到满足比特定值大的最小的值。</p>
<h2 id="答案记录法"><a href="#答案记录法" class="headerlink" title="答案记录法"></a>答案记录法</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> ans;</span><br><span class="line"><span class="type">int</span> l=<span class="number">1</span>,r=n;</span><br><span class="line"><span class="keyword">while</span>(l&lt;=r)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">check</span>(mid))</span><br><span class="line">    &#123;</span><br><span class="line">        ans=mid;</span><br><span class="line">        r=mid<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans);</span><br></pre></td></tr></table></figure>

<p>答案记录法有如下几个特点：</p>
<ol>
<li>循环终止条件为 <code>l&lt;=r</code>，这保证了循环能够检查到最短长度为 $1$ 的区间并再收缩 $1$ 次。</li>
<li>如果 <code>check(mid)</code> 成立，则记录当前值到 <code>ans</code> 中，最后 <code>ans</code> 中的值为答案。</li>
<li>左边界的收缩方式为 <code>l=mid+1</code>，既然判断 <code>mid</code> 不满足条件，则直接将左边界移到 <code>mid</code> 后。</li>
<li>右边界的收缩方式为 <code>r=mid-1</code>，虽然 <code>mid</code> 满足条件，但由于已经将其记录进了 <code>ans</code>，则直接将右边界移到 <code>mid</code> 前。</li>
<li><strong>左右边界的收缩方式一定是 <code>l=mid+1</code>、<code>r=mid-1</code>。</strong></li>
</ol>
<h2 id="边界重合法"><a href="#边界重合法" class="headerlink" title="边界重合法"></a>边界重合法</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> l=<span class="number">1</span>,r=n;</span><br><span class="line"><span class="keyword">while</span>(l&lt;r)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">check</span>(mid)) r=mid;</span><br><span class="line">    <span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,l);</span><br></pre></td></tr></table></figure>

<p>边界重合法有如下几个特点：</p>
<ol>
<li>循环终止条件为 <code>l&lt;r</code>，这保证了循环能够检查到最短长度为 $2$ 的区间并再收缩 $1$ 次。</li>
<li>最后左右边界重合， <code>l</code> 和 <code>r</code> 中的值均为答案。</li>
<li>左边界的收缩方式为 <code>l=mid+1</code>，既然判断 <code>mid</code> 不满足条件，则直接将左边界移到 <code>mid</code> 后。</li>
<li>右边界的收缩方式为 <code>r=mid</code>，由于 <code>mid</code> 满足条件，则直接将右边界移到 <code>mid</code> 处。</li>
<li><strong>左右边界的收缩方式一定是 <code>l=mid+1</code>、<code>r=mid</code> 或 <code>l=mid</code>、<code>r=mid-1</code>。</strong></li>
</ol>
<h1 id="难以确定的细节问题"><a href="#难以确定的细节问题" class="headerlink" title="难以确定的细节问题"></a>难以确定的细节问题</h1><h2 id="边界收缩方式确定"><a href="#边界收缩方式确定" class="headerlink" title="边界收缩方式确定"></a>边界收缩方式确定</h2><p>答案记录法永远是 <code>l=mid+1</code>、<code>r=mid-1</code>。</p>
<p>边界重合法需要结合题目具体确定。由于最后答案要被囊括在区间中，因此 <strong><code>check(mid)==true</code> 时一定跟随 <code>r=mid</code> 或 <code>l=mid</code><strong>。如整个待判断数组是单调递增的，我们想要找到</strong>满足比特定值大的最小的值</strong>时，则需要使用 <code>l=mid+1</code>、<code>r=mid</code> 组合；当整个待判断数组是单调递增的，我们想要找到<strong>满足比特定值小的的最大的值</strong>时，则需要使用 <code>l=mid</code>、<code>r=mid-1</code> 组合。</p>
<h2 id="自锁问题"><a href="#自锁问题" class="headerlink" title="自锁问题"></a>自锁问题</h2><p>二分自锁是一种在写二分程序时边界永远卡在相邻的两位导致程序无法终止的情况，<strong>只有在使用边界重合法的写法时会出现自锁问题。</strong>考虑程序进行到区间长度为 $2$，即 $l &#x3D; r - 1$ 的情况：</p>
<ul>
<li>设 <code>mid</code> 的计算方式为 <code>mid=(l+r)/2</code>，此时计算得出 <code>mid</code> 一定等于 <code>l</code>，即 <code>mid</code> 一定偏左。若此时你的左边界收缩策略为 <code>l=mid</code>，则可能会出现自锁情况，即在最后长度为 $2$ 的区间 <code>check(mid)</code> 时反复执行 <code>l=mid</code> 而导致边界不收缩。</li>
<li>设 <code>mid</code> 的计算方式为 <code>mid=(l+r+1)/2</code>，此时计算得出 <code>mid</code> 一定等于 <code>r</code>，即 <code>mid</code> 一定偏右。若此时你的右边界收缩策略为 <code>r=mid</code>，则可能会出现自锁情况，即在最后长度为 $2$ 的区间 <code>check(mid)</code> 时反复执行 <code>r=mid</code> 而导致边界不收缩。</li>
</ul>
<p>因此解决方法就是<strong>永远让 <code>mid=(l+r)/2</code> 与 <code>l=mid+1</code>、<code>r=mid</code> 绑定， <code>mid=(l+r+1)/2</code> 与 <code>l=mid</code>、<code>r=mid-1</code> 绑定</strong>。</p>
<h2 id="开闭区间问题"><a href="#开闭区间问题" class="headerlink" title="开闭区间问题"></a>开闭区间问题</h2><p>设初始的左右边界 $l&#x3D;a, r&#x3D;b$，开闭区间问题即我想知道最终可能遍历到的所有位置是否包括 $a$ 和 $b$。决定开闭区间的因素就是上述 <code>mid</code> 的计算方式与循环终止方式之间的排列组合。</p>
<p>当 <code>mid=(l+r)/2</code> 时，<code>mid</code> 偏左，因此数组第一位一定能走到，则左闭。考虑答案为数组最后一位时的极限情况：</p>
<ul>
<li>若 <code>l&lt;=r</code> 时循环终止，循环在最后执行完 <code>l=mid+1</code> 后依然能够判断最后一位 $b$，则右闭，总情况为 $[l, r]$。</li>
<li>若 <code>l&lt;r</code> 时循环终止，循环在最后执行完 <code>l=mid+1</code> 后终止，不能判断最后一位 $b$，则右开，总情况为 $[l, r)$。</li>
</ul>
<p>当 <code>mid=(l+r+1)/2</code> 时，<code>mid</code> 偏右，因此数组最后一位一定能走到，则右区间闭。考虑答案为数组第一位时的极限情况：</p>
<ul>
<li>若 <code>l&lt;=r</code> 时循环终止，循环在最后执行完 <code>r=mid-1</code> 后依然能够判断第一位 $a$，则左闭，总情况为 $[l, r]$。</li>
<li>若 <code>l&lt;r</code> 时循环终止，循环在最后执行完 <code>r=mid-1</code> 后终止，不能判断第一位 $a$，则左开，总情况为 $(l, r]$。</li>
</ul>
<h2 id="初值问题"><a href="#初值问题" class="headerlink" title="初值问题"></a>初值问题</h2><p>初值问题即如何设定左右边界的初值。了解了不同的写法所对应的开闭区间的情况后，就可以再结合题意设定合适的初值了。设答案必定存在在区间 $[a, b]$ 中，若使用左闭右闭的写法，则初值可以设置为 <code>l=a,r=b</code>；若使用左闭右开的写法，则初值可以设置为 <code>l=a,r=b+1</code>，以此类推。若答案只是可能存在在区间 $[a, b]$ 中，有可能发生无解的情况，则可以将设定的边界范围向外扩充 $1$ 格用来承载无解的情况（不要忘记给扩充的位置赋初值）。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>OI 知识</tag>
      </tags>
  </entry>
  <entry>
    <title>什么是梯度下降</title>
    <url>/2022/08/07/%E4%BB%80%E4%B9%88%E6%98%AF%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D/</url>
    <content><![CDATA[<p>在深度学习中会有梯度下降的应用，它被用来得到最小化的损失函数值和模型参数。暂时不去理那些专有名词，说简单一些：梯度下降就是一种找函数最小值的算法。</p>
<ul>
<li>第一种理解：梯度下降就像是在函数图像上放了一个球，因为重力影响，最终球会滚到最低处，也便找到了函数最小值。</li>
</ul>
<p><img src="/2022/08/07/%E4%BB%80%E4%B9%88%E6%98%AF%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D/2.gif" alt="img"></p>
<ul>
<li>第二种理解：方便理解可以把“梯度”理解为“导数”，“下降”理解为“逼近0”，因此一种意会的理解为梯度下降就是在找让一个函数的导数逼近0的变量值。</li>
</ul>
<h1 id="主流程"><a href="#主流程" class="headerlink" title="主流程"></a>主流程</h1><p>假设我们有一个简单的函数$f(x) &#x3D; x^2$，我们想知道使$f(x)$最小的值$x_{min}$，开始的位置为$x_0 &#x3D; 10$。图长这样：</p>
<p><img src="/2022/08/07/%E4%BB%80%E4%B9%88%E6%98%AF%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D/1.jpg" alt="img"></p>
<p>求梯度：</p>
<p>$$<br>\nabla f(x_0) &#x3D; f’(x_0) i &#x3D; (f’(x_0)) &#x3D; (2x |_{x_0 &#x3D; 10}) &#x3D; (20)<br>$$</p>
<p>这是在$x$轴上的向量，它指向函数值增长最快的方向，而$- \nabla f(x_0)$就指向减少最快的方向：</p>
<p><img src="/2022/08/07/%E4%BB%80%E4%B9%88%E6%98%AF%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D/2.jpg" alt="img"></p>
<p>定义一种运算计算$x_1$。将$x_0$看作一维向量$(x_0)$，和$- \nabla f(x_0)$进行运算：</p>
<p>$$<br>(x_1) &#x3D; (x_0) - \eta \nabla f(x_0)<br>$$</p>
<p>其中$\eta$称为<strong>步长</strong>，通过它可以控制移的动距离，我们设$\eta &#x3D; 0.2$，那么：</p>
<p>$$<br>(x_1) &#x3D; (x_0) - \eta \nabla f(x_0) &#x3D; (6)<br>$$</p>
<p>理解为原$x_0$的位置受梯度作为参数向左移动了一段距离，从而逼近了函数最低点。此时便下降到了$x_1 &#x3D; 6$的位置：</p>
<p><img src="/2022/08/07/%E4%BB%80%E4%B9%88%E6%98%AF%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D/3.jpg" alt="img"></p>
<p>后续的操作便是重复求梯度，利用梯度移动，直到逼近最低点：</p>
<p><img src="/2022/08/07/%E4%BB%80%E4%B9%88%E6%98%AF%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D/1.gif" alt="img"></p>
<p>选取$\eta &#x3D; 0.2$时，重复了10次便比较接近了最小值，这就是全过程了。</p>
<h1 id="问题解释"><a href="#问题解释" class="headerlink" title="问题解释"></a>问题解释</h1><p><strong>为什么叫梯度下降算法</strong></p>
<p>把每一次的梯度向量$\nabla f$的模长$|| \nabla f ||$列出来，可以看到是在不断减小的，因此这种方法称为梯度下降法。</p>
<p><img src="/2022/08/07/%E4%BB%80%E4%B9%88%E6%98%AF%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D/1.png" alt="img"></p>
<p><strong>步长的选取</strong></p>
<p>步长可以控制每次移动的距离，它的值的设置要依靠经验。过小时，很难达到谷底；过大时，容易在谷底的两端反复横跳，但下不去。</p>
<p><strong>高维的情况</strong></p>
<p>步骤是完全相同的。</p>
<p><strong>损失函数</strong></p>
<p>在深度学习里，损失函数的值代表了预测值与实际值间的误差，因此它越小越代表模型效果越好。我们要使用梯度下降求最小值的函数正是损失函数，便正是其被用来得到最小化的损失函数值和模型参数。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.zhihu.com/question/305638940">https://www.zhihu.com/question/305638940</a></p>
<p><a href="https://blog.csdn.net/wyf2017/article/details/109278430">https://blog.csdn.net/wyf2017/article/details/109278430</a></p>
<p><a href="https://baike.baidu.com/item/%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D/4864937?fr=aladdin">https://baike.baidu.com/item/%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D/4864937?fr=aladdin</a></p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>全排列</title>
    <url>/2023/05/01/%E5%85%A8%E6%8E%92%E5%88%97/</url>
    <content><![CDATA[<h1 id="基于交换的全排列"><a href="#基于交换的全排列" class="headerlink" title="基于交换的全排列"></a>基于交换的全排列</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n=<span class="number">4</span>,a[<span class="number">5</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pl</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x==n)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,a[i]);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=x;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">swap</span>(a[x],a[i]);</span><br><span class="line">		<span class="built_in">pl</span>(x+<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">swap</span>(a[x],a[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="基于-DFS-的全排列"><a href="#基于-DFS-的全排列" class="headerlink" title="基于 DFS 的全排列"></a>基于 DFS 的全排列</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n=<span class="number">4</span>,a[<span class="number">5</span>],used[<span class="number">5</span>]=&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pl</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x&gt;n)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,a[i]);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(used[i]) <span class="keyword">continue</span>;</span><br><span class="line">		a[x]=i;</span><br><span class="line">		used[i]=<span class="number">1</span>;</span><br><span class="line">		<span class="built_in">pl</span>(x+<span class="number">1</span>);</span><br><span class="line">		used[i]=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>OI 知识</tag>
      </tags>
  </entry>
  <entry>
    <title>六一</title>
    <url>/2022/06/01/%E5%85%AD%E4%B8%80/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="bc9529c70b0d5267274fefe4a594d86f1b715ae8e00ec4ff299c75f3e8e194ae">6fcf1523ddce79b7eefea9a75525b52452403c6618583fc3a88b1313632aafdce514474ed6215c69b06af73308678092e51abcf693506ee235725415117b5b01d68d950140903b06580f766a05da922f62e2fecafdc4d29bdee577597d4cea092a17340a0f8e1ead464f01033197e7d635353d741e3bd91b9f1c724f5717ad5602de6dbfe6bbf7f198dcaff10f2480b28764a835754e44ec857dd98e05be1ca21f9e606617592e50c512c080435fedb5b5b70d2c6b5485dbc76a62105f5763a83d14d33a8cf713a430252c2877417d38394cfea608c8eb58d9cab690d5a9897822851196095a2044ec90454221955c37a8b45d25a9cf6e1afeb4659ef0a8cb213f26eaffe0eabc1dadba76b3bb095525ac04b76b1c937d4606a779c1205976023ddd9eaf57b2c6a8ef5d15a88125a17c5c91a82b84d3cf2e4243ba51e673ba736cfd813a9cba15db2a6a94f9c926ed2111b675cca57d4198a0c900c7e17aa182e46eef82c60702eeffd3015848b51b49788f2cf032fd85829ffe0eec5c50160110a70e9886d61566d045f944d0ea1066ca6284ffaae8f70d483452359849a825745f60b0b5ac19055cb541965449b249fe2779855d415fe3413e73190a5fe4eee4eae5ecd48298f3ee3085819ccecba75aeb469820f92620981c31359bd069d438107da11b8a1608b8d3b2e149cfd2f2bc2e5584da804c359dc18b7d7406128d95de74314b34a656104714bfb4b4f19aeb6912e08eab057104856b2c131246690a5ac59946d7140cb1d061309763feed0074449a908acca957c51c4ff312dbcd94e75e339b9378040105f74dcc580821952ff5c8dbfb60def2ecd9c0a99927b1</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>日常</category>
      </categories>
  </entry>
  <entry>
    <title>前缀和与前缀和的和公式</title>
    <url>/2024/03/29/%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%89%8D%E7%BC%80%E5%92%8C%E7%9A%84%E5%92%8C%E5%85%AC%E5%BC%8F/</url>
    <content><![CDATA[<p>$1 + 2 + \dots + i$ 的求和公式：</p>
<p>$$<br>\begin{aligned}<br>  &amp; 1 + 2 + \dots + i \\<br>&#x3D; &amp; {1 + 2 + \dots + i + 1 + 2 + \dots + i \over 2} \\<br>&#x3D; &amp; {(1 + i) + (2 + i - 1) + \dots + (i + 1) \over 2} \\<br>&#x3D; &amp; {i \times (i + 1) \over 2} \\<br>\end{aligned}<br>$$</p>
<p>$1 + (1 + 2) + \dots + (1 + 2 + \dots + i)$ 的求和公式：</p>
<p>$$<br>\begin{aligned}<br>  &amp; 1 + (1 + 2) + \dots + (1 + 2 + \dots + i) \\<br>&#x3D; &amp; {1 \times 2 \over 2} + {2 \times 3 \over 2} + \dots + {i \times (i + 1) \over 2} \\<br>&#x3D; &amp; {1 \over 2} (1 \times 2 + 2 \times 3 + \dots + i \times (i + 1)) \\<br>&#x3D; &amp; {1 \over 6} (1 \times 2 \times 3 + 2 \times 3 \times (4 - 1) + \dots + i \times (i + 1) \times ((i + 2) - (i - 1))) \\<br> &#x3D; &amp; {1 \over 6} (1 \times 2 \times 3 - 1 \times 2 \times 3 + 2 \times 3 \times 4 - \dots - (i - 1) \times i \times (i + 1) + i \times (i + 1) \times (i + 2)) \\<br>&#x3D; &amp; {i \times (i + 1) \times (i + 2) \over 6} \\<br>\end{aligned}<br>$$</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>OI 知识</tag>
      </tags>
  </entry>
  <entry>
    <title>包裹浮动元素</title>
    <url>/2022/06/02/%E5%8C%85%E8%A3%B9%E6%B5%AE%E5%8A%A8%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<p>当一个 div 的子元素为浮动元素时，这个 div 是不能将其子元素包裹住的。具体情况如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;wrapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span>a<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span>b<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span>c<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.wrapper</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">2px</span> solid black;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.box</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* float: left; */</span></span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: green;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时的效果：</p>
<p><img src="/2022/06/02/%E5%8C%85%E8%A3%B9%E6%B5%AE%E5%8A%A8%E5%85%83%E7%B4%A0/1.png" alt="img"></p>
<p>在将 float 取消注释后，效果如下：</p>
<p><img src="/2022/06/02/%E5%8C%85%E8%A3%B9%E6%B5%AE%E5%8A%A8%E5%85%83%E7%B4%A0/2.png" alt="img"></p>
<p>可见 div 并不能很好的包裹浮动元素，原因在于块级元素看不到浮动元素。</p>
<p>利用产生 bfc 的解决方法如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.wrapper</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>既然浮动元素有 bfc ，只有 bfc 才能看到 bfc ，那我们也给外层一个 bfc 就好了。（但这种方法也会带来属性相应的我们可能不希望的变化）</p>
<p>利用伪元素的解决方法：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.wrapper</span><span class="selector-pseudo">::after</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;    <span class="comment">/*伪元素content属性必须写上*/</span></span><br><span class="line">    <span class="attribute">display</span>: block; <span class="comment">/*块级元素才能使用clear*/</span></span><br><span class="line">    <span class="attribute">clear</span>: both;    <span class="comment">/*伪元素左右两边都不允许有浮动元素，于是乎就贴到最下面了*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>添加之后，就可以有我们想要的效果了：</p>
<p><img src="/2022/06/02/%E5%8C%85%E8%A3%B9%E6%B5%AE%E5%8A%A8%E5%85%83%E7%B4%A0/3.png" alt="img"></p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>知识备忘</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>协方差与相关系数</title>
    <url>/2022/05/18/%E5%8D%8F%E6%96%B9%E5%B7%AE%E4%B8%8E%E7%9B%B8%E5%85%B3%E7%B3%BB%E6%95%B0/</url>
    <content><![CDATA[<p><strong>协方差</strong>（Covariance）在概率论和统计学中用于衡量两个变量的总体误差。方差是协方差两个变量相同的一种特殊情况。如果两个变量变化趋势一致，协方差为正值，反之为负值。协方差为 0 的两个随机变量被称为是不相关的。</p>
<p>协方差作为描述 X 和 Y 相关程度的量，在同一物理量纲之下有一定的作用，但同样的两个量采用不同的量纲使它们的协方差在数值上表现出很大的差异。为此引入<strong>相关系数</strong>（Correlation coefficient）研究变量间线性相关的程度。</p>
<h1 id="计算与性质"><a href="#计算与性质" class="headerlink" title="计算与性质"></a>计算与性质</h1><p><strong>协方差：</strong></p>
<p>$$<br>\begin{aligned}<br>    Cov(X, Y)<br>    &amp; &#x3D; E[(X - E[X])(Y - E[Y])] \\<br>    &amp; &#x3D; E[XY] - 2 E[Y]E[X] + E[X]E[Y] \\<br>    &amp; &#x3D; E[XY] - E[X]E[Y] \\<br> \end{aligned}<br>$$</p>
<p><strong>相关系数：</strong></p>
<p>$$<br>\rho_{X, Y} &#x3D; {Cov(X, Y) \over \sqrt{D(X)} \sqrt{D(Y)}}<br>$$</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>数学建模竞赛</tag>
      </tags>
  </entry>
  <entry>
    <title>博客分类总则</title>
    <url>/2023/03/24/%E5%8D%9A%E5%AE%A2%E5%88%86%E7%B1%BB%E6%80%BB%E5%88%99/</url>
    <content><![CDATA[<h1 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h1><ul>
<li>十字路口：一些记录博客的总览文档</li>
<li>日常：写日记的地方</li>
<li>OI题解：算法比赛专门放题解的地方</li>
<li>环境项目：完全与环境项目相关的内容</li>
<li>知识备忘录：记录基本且通用的知识</li>
<li>算法竞赛学习笔记：用来分开放置算法比赛知识点笔记</li>
<li>数学建模学习笔记：用来分开放置数学建模知识点笔记</li>
<li>游戏开发学习笔记：用来分开放置游戏开发知识点笔记</li>
<li>人工智能学习笔记：用来分开放置人工智能知识点笔记</li>
</ul>
<h1 id="一些具体解释"><a href="#一些具体解释" class="headerlink" title="一些具体解释"></a>一些具体解释</h1><p>学习笔记的侧重是<strong>学习本领域的专业知识</strong>。</p>
<p>知识备忘录一般存储暂时不能分类知识与通用知识。<strong>其中通用是指会在多个领域涉及到的知识。</strong></p>
<ol>
<li><strong>当一门有些通用的知识只与某领域相关时，不应记录在备忘录，而记录在此领域中。</strong>如人工智能的pytorch相关问题应自己保存，因为即使python知识是通用的，但pytorch只与人工智能相关（我是使用的python和pytorch区分开的原则，也就是库与语言本身当作不同知识来对待）。</li>
<li><strong>在面对同一通用知识在面对不同领域会有不同侧重时不需要合并在知识备忘录，但需要在出现这种情况时在备忘录进行简短的记录。</strong>如在面对如FFT的离散形式和连续形式两种变种的情况时离散形式可以单独放在算法竞赛内；同理算法竞赛涉及到STL时应记录在算法比赛内，因为其对于完整的STL知识来说可能不全且有自己的侧重。</li>
<li><strong>当一门通用知识同时会在我的多个学习领域出现且没有侧重时，应当转移到知识备忘录，之后在两领域分别调用。</strong>如对于我的世界linux服务器搭建来说，linux基本操作应该放入备忘录。</li>
</ol>
]]></content>
      <categories>
        <category>规则</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>博客美化指南</title>
    <url>/2022/05/15/%E5%8D%9A%E5%AE%A2%E7%BE%8E%E5%8C%96%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<h1 id="自定义外观"><a href="#自定义外观" class="headerlink" title="自定义外观"></a>自定义外观</h1><p>打开 next 主题配置文件，进行以下配置：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">custom_file_path:</span></span><br><span class="line">  <span class="attr">style:</span> <span class="string">source/_data/styles.styl</span></span><br></pre></td></tr></table></figure>

<p>打开根目录下的 source 文件夹，创建文件_data&#x2F;styles.styl。后大部分CSS样式都可在这里面自定义。</p>
<h2 id="添加背景图片"><a href="#添加背景图片" class="headerlink" title="添加背景图片"></a>添加背景图片</h2><p>在 styles.styl 中添加：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 添加背景图片</span></span><br><span class="line"><span class="selector-tag">body</span></span><br><span class="line">&#123;</span><br><span class="line">      <span class="attribute">background</span>: url(../images/background/background3.jpg);	<span class="comment">//本路径是主题文件夹内的images</span></span><br><span class="line">      <span class="attribute">background-size</span>: cover;</span><br><span class="line">      <span class="attribute">background-repeat</span>: no-repeat;</span><br><span class="line">      <span class="attribute">background-attachment</span>: fixed;</span><br><span class="line">      <span class="attribute">background-position</span>: <span class="number">50%</span> <span class="number">50%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="更改站板背景颜色"><a href="#更改站板背景颜色" class="headerlink" title="更改站板背景颜色"></a>更改站板背景颜色</h2><p>在 styles.styl 中添加：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.site-brand-container</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attribute">background</span> <span class="built_in">rgb</span>(<span class="number">70</span>, <span class="number">81</span>, <span class="number">120</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="修改meta与正文间间距"><a href="#修改meta与正文间间距" class="headerlink" title="修改meta与正文间间距"></a>修改meta与正文间间距</h2><p><img src="/2022/05/15/%E5%8D%9A%E5%AE%A2%E7%BE%8E%E5%8C%96%E6%8C%87%E5%8D%97/1.png" alt="img"></p>
<p>在 styles.styl 中添加：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="comment">//修改meta与正文间间距</span></span><br><span class="line"><span class="selector-class">.posts-expand</span> <span class="selector-class">.post-meta</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">3px</span> <span class="number">0</span> <span class="number">35px</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="为post块上方留白"><a href="#为post块上方留白" class="headerlink" title="为post块上方留白"></a>为post块上方留白</h2><p><img src="/2022/05/15/%E5%8D%9A%E5%AE%A2%E7%BE%8E%E5%8C%96%E6%8C%87%E5%8D%97/2.png" alt="img"></p>
<p>在 styles.styl 中添加：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.post-block</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="添加透明度"><a href="#添加透明度" class="headerlink" title="添加透明度"></a>添加透明度</h2><p>在 styles.styl 中添加：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="comment">//文章内容的透明度设置</span></span><br><span class="line"><span class="selector-class">.content-wrap</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0.95</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//侧边框的透明度设置</span></span><br><span class="line"><span class="selector-class">.sidebar</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: transparent;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0.95</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//菜单栏的透明度设置</span></span><br><span class="line"><span class="selector-class">.header-inner</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: rgba(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>,<span class="number">0.95</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="字体修改"><a href="#字体修改" class="headerlink" title="字体修改"></a>字体修改</h2><p>第一种简易的方法是在主题配置文件中进行修改，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Font Settings</span></span><br><span class="line"><span class="comment"># See: https://theme-next.org/docs/theme-settings/#Fonts-Customization</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Find fonts on Google Fonts (https://www.google.com/fonts)</span></span><br><span class="line"><span class="comment"># All fonts set here will have the following styles:</span></span><br><span class="line"><span class="comment">#   light | light italic | normal | normal italic | bold | bold italic</span></span><br><span class="line"><span class="comment"># Be aware that setting too much fonts will cause site running slowly</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># To avoid space between header and sidebar in scheme Pisces / Gemini, Web Safe fonts are recommended for `global` (and `title`):</span></span><br><span class="line"><span class="comment"># Arial | Tahoma | Helvetica | Times New Roman | Courier New | Verdana | Georgia | Palatino | Garamond | Comic Sans MS | Trebuchet MS</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="attr">font:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Uri of fonts host, e.g. https://fonts.googleapis.com (Default).</span></span><br><span class="line">  <span class="attr">host:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Font options:</span></span><br><span class="line">  <span class="comment"># `external: true` will load this font family from `host` above.</span></span><br><span class="line">  <span class="comment"># `family: Times New Roman`. Without any quotes.</span></span><br><span class="line">  <span class="comment"># `size: x.x`. Use `em` as unit. Default: 1 (16px)</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Global font settings used for all elements inside &lt;body&gt;.</span></span><br><span class="line">  <span class="attr">global:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">family:</span> <span class="string">Lato</span></span><br><span class="line">    <span class="attr">size:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Font settings for site title (.site-title).</span></span><br><span class="line">  <span class="attr">title:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">family:</span></span><br><span class="line">    <span class="attr">size:</span> <span class="number">1.5</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Font settings for headlines (&lt;h1&gt; to &lt;h6&gt;).</span></span><br><span class="line">  <span class="attr">headings:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">family:</span></span><br><span class="line">    <span class="attr">size:</span> <span class="number">1.5</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Font settings for posts (.post-body).</span></span><br><span class="line">  <span class="attr">posts:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">family:</span> <span class="string">微软雅黑</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Font settings for &lt;code&gt; and code blocks.</span></span><br><span class="line">  <span class="attr">codes:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">family:</span></span><br></pre></td></tr></table></figure>

<p>但有时利用这些还达不到我们想要的效果。因此可以去翻找源码进行更为细致的修改。位置为themes&#x2F;next&#x2F;source&#x2F;css&#x2F;_variables&#x2F;base.styl，在其中修改如下段落：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Font size</span></span><br><span class="line"><span class="variable">$font-size-smallest</span>       = <span class="selector-class">.85em</span>;</span><br><span class="line"><span class="variable">$font-size-smaller</span>        = <span class="selector-class">.875em</span>;</span><br><span class="line"><span class="variable">$font-size-small</span>          = <span class="selector-class">.875em</span>;</span><br><span class="line"><span class="variable">$font-size-medium</span>         = <span class="number">1em</span>;</span><br><span class="line"><span class="variable">$font-size-large</span>          = <span class="number">1em</span>;</span><br><span class="line"><span class="variable">$font-size-larger</span>         = <span class="number">1.25em</span>;</span><br><span class="line"><span class="variable">$font-size-largest</span>        = <span class="number">1.5em</span>;</span><br></pre></td></tr></table></figure>

<p>自己实验着修改就好。</p>
<h2 id="边框圆角"><a href="#边框圆角" class="headerlink" title="边框圆角"></a>边框圆角</h2><p>主题配置文件进行如下配置：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">custom_file_path:</span></span><br><span class="line">  <span class="attr">variable:</span> <span class="string">source/_data/variables.styl</span></span><br></pre></td></tr></table></figure>

<p>在 _data 文件夹下添加 variables.styl 文件，添加如下内容：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 圆角设置</span></span><br><span class="line"><span class="variable">$border-radius-inner</span>     = <span class="number">20px</span> <span class="number">20px</span> <span class="number">20px</span> <span class="number">20px</span>;</span><br><span class="line"><span class="variable">$border-radius</span>           = <span class="number">20px</span>;</span><br></pre></td></tr></table></figure>

<h2 id="不显示全文"><a href="#不显示全文" class="headerlink" title="不显示全文"></a>不显示全文</h2><p>修改主题配置文件：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">excerpt_description:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>之后在写文章时写 description 即可，只会显示 description 的内容。</p>
<h1 id="添加功能"><a href="#添加功能" class="headerlink" title="添加功能"></a>添加功能</h1><h2 id="搜索功能"><a href="#搜索功能" class="headerlink" title="搜索功能"></a>搜索功能</h2><p>首先安装插件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-search</span><br></pre></td></tr></table></figure>

<p>之后更改主题配置文件：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">local_search:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h2 id="评论功能（基于Valine）"><a href="#评论功能（基于Valine）" class="headerlink" title="评论功能（基于Valine）"></a>评论功能（基于Valine）</h2><h3 id="注册LeanCloud"><a href="#注册LeanCloud" class="headerlink" title="注册LeanCloud"></a>注册LeanCloud</h3><p>因为 Valine 是基于 LeanCloud 系统的，所以先注册 LeanCloud 账号。</p>
<p><a href="https://console.leancloud.cn/login">LeanCloud官网</a></p>
<p>注册完成后，在控制台中创建应用，选择开发版。</p>
<h3 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h3><p>首先在 LeanCloud 上获取 AppID 和 AppKey：</p>
<p><img src="/2022/05/15/%E5%8D%9A%E5%AE%A2%E7%BE%8E%E5%8C%96%E6%8C%87%E5%8D%97/3.png" alt="img"></p>
<p>在主题配置文件中进行如下修改：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Valine</span></span><br><span class="line"><span class="comment"># For more information: https://valine.js.org, https://github.com/xCss/Valine</span></span><br><span class="line"><span class="attr">valine:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">appid:</span> <span class="string">填写这里</span> <span class="comment"># Your leancloud application appid</span></span><br><span class="line">  <span class="attr">appkey:</span> <span class="string">填写这里</span> <span class="comment"># Your leancloud application appkey</span></span><br><span class="line">  <span class="attr">notify:</span> <span class="literal">false</span> <span class="comment"># Mail notifier</span></span><br><span class="line">  <span class="attr">verify:</span> <span class="literal">false</span> <span class="comment"># Verification code</span></span><br><span class="line">  <span class="attr">placeholder:</span> <span class="string">留下一条友善的评论</span> <span class="comment"># Comment box placeholder</span></span><br><span class="line">  <span class="attr">avatar:</span> <span class="string">mm</span> <span class="comment"># Gravatar style</span></span><br><span class="line">  <span class="attr">guest_info:</span> <span class="string">nick,mail,link</span> <span class="comment"># Custom comment header</span></span><br><span class="line">  <span class="attr">pageSize:</span> <span class="number">8</span> <span class="comment"># Pagination size</span></span><br><span class="line">  <span class="attr">language:</span> <span class="string">zh-cn</span> <span class="comment"># Language, available values: en, zh-cn</span></span><br><span class="line">  <span class="attr">visitor:</span> <span class="literal">false</span> <span class="comment"># Article reading statistic</span></span><br><span class="line">  <span class="attr">comment_count:</span> <span class="literal">false</span> <span class="comment"># If false, comment count will only be displayed in post page, not in home page</span></span><br><span class="line">  <span class="attr">recordIP:</span> <span class="literal">false</span> <span class="comment"># Whether to record the commenter IP</span></span><br><span class="line">  <span class="attr">serverURLs:</span> <span class="comment"># When the custom domain name is enabled, fill it in here (it will be detected automatically by default, no need to fill in)</span></span><br><span class="line">  <span class="comment">#post_meta_order: 0</span></span><br></pre></td></tr></table></figure>

<h3 id="管理评论"><a href="#管理评论" class="headerlink" title="管理评论"></a>管理评论</h3><p>评论在这里进行管理：</p>
<p><img src="/2022/05/15/%E5%8D%9A%E5%AE%A2%E7%BE%8E%E5%8C%96%E6%8C%87%E5%8D%97/4.png" alt="img"></p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>知识备忘</tag>
        <tag>博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>博客问题指南</title>
    <url>/2022/05/11/%E5%8D%9A%E5%AE%A2%E9%97%AE%E9%A2%98%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<p>自己在建站的过程也遇到了很多问题，于是在这里给自己写一篇问题指南。</p>
<p><a href="https://hexo.io/zh-cn/docs">Hexo文档</a></p>
<p>首先要记住的一点就是，优先在官方文档找解决方案。</p>
<h1 id="如何开启本地服务器"><a href="#如何开启本地服务器" class="headerlink" title="如何开启本地服务器"></a>如何开启本地服务器</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo s          #hexo server，默认端口4000</span><br><span class="line">hexo s -p 1234	#我的本地4000端口似乎被占用，所以要手动换一个端口</span><br></pre></td></tr></table></figure>

<h1 id="如何同步文件"><a href="#如何同步文件" class="headerlink" title="如何同步文件"></a>如何同步文件</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo clean   #清除缓存文件 db.json 和已生成的静态文件 public</span><br><span class="line">hexo g       #生成网站静态文件到默认设置的 public 文件夹(hexo generate 的缩写)</span><br><span class="line">hexo d       #自动生成网站静态文件，并部署到设定的仓库(hexo deploy 的缩写)</span><br></pre></td></tr></table></figure>

<h1 id="如何支持数学函数"><a href="#如何支持数学函数" class="headerlink" title="如何支持数学函数"></a>如何支持数学函数</h1><p>我采用的方法是使用 next 主题自带的方式。</p>
<p>打开 next 的 _config.yml，设置 mathjax 为 true ：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">math:</span></span><br><span class="line">  <span class="attr">mathjax:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>之后，在每篇博客前加入 mathjax: true 即可正常显示数学函数了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 博客问题指南</span><br><span class="line">date: 2022-05-11 10:07:20</span><br><span class="line">tags:</span><br><span class="line">mathjax: true</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<h1 id="如何支持-md-语法显示图片"><a href="#如何支持-md-语法显示图片" class="headerlink" title="如何支持 md 语法显示图片"></a>如何支持 md 语法显示图片</h1><p>网上给出了诸多解决办法，但我使用了他们的方法后均没有成功，反而把博客搞崩了一次：（。最后我在官方文档里找到了适合我的解决方法，在此复述一遍。</p>
<p><a href="https://hexo.io/zh-cn/docs/asset-folders">Hexo资源文件夹</a></p>
<p>首先对 hexo 的 _config.yml 进行如下修改：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>修改后每当进行 new post 时，将会自动生成一个同名文件夹。我们要把需使用的图片放入此文件夹。</p>
<p>之后安装 hexo-renderer-marked 插件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-renderer-marked --save</span><br></pre></td></tr></table></figure>

<p>安装完成后，在 hexo 的 _config.yml 中添加如下语句：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">marked:</span></span><br><span class="line">  <span class="attr">prependRoot:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">postAsset:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>此时，我们就已经可以使用 <code>![](image.jpg)</code> 来引用图片了。</p>
<h1 id="添加标签产生-Cannot-GET-tags-等问题"><a href="#添加标签产生-Cannot-GET-tags-等问题" class="headerlink" title="添加标签产生 Cannot GET \tags\ 等问题"></a>添加标签产生 Cannot GET \tags\ 等问题</h1><p><img src="/2022/05/11/%E5%8D%9A%E5%AE%A2%E9%97%AE%E9%A2%98%E6%8C%87%E5%8D%97/1.png" alt="img"></p>
<p>在 next 的 _config.yml中取消了 tags 的注释，后产生了此错误。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">tags:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-tags</span></span><br></pre></td></tr></table></figure>

<p>原因是还需要进行后续的配置。首先创建新的 page：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new page &quot;tags&quot;</span><br></pre></td></tr></table></figure>

<p>此时 source 文件夹下会新建 tags 文件夹，其下还会产生 index.md 文件，对其进行如下修改：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">标签</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2022-05-11 16:15:22</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">&quot;tags&quot;</span>	<span class="comment">#写入本句，这句话的作用似乎是用来识别这个页面是&quot;tags&quot;预置页面</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure>

<p>在这之后，我们就可以愉快的为文章添加标签了，格式如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">博客问题指南</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2022-05-11 10:07:20</span></span><br><span class="line"><span class="attr">tags:</span></span><br><span class="line">	<span class="bullet">-</span> <span class="string">&quot;博客&quot;</span></span><br><span class="line">	<span class="bullet">-</span> <span class="string">&quot;其他&quot;</span></span><br><span class="line">	<span class="bullet">-</span> <span class="string">&quot;另一个&quot;</span></span><br><span class="line"><span class="attr">mathjax:</span> <span class="literal">true</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure>

<p>其余几项如关于（about）、分类（categories）等同理。</p>
<p><a href="https://www.icode9.com/content-4-1119485.html">参考</a></p>
<h1 id="如何支持下载-pdf"><a href="#如何支持下载-pdf" class="headerlink" title="如何支持下载 pdf"></a>如何支持下载 pdf</h1><p>安装插件即可：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-pdf --save</span><br></pre></td></tr></table></figure>

<p>后使用此格式引用就好：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[显示名称](文件.pdf)</span><br></pre></td></tr></table></figure>

<p>之后就可以点击下载了。至于如何在博客上显示 pdf ，由于自己还没有需求，所以没有记录，等以后用到了再回来补充。</p>
<h1 id="本地与服务器不同的语法"><a href="#本地与服务器不同的语法" class="headerlink" title="本地与服务器不同的语法"></a>本地与服务器不同的语法</h1><ol>
<li>在本地图片被存储在与 post 同名的文件夹下，而在服务器上图片被视为与 post 在同一目录下。</li>
<li>本地的 <code>\\</code> 在服务器会被视为 <code>\</code>，因此在书写 latex 语法时的 <code>\\</code> 为了在服务器上正确使用应写为 <code>\\\\</code>。</li>
</ol>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>知识备忘</tag>
        <tag>博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>博弈论</title>
    <url>/2022/02/12/%E5%8D%9A%E5%BC%88%E8%AE%BA/</url>
    <content><![CDATA[<p>博弈论就是指有若干个人进行一些对弈，并且默认每个人都可以找到当前的最优解，最后寻找有没有哪个人有必胜&#x2F;必败的的策略。</p>
<h1 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h1><p><strong>移动（Move）</strong>：对游戏局面的改变。<br><strong>局面（Position）</strong>：游戏进行中的一种状态。每个局面都对应着一个当前合法操作的集合。<br><strong>必败态（P-Position）</strong>：在当前的局面下，先手必败<br><strong>必胜态（N-Position）</strong>：在当前的局面下，先手必胜</p>
<p><strong>有关局面的性质：</strong></p>
<ul>
<li>合法操作集合为空的局面是必败态</li>
<li>可以移动到必败态的局面是必胜态</li>
<li>只能移动到必胜态的局面是必败态</li>
</ul>
<h1 id="公平组合游戏（ICG）"><a href="#公平组合游戏（ICG）" class="headerlink" title="公平组合游戏（ICG）"></a>公平组合游戏（ICG）</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ul>
<li>两名选手</li>
<li>两名选手轮流行动，每一次行动可以在有限合法操作集合中选择一个</li>
<li>游戏的任何一种可能的局面，合法操作集合只取决于这个局面本身，不取决于轮到哪名选手操作、以前的任何操作、骰子的点数或者其它因素</li>
<li>如果轮到某名选手移动，且这个局面的合法的移动集合为空（也就是说此时无法进行移动），则这名选手负</li>
</ul>
<h2 id="nim游戏"><a href="#nim游戏" class="headerlink" title="nim游戏"></a>nim游戏</h2><p><a href="https://www.luogu.com.cn/problem/P2197">nim游戏</a></p>
<p><strong>题目大意</strong>：有n堆石子，每堆有$s_i$个，两人依次从中任意一堆中取至少1个的任意数量的石子，问先手有没有必胜策略。</p>
<p><strong>在本游戏中可以得到一个结论：</strong></p>
<p>$$<br>当且仅当s_1 \oplus s_2 \oplus s_3 \oplus \cdots \oplus s_n &#x3D; 0时，局面为必败态<br>$$</p>
<p><strong>证明：</strong></p>
<ul>
<li>当石子数量和为0时为必败态（此时异或和为0）</li>
<li>当各石子堆异或和为$k(k \neq 0)$时，设k的最高位二进制1的位数为j，则我们一定能找到一堆石子$s_i$，且$s_i$的二进制第j位为1。将$s_i$的数量变为$s_i \oplus k$（显然在第j位为1的前提下$s_i &gt; s_i \oplus k$），此时各石子堆异或和便为0了（$x \oplus y \oplus y &#x3D; x$）。（必胜态转必败态）</li>
<li>若异或和为0且存在数量不为0的石子堆，不能找到一种方法使异或和仍为0。（异或的性质）（必败态转必胜态）</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> t,n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;t);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> v=<span class="number">1</span>;v&lt;=t;v++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> ans,lin;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;ans);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;lin);</span><br><span class="line">			ans^=lin;</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">		<span class="keyword">if</span>(ans) <span class="built_in">printf</span>(<span class="string">&quot;Yes\n&quot;</span>);</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="SG函数"><a href="#SG函数" class="headerlink" title="SG函数"></a>SG函数</h2><h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><p>给定一个有向无环图和一个起始顶点上的一枚棋子，Alice和Bob交替的将这枚棋子沿有向边进行移动，无法移动者判负。问是否有必胜策略。</p>
<p>该游戏可以认为是所有ICG游戏的抽象模型。也就是说，任何一个ICG游戏都可以通过把每个局面看成一个顶点，对每个局面和它的子局面连一条有向边来抽象成这个“有向图游戏”。</p>
<h3 id="函数建立"><a href="#函数建立" class="headerlink" title="函数建立"></a>函数建立</h3><p><strong>mex运算</strong>：这是施加于一个集合的运算，表示最小的不属于这个集合的非负整数，如mex{0, 1, 2, 4} &#x3D; 3、mex{2, 3, 5} &#x3D; 0、mex{} &#x3D; 0。</p>
<p>对于一个给定的有向无环图，定义关于图的每个顶点的SG函数sg如下：sg(x) &#x3D; mex{sg(y) | y是x的后继 }。也就是说，一个点的SG函数为在它所有后继中都未出现的最小的值。</p>
<p><strong>注意</strong>：由于这是一种类似递归的定义，所以对于一张有向无环图，每个点的SG值都是会被直接计算出来的。</p>
<h3 id="函数性质"><a href="#函数性质" class="headerlink" title="函数性质"></a>函数性质</h3><ul>
<li>没有出边的点，SG值为0。</li>
<li>对于一个$sg(x) &#x3D; 0$的顶点x，它的后继y都满足$sg(y) \neq 0$。</li>
<li>对于一个$sg(x) \neq 0$的顶点x，必定存在一个后继y都满足$sg(y) &#x3D; 0$。</li>
</ul>
<p>可以发现，SG函数的性质与必败态、必胜态的性质十分相似：</p>
<ul>
<li>顶点x所代表的局面是必败态当且仅当$sg(x) &#x3D; 0$。</li>
<li>顶点x所代表的局面是必胜态当且仅当$sg(x) &gt; 0$。</li>
</ul>
<h3 id="SG值的阶"><a href="#SG值的阶" class="headerlink" title="SG值的阶"></a>SG值的阶</h3><p>当$sg(x) &#x3D; k$时，表明对于任意一个$0 \leq i &lt; k$，都存在x的一个后继y满足$sg(y) &#x3D; i$。</p>
<p>因此当$sg(x) &#x3D; k$时，我们可以把这个点的SG值称为k阶SG值，它一定可以通过移动转换到一个拥有更低阶SG值的点。</p>
<h2 id="nim游戏与SG函数的联系"><a href="#nim游戏与SG函数的联系" class="headerlink" title="nim游戏与SG函数的联系"></a>nim游戏与SG函数的联系</h2><p>设有$G_1,G_2,G_3, \cdots ,G_n$个有向图游戏，定义游戏$G &#x3D; G_1 + G_2 + G_3 + \cdots + G_n$（游戏本身的加和，不是数学意义上的加和），移动规则为任选一个有向图$G_i$并移动上面的棋子。</p>
<p>Sprague-Grundy定理就是：</p>
<p>$$<br>\begin{aligned}<br>    &amp; 对于任意G &#x3D; G_1 + G_2 + G_3 + \cdots + G_n \\<br>    &amp; 有sg(G) &#x3D; sg(G_1) \oplus sg(G_2) \oplus \cdots \oplus sg(G_n) \\<br>    &amp; SG值相同局面，可以认为局面本质相同<br>\end{aligned}<br>$$</p>
<p>也就是说，游戏的和的SG函数值是它所有子游戏的SG函数值的异或。</p>
<p>之后我们可以发现，若将nim游戏中的每一堆石头看成一个有向图游戏，则nim游戏是一个符合上述定义的多个有向图相加的游戏G。因此我们可以分别计算每一堆石头的有向图所对应的SG值，再将所有的SG值进行异或从而得到nim游戏的SG值，从而找到必胜策略。</p>
<p><strong>注</strong>：对于任意一张子图$G_i$，它上面的不同的点要理解成本堆石头的当前状态，而不是整个nim游戏的当前状态，是多堆石头的不同状态得到的SG值异或得到了整个nim游戏的SG值，不存在一张有向图代表整个nim游戏（虽然的确可以存在这样一张有向图），而是nim游戏本身就是许多有向图的加和。这是我一开始不理解这个联系的重要一点。</p>
<p>不妨设第i个有向图游戏的点的值为$s_i$，当且仅当本点与本石子堆还剩$s_i$个石子的状态对应。</p>
<p>因此还剩一个问题：对于nim游戏来说，由于直接异或每堆石子的数量即可得到答案，因此：</p>
<p>$$<br>\begin{aligned}<br>    &amp; sg(G) &#x3D; s_1 \oplus s_2 \oplus s_3 \oplus \cdots \oplus s_n \\<br>    &amp; sg(G) &#x3D; sg(s_1) \oplus sg(s_2) \oplus \cdots \oplus sg(s_n) \\<br>\end{aligned}<br>$$</p>
<p>我们可以得到一个结论：$sg(s_i) &#x3D; s_i$。那么为什么？</p>
<p>这里不做严格证明，不过不难想象，这与SG值阶的转换有关。在标准的nim游戏中，<strong>对于每一堆石子我们每次都可以取任意数量的石子</strong>，由于石子的所有可能数量与有向图上的点一一对应，因此这句话与<strong>本点的SG值可以转换为任意SG值更低阶的点</strong>相对应，也便是<strong>本点的后继是所有小于本点值的点的集合</strong>，因此：</p>
<p>$$<br>sg(s_i) &#x3D; mex { x | 0 \leq x &lt; s_i 且x为非负整数 } &#x3D; s_i<br>$$</p>
<p>至此，nim游戏与SG函数的联系论述完成。</p>
<h2 id="nim游戏的变形与SG值的计算方法"><a href="#nim游戏的变形与SG值的计算方法" class="headerlink" title="nim游戏的变形与SG值的计算方法"></a>nim游戏的变形与SG值的计算方法</h2><p>在标准的nim游戏中，我们每次可以取不少于1个的任意个石子，使得在转换中有$sg(s_i) &#x3D; s_i$。但大多的时候转换的规律不会这么简单。</p>
<p><strong>第一个例子：</strong></p>
<p><img src="/2022/02/12/%E5%8D%9A%E5%BC%88%E8%AE%BA/2.png" alt="img"></p>
<p><img src="/2022/02/12/%E5%8D%9A%E5%BC%88%E8%AE%BA/3.png" alt="img"></p>
<p><strong>第二个例子：</strong></p>
<p>有n个石子，每次只能取{1, 3, 4}个石子，先取完石子者胜利，那么各个数的SG值为多少？</p>
<p><img src="/2022/02/12/%E5%8D%9A%E5%BC%88%E8%AE%BA/1.png" alt="img"></p>
<p>sg[0]&#x3D;0，f[]&#x3D;{1,3,4}；</p>
<p>x&#x3D;1时，可以取走1-f{1}个石子，剩余{0}个，mex{sg[0]}&#x3D;{0}，故sg[1]&#x3D;1；</p>
<p>x&#x3D;2时，可以取走2-f{1}个石子，剩余{1}个，mex{sg[1]}&#x3D;{1}，故sg[2]&#x3D;0；</p>
<p>x&#x3D;3时，可以取走3-f{1,3}个石子，剩余{2,0}个，mex{sg[2],sg[0]}&#x3D;{0,0}，故sg[3]&#x3D;1；</p>
<p>x&#x3D;4时，可以取走4-f{1,3,4}个石子，剩余{3,1,0}个，mex{sg[3],sg[1],sg[0]}&#x3D;{1,1,0},故sg[4]&#x3D;2；</p>
<p>x&#x3D;5时，可以取走5-f{1,3,4}个石子，剩余{4,2,1}个，mex{sg[4],sg[2],sg[1]}&#x3D;{2,0,1},故sg[5]&#x3D;3；</p>
<p>以此类推…</p>
<table>
<thead>
<tr>
<th align="center">x</th>
<th align="center">0</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
<th align="center">5</th>
<th align="center">6</th>
<th align="center">7</th>
<th align="center">8</th>
<th align="center">…</th>
</tr>
</thead>
<tbody><tr>
<td align="center">sg[x]</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">3</td>
<td align="center">2</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">…</td>
</tr>
</tbody></table>
<p>由此我们可以得到一些规律，总结出<strong>SG值的计算方法</strong>：</p>
<ul>
<li>可选步数为任意步，SG(x) &#x3D; x。</li>
<li>可选步数为1~m的连续整数，SG(x) &#x3D; x % (m+1)。</li>
<li>可选步数为一系列不连续的数，用模板计算。</li>
</ul>
<p><strong>模板</strong> 两种方法我觉得都是搜索</p>
<p>方法一：打表 f[]可以取走的石子个数,注意f[]需要从小到大排序 sg[]SG函数值；vis[]标记数组，用于求mex{}</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> f[MAXN],sg[MAXN];</span><br><span class="line"><span class="type">bool</span> vis[MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getSG</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">sort</span>(f+<span class="number">1</span>,f+<span class="number">1</span>+n);</span><br><span class="line">	<span class="built_in">memset</span>(sg,<span class="number">0</span>,<span class="built_in">sizeof</span>(sg));</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="built_in">sizeof</span>(vis));</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>; f[j]&lt;=i; j++)<span class="comment">//f排序是为了让每一种取法都循环到</span></span><br><span class="line">			vis[sg[i-f[j]]]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;=n; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (vis[j]==<span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				sg[i]=j; <span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法二：dfs s数组是定义特殊取法规则的数组，注意要按照从小到大排序；n表示集合大小 SG函数要初始化为-1，每个集合只需初始化一遍</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> s[MAXN],sg[MAXN],n;</span><br><span class="line"><span class="type">bool</span> vis[MAXN];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">SG_dfs</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (sh[x]!=<span class="number">-1</span>)</span><br><span class="line">		<span class="keyword">return</span> sg[x];</span><br><span class="line">	<span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="built_in">sizeof</span>(vis));</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (x&gt;=s[i])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">SG_dfs</span>(x-s[i]);</span><br><span class="line">			vis[sg[x-s[i]]]=<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (!vis[i])</span><br><span class="line">			<span class="keyword">return</span> sg[x]=i;</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.luogu.com.cn/problem/solution/P2197">https://www.luogu.com.cn/problem/solution/P2197</a></p>
<p><a href="https://blog.csdn.net/amf12345/article/details/97934508">https://blog.csdn.net/amf12345/article/details/97934508</a></p>
<p><a href="https://baike.baidu.com/item/SG%E5%87%BD%E6%95%B0/1004609?fr=aladdin">https://baike.baidu.com/item/SG%E5%87%BD%E6%95%B0/1004609?fr=aladdin</a></p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>OI 知识</tag>
      </tags>
  </entry>
  <entry>
    <title>天气数据图像插值</title>
    <url>/2022/06/13/%E5%A4%A9%E6%B0%94%E6%95%B0%E6%8D%AE%E5%9B%BE%E5%83%8F%E6%8F%92%E5%80%BC/</url>
    <content><![CDATA[<p>对于图像插值这个事情自己算大概有一些了解了，在要求下用 python 写过两次。尤其要分辨的是，均匀点插值与散点插值的方法上还是有很大的差异的，不过共同点就是都要插到一个二维数组里。</p>
<h1 id="均匀点插值"><a href="#均匀点插值" class="headerlink" title="均匀点插值"></a>均匀点插值</h1><p>这个方法好多，比如最近邻插值、双线性插值、高阶插值等，由于我们数据的特殊性，是把 1X1 插成 10X10，我便用了一种近似双线性插值的简单方法解决了问题，简单说就是根据四个角上的值通过距离确定权重去补全它们之间的 96 个点。总之效果还算不错，这事也便完工了。</p>
<h1 id="散点插值"><a href="#散点插值" class="headerlink" title="散点插值"></a>散点插值</h1><p>我使用的就是普通的 IDW 插值，他的思路以插值点与样本点间的距离为权重进行加权平均，离插值点越近的样本点赋予的权重越大，好处就是好写，并且我自己实验发现通过改变权值计算公式的次方数是可以扩大点的扩散影响力的（当然次数太大了方法也就退化了）。但据我搜集资料还有一种叫做克里金插值的方法，可惜我是没研究出来…</p>
<p>注意：散点插值的点一般很稀疏，所以插值的情况一般不会很理想，画出来的图也就不好看。我的解决方法是把图的数据标准处理一下，也就是让数据变成10、20、30等这种有梯度的数据，对出图效果有明显的改观。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>大气遥感项目</tag>
      </tags>
  </entry>
  <entry>
    <title>层次分析法</title>
    <url>/2022/02/09/%E5%B1%82%E6%AC%A1%E5%88%86%E6%9E%90%E6%B3%95/</url>
    <content><![CDATA[<p>层次分析法（AHP）用来解决评价类问题。</p>
<h1 id="评价类问题"><a href="#评价类问题" class="headerlink" title="评价类问题"></a>评价类问题</h1><p>解决评价类问题，首先要想到以下三个问题：</p>
<ul>
<li>我们评价的目标是什么？</li>
<li>我们为了达到这个目标有哪几种可选的方案？</li>
<li>评价的准则或者说指标是什么（我们根据什么东西来评价好坏）</li>
</ul>
<h1 id="打分法"><a href="#打分法" class="headerlink" title="打分法"></a>打分法</h1><table>
<thead>
<tr>
<th align="center"></th>
<th align="center"><strong>指标权重</strong></th>
<th align="center"><strong>方案1</strong></th>
<th align="center"><strong>方案2</strong></th>
<th align="center"><strong>…</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>指标1</strong></td>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">2</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center"><strong>指标2</strong></td>
<td align="center">1</td>
<td align="center">3</td>
<td align="center">3</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center"><strong>指标3</strong></td>
<td align="center">1</td>
<td align="center">4</td>
<td align="center">4</td>
<td align="center">4</td>
</tr>
<tr>
<td align="center"><strong>…</strong></td>
<td align="center">1</td>
<td align="center">5</td>
<td align="center">5</td>
<td align="center">5</td>
</tr>
</tbody></table>
<p>同数字格相加为1。</p>
<h1 id="分治思想"><a href="#分治思想" class="headerlink" title="分治思想"></a>分治思想</h1><p>一次性考虑多个指标间的关系往往考虑不周，因此两两指标进行比较，最终推算出总权重。</p>
<h1 id="重要程度（或满意度）"><a href="#重要程度（或满意度）" class="headerlink" title="重要程度（或满意度）"></a>重要程度（或满意度）</h1><table>
<thead>
<tr>
<th>标度</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>两个因素相比，同样重要</td>
</tr>
<tr>
<td>3</td>
<td>两个因素相比，一个比另一个稍微重要</td>
</tr>
<tr>
<td>5</td>
<td>两个因素相比，一个比另一个明显重要</td>
</tr>
<tr>
<td>7</td>
<td>两个因素相比，一个比另一个强烈重要</td>
</tr>
<tr>
<td>9</td>
<td>两个因素相比，一个比另一个极端重要</td>
</tr>
<tr>
<td>2，4，6，8</td>
<td>上述两相邻判断的中值</td>
</tr>
<tr>
<td>倒数</td>
<td>若A和B比标度是3，则B和A比标度是1&#x2F;3</td>
</tr>
</tbody></table>
<h1 id="判断矩阵"><a href="#判断矩阵" class="headerlink" title="判断矩阵"></a>判断矩阵</h1><table>
<thead>
<tr>
<th align="center"></th>
<th align="center"><strong>指标1</strong></th>
<th align="center"><strong>指标2</strong></th>
<th align="center"><strong>指标3</strong></th>
<th align="center"><strong>指标4</strong></th>
<th align="center"><strong>指标5</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>指标1</strong></td>
<td align="center"><strong>1</strong></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><strong>指标2</strong></td>
<td align="center"></td>
<td align="center"><strong>1</strong></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><strong>指标3</strong></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"><strong>1</strong></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><strong>指标4</strong></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"><strong>1</strong></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><strong>指标5</strong></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"><strong>1</strong></td>
</tr>
</tbody></table>
<p>方案矩阵同理。</p>
<p><strong>注：</strong>指标矩阵由专家填写，方案矩阵由主角填写，判断矩阵在填写后可能有逻辑错误。</p>
<p>填好的5X5方阵记为A，其对应元素为$a_{ij}$，A有如下特点：</p>
<ul>
<li>$a_{ij}$的意义为与指标j相比，i的重要程度。</li>
<li>当$i&#x3D;j$时，两指标相同，记为1。</li>
<li>$a_{ij}&gt;0$且满足$a_{ij} \cdot a_{ji} &#x3D; 1$（正互反矩阵）</li>
</ul>
<h1 id="一致矩阵"><a href="#一致矩阵" class="headerlink" title="一致矩阵"></a>一致矩阵</h1><p>$$<br>\begin{aligned}<br>    &amp; a_{ij} &#x3D; {i的重要程度 \over j的重要程度} , a_{jk} &#x3D; {j的重要程度 \over k的重要程度} \<br>    &amp; a_{ik} &#x3D; {i的重要程度 \over k的重要程度} &#x3D; a_{ij} \cdot a_{jk} \<br>\end{aligned}<br>$$</p>
<p>若正互反矩阵满足$a_{ik} &#x3D; a_{ij} \cdot a_{jk}$，则为一致矩阵。</p>
<p>一致矩阵各行（各列）之间成倍数关系。</p>
<p><strong>注：</strong>因此可知，在使用判断矩阵求权重前，一定要进行<strong>一致性检验</strong>。</p>
<h1 id="一致性检验"><a href="#一致性检验" class="headerlink" title="一致性检验"></a>一致性检验</h1><p><strong>原理：</strong>检验构造的判断矩阵和一致矩阵是否有太大区别。</p>
<p>$$<br>\left[<br>    \begin{matrix}<br>        a_{11} &amp; a_{12} &amp; \cdots &amp; a_{1n} \<br>        a_{21} &amp; a_{22} &amp; \cdots &amp; a_{2n} \<br>        \vdots &amp; \vdots &amp; \ddots &amp; \vdots \<br>        a_{n1} &amp; a_{n2} &amp; \cdots &amp; a_{nn} \<br>    \end{matrix}<br>\right]<br>为一致矩阵的充要条件：<br>\begin{cases}<br>    a_{ij} &gt; 0 \<br>    a_{11} &#x3D; a_{22} &#x3D; \cdots &#x3D; a_{nn} &#x3D; 1 \<br>    [a_{i1}, a_{i2}, \cdots , a_{in}] &#x3D; k_i[a_{11}, a_{12}, \cdots , a_{1n}]\<br>\end{cases}<br>$$</p>
<p>引理：A为n阶方阵，且$r(A) &#x3D; 1$则A有一个特征值为$tr(A)$，其余特征值为0。</p>
<p>因为一致矩阵各行成比例，其秩一定为1。</p>
<p>由引理可知：一致矩阵有一个特征值为n，其余特征值均为0。</p>
<p>另外易得，当特征值为n时，对应的特征向量刚好为$k[{1 \over a_{11}}, {1 \over a_{12}}, \cdots , {1 \over a_{1n}}]^T \ (k \neq 0)$。</p>
<p>引理：n阶正互反矩阵A为一致矩阵当且仅当最大特征值$\lambda_{max} &#x3D; n$，且当正互反矩阵A非一致时一定满足$\lambda_{max} &gt; n$。</p>
<p><strong>步骤：</strong></p>
<p>第一步：计算<strong>一致性指标CI</strong></p>
<p>$$<br>CI &#x3D; {\lambda_{max} - n \over n - 1}<br>$$</p>
<p>第二步：查找对应的<strong>平均随机一致性指标RI</strong></p>
<table>
<thead>
<tr>
<th><strong>n</strong></th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
<th>10</th>
<th>11</th>
<th>12</th>
<th>13</th>
<th>14</th>
<th>15</th>
</tr>
</thead>
<tbody><tr>
<td><strong>RI</strong></td>
<td>0</td>
<td>0</td>
<td>0.52</td>
<td>0.89</td>
<td>1.12</td>
<td>1.26</td>
<td>1.36</td>
<td>1.41</td>
<td>1.46</td>
<td>1.49</td>
<td>1.52</td>
<td>1.54</td>
<td>1.56</td>
<td>1.58</td>
<td>1.59</td>
</tr>
</tbody></table>
<p><strong>注：</strong>在实际应用中，n很少超过10，如果指标的个数大于10，则可考虑建立二级指标体系。</p>
<p>第三步：计算<strong>一致性比例CR</strong></p>
<p>$$<br>CR &#x3D; {CI \over RI}<br>$$</p>
<p>若$CR &lt; 0.1$，则可认为判断矩阵的一致性可以接受；否则需要对判断矩阵进行修正。</p>
<h1 id="一致矩阵计算权重"><a href="#一致矩阵计算权重" class="headerlink" title="一致矩阵计算权重"></a>一致矩阵计算权重</h1><p>因为各列成比例，所以随便选一列计算权重并进行归一化处理（各项相加等于1）。</p>
<h1 id="判断矩阵计算权重"><a href="#判断矩阵计算权重" class="headerlink" title="判断矩阵计算权重"></a>判断矩阵计算权重</h1><p>因为各列不成比例，所以每列计算权重并进行归一化处理，最后取平均值。</p>
<h2 id="方法1-算术平均法求权重"><a href="#方法1-算术平均法求权重" class="headerlink" title="方法1 算术平均法求权重"></a>方法1 算术平均法求权重</h2><p>第一步：将判断矩阵按照列归一化（每一个元素除以其所在列的和）</p>
<p>第二步：将归一化的各列相加（按行求和）</p>
<p>第三步：将相加后得到的向量中每个元素除以n即可得到权重向量</p>
<p><strong>数学描述：</strong></p>
<p>$$<br>\begin{aligned}<br>    &amp; 假设判断矩阵A &#x3D;<br>    \left[<br>    \begin{matrix}<br>        a_{11} &amp; a_{12} &amp; \cdots &amp; a_{1n} \<br>        a_{21} &amp; a_{22} &amp; \cdots &amp; a_{2n} \<br>        \vdots &amp; \vdots &amp; \ddots &amp; \vdots \<br>        a_{n1} &amp; a_{n2} &amp; \cdots &amp; a_{nn} \<br>    \end{matrix}<br>\right], \<br>    &amp; 那么算术平均法求得的权重向量 w_i &#x3D; {1 \over n} \sum^n_{j&#x3D;1} {a_{ij} \over \sum^n_{k&#x3D;1} a_{kj}} \ (i &#x3D; 1, 2, \cdots , n)\<br>\end{aligned}<br>$$</p>
<h2 id="方法2-几何平均法求权重"><a href="#方法2-几何平均法求权重" class="headerlink" title="方法2 几何平均法求权重"></a>方法2 几何平均法求权重</h2><p>待补充</p>
<h2 id="方法3-特征值法求权重"><a href="#方法3-特征值法求权重" class="headerlink" title="方法3 特征值法求权重"></a>方法3 特征值法求权重</h2><p>一致矩阵有一个特征值为n，其余特征值均为0。</p>
<p>另外易得，当特征值为n时，对应的特征向量刚好为$k[{1 \over a_{11}}, {1 \over a_{12}}, \cdots , {1 \over a_{1n}}]^T \ (k \neq 0)$。</p>
<p>这一特征向量刚好就是一致矩阵的第一列</p>
<p>还是先归一化。</p>
<p>假如判断矩阵的一致性可以接受，则可仿照一致矩阵求权重的方法。</p>
<p>第一步：求出矩阵A的最大特征值以及其对应的特征向量</p>
<p>第二步：对求出的特征向量进行归一化即得到权重</p>
<h1 id="整体步骤"><a href="#整体步骤" class="headerlink" title="整体步骤"></a>整体步骤</h1><h2 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h2><p>分析系统中各因素之间的关系，建议系统的递阶层次结构。</p>
<p>目标层（Objective）</p>
<p>准则层（Criterion）</p>
<p>方案层（Plan）</p>
<h2 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h2><p>对于同一层次的各元素关于上一层次中某一准则的重要性进行两两比较，构造两两比较矩阵（判断矩阵）。</p>
<h2 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h2><p>由判断矩阵计算被比较元素对于该准则的相对权重，并进行一致性检验（检验通过权重才能用）。</p>
<p>三种方法计算权重：</p>
<ul>
<li>算数平均法</li>
<li>几何平均法</li>
<li>特征值法</li>
</ul>
<p>建议三种方法都使用。</p>
<p><strong>CR &gt; 0.1如何修正：</strong></p>
<p>往一致矩阵上调整，一致矩阵各行成倍数关系。</p>
<h2 id="第四步"><a href="#第四步" class="headerlink" title="第四步"></a>第四步</h2><p>计算各层元素对系统目标的合成权重，并进行排序。</p>
<h1 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h1><p>（1）评价的决策层不能太多，太多的话n会很大，判断矩阵和一致矩阵差异可能会很大。</p>
<table>
<thead>
<tr>
<th><strong>n</strong></th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
<th>10</th>
<th>11</th>
<th>12</th>
<th>13</th>
<th>14</th>
<th>15</th>
</tr>
</thead>
<tbody><tr>
<td><strong>RI</strong></td>
<td>0</td>
<td>0</td>
<td>0.52</td>
<td>0.89</td>
<td>1.12</td>
<td>1.26</td>
<td>1.36</td>
<td>1.41</td>
<td>1.46</td>
<td>1.49</td>
<td>1.52</td>
<td>1.54</td>
<td>1.56</td>
<td>1.58</td>
<td>1.59</td>
</tr>
</tbody></table>
<p>（2）如果决策层中指标的数据是已知的，那么如何利用这些数据来使得评价更加准确？</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%% 测试数据</span></span><br><span class="line"><span class="comment">% [1 1 4 1/3 3; 1 1 4 1/3 3; 1/4 1/4 1 1/3 1/2; 3 3 3 1 3; 1/3 1/3 2 1/3 1] </span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 输入判断矩阵</span></span><br><span class="line">clear; clc</span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;请输入判断矩阵A：&#x27;</span>)</span><br><span class="line">A = input(<span class="string">&#x27;判断矩阵A=&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 方法1：算数平均法求权重</span></span><br><span class="line"><span class="comment">% 第一步：将判断矩阵按照列归一化（每一个元素除以其所在列的和）</span></span><br><span class="line">Sum_A = sum(A)</span><br><span class="line"></span><br><span class="line">[n, n] = <span class="built_in">size</span>(A)	<span class="comment">% 也可以写成n = size(A, 1)</span></span><br><span class="line"><span class="comment">% 因为我们的判断矩阵A是一个方阵，所以这里的r和c相同，我们可以就用同一个字母n表示</span></span><br><span class="line">SUM_A = <span class="built_in">repmat</span>(Sum_A, n, <span class="number">1</span>)	<span class="comment">% repeat matrix的缩写</span></span><br><span class="line"><span class="comment">% 另外一种替代的方法如下：</span></span><br><span class="line"><span class="comment">%	SUM_A = [];</span></span><br><span class="line"><span class="comment">%	for i = 1 : n</span></span><br><span class="line"><span class="comment">%		SUM_A = [SUM_A; Sum_A]</span></span><br><span class="line"><span class="comment">%	end</span></span><br><span class="line">clc; A</span><br><span class="line">SUM_A</span><br><span class="line">Stand_A = A ./ SUM_A</span><br><span class="line"><span class="comment">% 这里我们直接将两个矩阵对应的元素相除即可</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 第二步：将归一化的各列相加（按行求和）</span></span><br><span class="line">sum(Stand_A, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">% 第三步：将相加后得到的向量中每个元素除以n即可得到权重向量</span></span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;算术平均法求权重的结果为：&#x27;</span>);</span><br><span class="line"><span class="built_in">disp</span>(sum(Stand_A, <span class="number">2</span>) / n)</span><br><span class="line"><span class="comment">% 首先对标准化后的矩阵按照行求和，得到一个列向量</span></span><br><span class="line"><span class="comment">% 然后再将这个列向量的每个元素同时除以n即可（这里也可用./）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 方法2：几何平均法求权重</span></span><br><span class="line"><span class="comment">% 第一步：将A的元素按照行相乘得到一个新的列向量</span></span><br><span class="line">clc; A</span><br><span class="line">Prduct_A = prod(A, <span class="number">2</span>)</span><br><span class="line"><span class="comment">% prod函数和max函数类似，一个用于乘，一个用于加</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 第二步：将新向量的每个分量开n次方</span></span><br><span class="line">Prduct_n_A = Prduct_A .^ (<span class="number">1</span>/n)</span><br><span class="line"><span class="comment">%这里最每个元素进行乘方操作，开n次方等价于求1/n</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 第三步：对该列向量进行归一化即可得到权重向量</span></span><br><span class="line"><span class="comment">% 将这个列向量中的每一个元素除以这一个向量的和即可</span></span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;几何平均法求权重的结果为：&#x27;</span>);</span><br><span class="line"><span class="built_in">disp</span>(Prduct_n_A ./ sum(Prduct_n_A))</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 方法3：特征值法求权重</span></span><br><span class="line"><span class="comment">% 第一步：求出矩阵A的最大特征值以及其对应的特征向量</span></span><br><span class="line">clc</span><br><span class="line">[V, D] = eig(A)	<span class="comment">% V是特征向量，D是由特征值构成的对角矩阵（除了对角元素外都为0）</span></span><br><span class="line">Max_eig = <span class="built_in">max</span>(<span class="built_in">max</span>(D)) <span class="comment">% 也可写成max(D(:))</span></span><br><span class="line"><span class="comment">% 找最大特征值虽在位置用到find函数，其可以返回向量或矩阵中不为0的元素的位置索引。</span></span><br><span class="line"><span class="comment">% 找到最大特征值位置后，需要将包含所有特征值的这个对角矩阵D中，不等于0的位置全变为0</span></span><br><span class="line"><span class="comment">% 此时运用矩阵与常数的大小判断运算</span></span><br><span class="line">D == Max_eig</span><br><span class="line">[r, c] = <span class="built_in">find</span>(D == Max_eig, <span class="number">1</span>)</span><br><span class="line"><span class="comment">%找到D中第一个与最大特征值相等元素的位置，记录其行列</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 第二步：对求出的特征向量进行归一化即可得到权重</span></span><br><span class="line">V( : , c)</span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;特征值法求权重的结果为：&#x27;</span>);</span><br><span class="line"><span class="built_in">disp</span>(V( : , c) ./ sum(V( : , c)))</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 计算一致性比例CR</span></span><br><span class="line">clc</span><br><span class="line">CI = (Max_eig - n) / (n - <span class="number">1</span>)</span><br><span class="line">RI = [<span class="number">0</span> <span class="number">0</span> <span class="number">0.52</span> <span class="number">0.89</span> <span class="number">1.12</span> <span class="number">1.26</span> <span class="number">1.36</span> <span class="number">1.41</span> <span class="number">1.46</span> <span class="number">1.52</span> <span class="number">1.54</span> <span class="number">1.56</span> <span class="number">1.58</span> <span class="number">1.59</span>];	<span class="comment">% RI最多支持n = 15</span></span><br><span class="line">CR = CI/RI(n);</span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;一致性指标CI=&#x27;</span>); <span class="built_in">disp</span>(CI);</span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;一致性比例RI=&#x27;</span>); <span class="built_in">disp</span>(RI);</span><br><span class="line"><span class="keyword">if</span> CR &lt; <span class="number">0.10</span></span><br><span class="line">	<span class="built_in">disp</span>(<span class="string">&#x27;因为CR &lt; 0.10，所以该判断矩阵A的一致性可以接受&#x27;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	<span class="built_in">disp</span>(<span class="string">&#x27;注意：CR &gt;= 0.10，因此该判断矩阵A需要进行修改&#x27;</span>);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>数学建模竞赛</tag>
      </tags>
  </entry>
  <entry>
    <title>常忘数学公式语法</title>
    <url>/2022/05/15/%E5%B8%B8%E5%BF%98%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<p>平时写数学公式时，总是忘记一些符号的代码，在此将他们统一记录一下，方便查找。</p>
<h1 id="一般符号类"><a href="#一般符号类" class="headerlink" title="一般符号类"></a>一般符号类</h1><table>
<thead>
<tr>
<th align="left">符号</th>
<th align="left">代码</th>
</tr>
</thead>
<tbody><tr>
<td align="left">约等号</td>
<td align="left">\approx</td>
</tr>
<tr>
<td align="left">累加</td>
<td align="left">\sum</td>
</tr>
<tr>
<td align="left">累乘</td>
<td align="left">\prod</td>
</tr>
<tr>
<td align="left">分式</td>
<td align="left">\over</td>
</tr>
<tr>
<td align="left">小于等于</td>
<td align="left">\leq</td>
</tr>
<tr>
<td align="left">大于等于</td>
<td align="left">\geq</td>
</tr>
<tr>
<td align="left">与</td>
<td align="left">\&amp; \land</td>
</tr>
<tr>
<td align="left">上取整</td>
<td align="left">\lceil \rceil</td>
</tr>
<tr>
<td align="left">下取整</td>
<td align="left">\lfloor \rfloor</td>
</tr>
</tbody></table>
<h1 id="希腊字母类"><a href="#希腊字母类" class="headerlink" title="希腊字母类"></a>希腊字母类</h1><p>首字母大写就是大写希腊字母。</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>代码</th>
</tr>
</thead>
<tbody><tr>
<td>阿尔法</td>
<td>\alpha</td>
</tr>
<tr>
<td>贝塔</td>
<td>\beta</td>
</tr>
<tr>
<td>ρ</td>
<td>\rho</td>
</tr>
<tr>
<td>δ</td>
<td>\delta</td>
</tr>
<tr>
<td>Δ</td>
<td>\Delta</td>
</tr>
</tbody></table>
<h1 id="特殊效果类"><a href="#特殊效果类" class="headerlink" title="特殊效果类"></a>特殊效果类</h1><p>在博客上写此类符号时往往要多加一个\，不然两个的\往往会被转义掉。</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>代码</th>
</tr>
</thead>
<tbody><tr>
<td>空格</td>
<td>\</td>
</tr>
<tr>
<td>回车</td>
<td>\ \</td>
</tr>
<tr>
<td>长空格</td>
<td>\quad</td>
</tr>
</tbody></table>
<h1 id="点类"><a href="#点类" class="headerlink" title="点类"></a>点类</h1><table>
<thead>
<tr>
<th>符号</th>
<th>代码</th>
</tr>
</thead>
<tbody><tr>
<td>点乘</td>
<td>\cdot</td>
</tr>
<tr>
<td>横着三个点</td>
<td>\codts</td>
</tr>
<tr>
<td>竖着三个点</td>
<td>\vdots</td>
</tr>
<tr>
<td>斜着三个点</td>
<td>\ddots</td>
</tr>
</tbody></table>
<h1 id="大括号类"><a href="#大括号类" class="headerlink" title="大括号类"></a>大括号类</h1><p>此类符号的格式为 \begin{写在这里} \end{还有这里} 。</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>代码</th>
</tr>
</thead>
<tbody><tr>
<td>带标注的多行</td>
<td>align</td>
</tr>
<tr>
<td>多行</td>
<td>aligned</td>
</tr>
<tr>
<td>大括号</td>
<td>cases</td>
</tr>
<tr>
<td>矩阵</td>
<td>matrix</td>
</tr>
<tr>
<td>小括号矩阵</td>
<td>pmatrix</td>
</tr>
<tr>
<td>方括号矩阵</td>
<td>bmatrix</td>
</tr>
<tr>
<td>大括号矩阵</td>
<td>Bmatrix</td>
</tr>
<tr>
<td>行列式</td>
<td>vmatrix</td>
</tr>
<tr>
<td>范数矩阵</td>
<td>Vmatrix</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>知识备忘</tag>
        <tag>LaTex</tag>
      </tags>
  </entry>
  <entry>
    <title>并查集</title>
    <url>/2021/03/30/%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
    <content><![CDATA[<p>并查集是一种在线维护集合关系的数据结构，它支持两个操作：</p>
<ul>
<li><strong>合并</strong>：将两个元素所属的集合合并为一个。</li>
<li><strong>查询</strong>：查询某两个元素是否在同一集合中。</li>
</ul>
<p><strong>时间复杂度</strong>：合并与查询都接近$O(1)$。</p>
<h2 id="普通并查集"><a href="#普通并查集" class="headerlink" title="普通并查集"></a>普通并查集</h2><p>假设我们有n个元素，它们分别使用1~n表示。并查集为了实现维护集合关系，为每个元素增加了一个用来指向其他元素的$fa_i$属性（父亲属性）。该属性初始值$fa_i &#x3D; i$（即指向自己）。并查集就是利用了这个父亲属性将不同的元素串连起来，组成不同的集合。</p>
<p>比如有3个元素A、B、C，若我们想要使用fa[A] &#x3D; B的这种关系把它们联系起来形成一个集合，我们可能会这样串连他们（都为向上的有向线段）：</p>
<p><img src="/2021/03/30/%E5%B9%B6%E6%9F%A5%E9%9B%86/1.png" alt="img"></p>
<p>在我们画的图上，我们认为一个点的父亲节点就是该点上方的那个节点，即把图描述出来为：</p>
<ul>
<li>fa[A]&#x3D;B、fa[C]&#x3D;B、fa[B]&#x3D;B</li>
<li>fa[A]&#x3D;B、fa[B]&#x3D;C、fa[C]&#x3D;C</li>
</ul>
<p>由于每个元素都是单指向的，所以我们所能连接出的图的顶部有且只有一个元素（如第一个图为B，第二个图为C）。这个元素的fa为它本身，且集合内的任意元素在沿着fa的指引向上追溯时，一定会找到该元素。所以此元素便是该集合的唯一<strong>标识</strong>，这个向上追溯找到标识的操作便是并查集的核心。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(x==fa[x]) <span class="keyword">return</span> x;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有了追溯标识的操作，我们便不难定义出合并与查询：</p>
<p>设x &#x3D; find(A)，y &#x3D; find(B)，即x为A元素所在集合的标识，y为B元素所在集合的标识。</p>
<p><strong>注</strong>：标识本身也是一个元素。在开始时$fa_i &#x3D; i$，也就是说每个元素单独构成一个只有自己的集合。</p>
<ul>
<li><strong>合并</strong>：fa[y] &#x3D; x。将两个元素所属的集合合并为一个。写成fa[x] &#x3D; y效果相同。</li>
<li><strong>查询</strong>：if(x &#x3D;&#x3D; y) 。查询某两个元素是否在同一集合中。</li>
</ul>
<p>看下面这个例子，这是执行了fa[D] &#x3D; B之后集合的样子。</p>
<p><img src="/2021/03/30/%E5%B9%B6%E6%9F%A5%E9%9B%86/2.png" alt="img"></p>
<p>首先我们确认一点，并查集下某个集合的结构就像一棵树，而标识正是这棵树的树根。</p>
<p>我们发现，随着合并次数的增加，树的深度越来越大，如果我们此时查询G所在集合的标识效率会大打折扣。我们可以通过一个小优化来提升效率。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(x==fa[x]) <span class="keyword">return</span> x;</span><br><span class="line">  <span class="keyword">return</span> fa[x]=<span class="built_in">find</span>(fa[x]);	<span class="comment">//这里变化了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们在递归的过程中压缩了树的高度，向上找到树根后，在逐级下放的过程中将所有子节点的父节点都改变成了树根，使得树被压缩，从而在不影响集合标识的同时提升了find函数的效率，这是并查集的精髓（在带权并查集中会更有体现）。</p>
<p>find(G)后树的压缩情况：</p>
<p><img src="/2021/03/30/%E5%B9%B6%E6%9F%A5%E9%9B%86/3.png" alt="img"></p>
<h2 id="种类并查集"><a href="#种类并查集" class="headerlink" title="种类并查集"></a>种类并查集</h2><p><strong>注</strong>：此部分为本人理解，酌情参考。</p>
<p><a href="https://www.luogu.com.cn/problem/P1525">洛谷P1525 关押罪犯</a></p>
<p><del>看到最小的最大直接二分答案</del></p>
<p>分析一下不难发现，我们需要将罪犯划分为两个集合。</p>
<p>我们可能会使用这种策略：</p>
<ol>
<li>将罪犯组的怨气值由大到小排序，后从大到小依次判断。</li>
<li>若此组可以分开到两个监狱，则分到两个不同的监狱。</li>
<li>若此组不能被分开到两个监狱（1. 这组的两个人因前面的分配已经被分配到同一个监狱里了。2. 有一个相比两人间的仇恨与这两人都有深仇大恨的人已经入狱了），答案为此组怨气值。</li>
</ol>
<p>这个策略是正确的，但若想使用并查集解决便出现了问题。</p>
<p>并查集所支持的操作是将两个集合合并，而不是将两个集合间划分界限。这时，种类并查集孕育而生，它给了并查集更广泛的意义。</p>
<p>现在拓宽集合的概念，我们要为每个集合加上一个<strong>标签</strong>。如一个集合的标签为“它们应该在一起”，同样的，我们可以创造一个标签为“A和B应该分到不同监狱”的集合。当然不难发现这个集合是有限制的，我们定义的标签让我们希望这个集合中只有2个元素。与其说现在在用并查集维护集合，不如说我们现在在用并查集维护一种人与人间的<strong>关系</strong>。</p>
<p>在本题中，由于只有2座监狱，所以存在<strong>传递性</strong>：如果A应与C分开，B也应与C分开，那么A和B就应该在一起。依靠传递性，我们以C为媒介，将A和B间的关系连接了起来。</p>
<p>这时存在一个问题，我们按照这样的关系进行合并：</p>
<ul>
<li>A应与C分开，因此二者放入同一有“A和C应分开”标签的集合，A与C连接</li>
<li>B应与C分开，因此二者放入同一有“B和C应分开”标签的集合，B与C连接</li>
<li>哦吼，A、B、C进入了一个集合，关系混乱了</li>
</ul>
<p>可以看到，使用这种只能存在2个元素的标签虽然想法很美好，但现实很残酷。</p>
<p>为了解决这个问题，我们不仅引入了一种标签，还引入了一种媒介。我们对应每一个罪犯X创建一个<strong>分开媒介!X</strong>，如罪犯C的分开媒介!C。!C存在的目的就是与“不能与C在一起”的罪犯连接起来，形成一个集合，理所当然的，“不能与C在一起”便是这个集合的标签。按照这种理念合并：</p>
<ul>
<li>A应与C分开，因此A应放入“不能与C在一起”的集合，A与!C连接，<strong>同时C应放入“不能与A在一起”的集合，C与!A连接</strong></li>
<li>B应与C分开，因此B应放入“不能与C在一起”的集合，B与!C连接，<strong>同时C应放入“不能与B在一起”的集合，C与!B连接</strong></li>
<li>!C-A-B、!A-C、!B-C，逻辑和结构上很清晰</li>
</ul>
<p><strong>注</strong>：C与!C虽有联系但有本质区别，C是真实存在的罪犯，而!C是一种用来表示“不能与C在一起”的关系的媒介，不过两者在编程过程中被视为同等的元素对待。</p>
<p>题目被解决了，策略如下：</p>
<p>在代码实现中，若有n个罪犯，对应编号分别为$a_i$，那么编号为$a_i$的罪犯的分开媒介的编号使用$a_i + n$表示。</p>
<p>若a、b为一组罪犯的两个编号，设x &#x3D; find(a)，y &#x3D; find(b)，nx &#x3D; find(a + n)，ny &#x3D; find(b + n)。</p>
<ol>
<li>将罪犯组的怨气值由大到小排序，后从大到小依次判断。</li>
<li>如果此组可以分开到两个监狱，则fa[x] &#x3D; ny，fa[y] &#x3D; nx。</li>
<li>如果起了冲突，也就是(x &#x3D;&#x3D; y || nx &#x3D;&#x3D; ny)，输出此组怨气值。</li>
</ol>
<p>再来简略的看一道题：</p>
<p><a href="https://www.luogu.com.cn/problem/P2024">洛谷P2024 食物链</a></p>
<p>对于一类物种，与其他物种应有3种关系：与X同类，被X吃（X的猎物），X被吃（X的猎人）。</p>
<p>假设有n个动物，对应编号分别为$a_i$，那么编号为$a_i$的动物的猎物媒介的编号使用$a_i + n$表示，猎人媒介的编号使用$a_i + 2n$表示。</p>
<ul>
<li>当A和B是同类时：分别合并A和B，A的猎物和B的猎物，A的天敌和B的天敌。</li>
<li>当A吃B时：分别合并A和B的天敌，A的猎物和B，<strong>A的猎人和B的猎物</strong>（容易被忽略）。</li>
</ul>
<p><strong>总结：</strong></p>
<ul>
<li>种类并查集是在维护不同事物间的一种<strong>关系</strong>。</li>
<li>编写时使用多倍长度的数组作为形容多种关系的<strong>媒介</strong>。</li>
</ul>
<p><strong>注意：</strong></p>
<ul>
<li>一个物品与另一个物品存在多个关系，在合并时要考虑所有关系的合并。</li>
<li>不同物品间一定要有连续性，也就是“都与A有同一种关系的东西应该是同一类”。</li>
<li>种类并查集只注重关系，到底哪堆人被分配到了哪个监狱不在考虑范围内。</li>
</ul>
<h2 id="带权并查集"><a href="#带权并查集" class="headerlink" title="带权并查集"></a>带权并查集</h2><p><a href="https://www.luogu.com.cn/problem/P1196">洛谷P1196 银河英雄传说</a></p>
<p>这道题看下来，其中合并和查询的部分使用普通的并查集就可以实现了，问题在于如何求出两个战舰之前的舰数。</p>
<p>不妨这样想，对于每个战舰$a_i$增加一个权值$d_i$用来表示此战舰与本列队头间的舰数，那么战舰$a_i$与$a_j$间的舰数即为$abs(a_i-a_j)-1$，元素带有权值即为带权并查集。现在要考虑的就是如何更新权值。</p>
<p>由于每次移动都是将一列舰队并到另一列的后方，那么对于被移动的那列舰队，所有战舰的$d_i$都应更新加上未移动的舰队的长度。由此发现，我们需要知道每队的长度来维护$d_i$，于是设每队的长度为$s_i$。</p>
<p>设x &#x3D; find(i), y &#x3D; find(j)，每一次移动，都有这样的变化：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">s[y]+=s[x];</span><br><span class="line">s[x]=<span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>要注意的是，这里修改的是两个战舰所在集合的长度。现在长度修改好了，还需要的是利用更新过的长度去更新被移动的所有战舰的$d_i$，这是带权并查集的关键所在。怎么变，一个一个变吗？那样的话效率就和爆搜没有区别了。带权并查集利用了find()函数中的路径压缩优化步骤，巧妙的在路径压缩的过程中更新了$d_i$的值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(in==<span class="string">&#x27;M&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">	d[x]+=s[y];	<span class="comment">//被移动舰队的标识战舰的di加上了长度</span></span><br><span class="line">	fa[x]=y;	<span class="comment">//合并，注意此时合并完的舰队的标志战舰已经变为了y，即树根</span></span><br><span class="line">	s[y]+=s[x];</span><br><span class="line">	s[x]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在一开始时，每列舰队只有1架战舰，因此每列的队头都是标识战舰（标识的意思看普通并查集），且<strong>合并操作不会改变这一规律</strong>。</p>
<p>合并操作完成后，本列舰队的标识战舰为y，同时我们称x战舰为“曾经的标识战舰”易。知$d_y &#x3D; 0$，而$d_x$被加上了$s_y$，由于在这一步操作前x始终为标识战舰，因此可知$d_x &#x3D; s_y$，可以看到整列被移动的舰队中只有它的$d_i$值被修改了。接下来看find()部分：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x==fa[x]) <span class="keyword">return</span> x;</span><br><span class="line">	<span class="type">int</span> root=<span class="built_in">find</span>(fa[x]);	<span class="comment">//首先执行find()的递归操作</span></span><br><span class="line">	d[x]+=d[fa[x]];			<span class="comment">//回溯时距离更新</span></span><br><span class="line">	<span class="keyword">return</span> fa[x]=root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先明确一点，find(x)的操作只会更新x追溯到他的标识战舰的$d_i$的值和这些点的路径。</p>
<p>我们可以想到，被移动的战舰到队头的距离 &#x3D; 该战舰到曾经的标识战舰的距离（即$d_i$） + 曾经的标识战舰到队头的距离（即$d_x$），而在find()函数向上追溯的过程中，一定能够找到曾经的标识战舰（因为存在路径压缩，所以一定是fa[x]），利用他的值更新自己的值。利用这一点，继续推想：假如曾经的标识战舰处于尚未更新的状态（出现这种情况的原因是因为上面所明确的那一点，也就是还尚未更新过），那么曾经的标识战舰向上追溯又一定能找到“曾经的曾经的标识战舰”，从而利用其值更新自己，后原战舰再根据更新好的曾经的标识战舰的值更新自己的值。由此得出，若想得到正确的曾经的标识战舰的$d_x$则必须要先执行递归find(x)，之后在回溯时更新距离。由于路径压缩的的存在，所有的战舰在更新一次$d_i$后父节点会直接指向最新的标志战舰，而$d_y &#x3D; 0$，从而在当前状态下再次寻找同一战舰时不再更新。这便是路径压缩与$d_i$更新的巧妙配合。</p>
<p><img src="/2021/03/30/%E5%B9%B6%E6%9F%A5%E9%9B%86/4.png" alt="img"></p>
<p><strong>代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> t;</span><br><span class="line"><span class="type">int</span> fa[<span class="number">30010</span>];</span><br><span class="line"><span class="type">int</span> size[<span class="number">30010</span>];</span><br><span class="line"><span class="type">int</span> d[<span class="number">30010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x==fa[x]) <span class="keyword">return</span> x;</span><br><span class="line">	<span class="type">int</span> root=<span class="built_in">find</span>(fa[x]);</span><br><span class="line">	d[x]+=d[fa[x]];</span><br><span class="line">	<span class="keyword">return</span> fa[x]=root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">char</span> s[<span class="number">2</span>];</span><br><span class="line">	<span class="type">int</span> a,b;</span><br><span class="line">	<span class="type">int</span> dx,dy;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">30000</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		fa[i]=i;</span><br><span class="line">		size[i]=<span class="number">1</span>;</span><br><span class="line">		d[i]=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;t);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=t;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%s%d%d&quot;</span>,s+<span class="number">1</span>,&amp;a,&amp;b);</span><br><span class="line">		dx=<span class="built_in">find</span>(a);</span><br><span class="line">		dy=<span class="built_in">find</span>(b);</span><br><span class="line">		<span class="keyword">if</span>(s[<span class="number">1</span>]==<span class="string">&#x27;M&#x27;</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			d[dx]+=size[dy];</span><br><span class="line">			fa[dx]=dy;</span><br><span class="line">			size[dy]+=size[dx];</span><br><span class="line">			size[dx]=<span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(s[<span class="number">1</span>]==<span class="string">&#x27;C&#x27;</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(dx!=dy) <span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>);</span><br><span class="line">			<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">abs</span>(d[a]-d[b])<span class="number">-1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.luogu.com.cn/problem/solution/P1525">https://www.luogu.com.cn/problem/solution/P1525</a></p>
<p><a href="https://www.luogu.com.cn/problem/solution/P2024">https://www.luogu.com.cn/problem/solution/P2024</a></p>
<p><a href="https://www.luogu.com.cn/problem/solution/P1196">https://www.luogu.com.cn/problem/solution/P1196</a></p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>OI 知识</tag>
      </tags>
  </entry>
  <entry>
    <title>归并排序</title>
    <url>/2022/02/11/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>归并排序（MERGE-SORT）是利用<strong>归并</strong>的思想实现的排序方法，采用了分治策略。</p>
<p>归并排序的效率稳定。</p>
<p><strong>时间复杂度</strong>：$O(nlog_n)$</p>
<h1 id="分治"><a href="#分治" class="headerlink" title="分治"></a>分治</h1><p><strong>分</strong>：将原问题分成一些小的问题。</p>
<p><strong>治</strong>：将分的阶段得到的各答案”修补”在一起。</p>
<p>本算法使用了递归实现分治，理论上迭代也可。</p>
<p><img src="/2022/02/11/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/1.png" alt="img"></p>
<h1 id="合并有序子序列"><a href="#合并有序子序列" class="headerlink" title="合并有序子序列"></a>合并有序子序列</h1><p>合并有序子序列，即<strong>治</strong>的操作。</p>
<p><img src="/2022/02/11/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/2.png" alt="img">、<img src="/2022/02/11/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/3.png" alt="img"></p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p><a href="https://www.luogu.com.cn/problem/P1177">模板题点我</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[<span class="number">100010</span>];</span><br><span class="line"><span class="type">int</span> temp[<span class="number">100010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">psort</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> i=l,j=mid+<span class="number">1</span>,k=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(i&lt;=mid||j&lt;=r)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(i&lt;=mid&amp;&amp;j&lt;=r)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(a[i]&lt;=a[j]) temp[++k]=a[i++];</span><br><span class="line">			<span class="keyword">else</span> temp[++k]=a[j++];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(i&lt;=mid) temp[++k]=a[i++];</span><br><span class="line">			<span class="keyword">else</span> temp[++k]=a[j++];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	k=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=l;i&lt;=r;i++) a[i]=temp[++k];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">msort</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(r-l&gt;<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">msort</span>(l,mid);</span><br><span class="line">		<span class="built_in">msort</span>(mid+<span class="number">1</span>,r);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">psort</span>(l,r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">msort</span>(<span class="number">1</span>,n);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,a[i]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.cnblogs.com/chengxiao/p/6194356.html">https://www.cnblogs.com/chengxiao/p/6194356.html</a></p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>OI 知识</tag>
      </tags>
  </entry>
  <entry>
    <title>快速幂</title>
    <url>/2022/03/23/%E5%BF%AB%E9%80%9F%E5%B9%82/</url>
    <content><![CDATA[<p>快速幂是一种让计算机快速算出$a^b$的算法。</p>
<p>时间复杂度$O(\log b)$</p>
<p><strong>原理：</strong></p>
<p>任意一个十进制数都可以写成$\sum 2^i(i为本数二进制下为1的位的位数-1的)$的形式，这是由十进制与二进制间的转换得来的，如$4_{10} &#x3D; 100_{2} &#x3D; 2^2$、$7_{10} &#x3D; 111_{2} &#x3D; 2^2 + 2^1 + 2^0$、$19_{10} &#x3D; 10011_{2} &#x3D; 2^4 + 2^1 + 2^0$。我们将这种变化应用到$b$上，将原式变形：</p>
<p>$$<br>a^b &#x3D; a^{\sum 2^i} &#x3D; \prod a^{2^i}(i为b二进制下为1的位的位数-1)<br>$$</p>
<p>即对于代码来说，不断的找到$a^{2^i}$的值进行连乘就可以求得答案，因此我们需要一个简单有效的方法递推$a^{2^i}$的值。</p>
<p>当$i &#x3D; 1,2,3,…,n$时，易得到递推$a^{2^{i + 1}} &#x3D; {a^{2^i}}^2$。同时伴随的问题便是，$i$为本数二进制下所有为$1$的位的位数$-1$的数组，显然前面的定义大于这个数组，因此要增加一个判定条件，确定$b$的二进制的$i + 1$位是否为$1$。若是，则进行连乘，反之跳过。</p>
<p><strong>代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">fpow</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> ans=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(b&gt;<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(b&amp;<span class="number">1</span>==<span class="number">1</span>) ans*=a;</span><br><span class="line">		a*=a;</span><br><span class="line">		b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>OI 知识</tag>
      </tags>
  </entry>
  <entry>
    <title>想法</title>
    <url>/2022/06/06/%E6%83%B3%E6%B3%95/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="86452d66917e5f9e67e48d4a74d9d52b9a6c313d9f91a4dc6566abd49126bda3">6fcf1523ddce79b7eefea9a75525b524c27790844feebdcc97655127d1eee6c505fa73c61008d84c6a8a6b02d2420be85b8718f9bdf7688a021d33a494a0404a59139d5bd7cfdc48b51a4b1f14a01f5690909880e20c1fac96d0dd0d78a56d9f29af5343d8e99a0a39c328665280509aca20c079bbc1f82d4ceb2d131dc55ce09a0f19165a4146570782354bc9a2de7bb128bdd8a2a8df5d59fb82519b3eb2991f88ca6bdb7f1dc964d01c38d72cea6a258b16789664d69d451d206b1b0df189fbc40f56f549cde17bb7236f28d5077a9406b92e7353727f2fa5cfbdcffea423edea411f5962c8acd43674141e8b9bd3c7aea9ce6d0f7bfb4674da1f0c603f7b73398979c44a6fef482481a954af40a05d68b663fb90f3ad043626e2dbbe17784bd6280e4a434bdbdeb8f438e7dc8cc14ef2e4292c170f4221329978637c98f314531dbf0c88e4a25b0a83f6fc07d61983082800952a9932822a98d0915287977416f3c1d49eb5a8fde0cd8b3b28d349875b69d00d2bc9434dc7d247c603dee2d92fff93ca1388b63ad37b43ef79ce1c53cc7432a595c60941963407ca0cac724ae5509905c9143275d879fa9f9a1a65335938b990b4039f85a2d646e3d3b81b65b511d7d565930220b7f007da0b1e5062b0275b3053dc70cc205790093a85d05bcae4c2367031044a99841d936ace0daf85798c5085d74c12baa5bd020eaedbb2a89b2cc292c6248d0515f2047a05a9792ebb7b029c39a818f24959b3694052b879b921c0d8aae3ed16a08ebd5de234cd79d7f7c79cf46a2586b818e9df858e80f0e49fc436178cc2ed53375f14c3b460cadf1ac91cb8eb484dc101b70aaec64235393cbc1bd135214ed73a8bb9a75bdc384e631c717925c1e4751b13a047a88a3377f35bbabd48164ba697bdff23b030c5e0a1f278ca065506bdf017e732a68f4650e15fe0fc950f64b58c91d061f96a23acb311aef446b9d3b097fc2f169dd800c112084a1df095fabf6423a8bffaad45322473b6c6b4afe7b88e721c98870b1a6e289776d9baa9baa68a431c61b8b89cd5679c58210e00c836baf65faa9b9def6b2de23f6cf9e63782dc75a3b681e5889969bda1ee62b94c0791e3d14190f04d3a113a605029cccec68c2fe31be4f47f6fe94f7e722da7dd90b555a25616308d6ad799f8a05274efe7471770a4df144cbb4d35c8c745b913f25a3cf0e76b9c24e0792d841f5a70a8d760c8dd803e921688550c8f9db88950c7ab3da7d71633e00045697f24a59edbed6a3712b2b4e4058bc3402be00d31b12b8311dd789ce7bc245aa13dc11895d9386783703ebbf3a0ee2d51217f90516d6c1fc663d23cf5b53065c7b0991cbd2adc2b0fff6d68e9c360a00ba2a6bf6a79c9e050c35e75aeee5b729f282e8e9a5fdf9d28a8b39eef2571be557fb49a2614e37d742772f39ef52cc7d16ccbbf52229f9336fdb62f613b521884401633ff5c09192b5c8ad96d821fa3d2bc1eda9f06ba49b38ecdf24414e782c1154171713557825f7463962ac585eaf4150a092db9557ae783b83c5280ef87e3fceb6d4e6d75aa21ea3f89a6c9fb041a2a3de67014c3b6f676092e35e308d15a249fda1ef6505c4f64d2112fee97d4d07c5d54989536734401fec96d8bd2def16bb20f3aad392478d05d0a1fab4c5d34960115a1cd36e6732471428a47fd4c7234a8c9ecd7300e886fd2182cc6b7352290948ca236e20e0e4ec7d2dcbde2fd13a88761d1f423afd3e8454bbb50b563996fde799d2a478226422b2b8f0992af80d43486d9f143abbf5220d6995da476e8455612e7c9d8828bb21b8f</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>日常</category>
      </categories>
  </entry>
  <entry>
    <title>打了一个数学建模校赛</title>
    <url>/2022/05/23/%E6%89%93%E4%BA%86%E4%B8%80%E4%B8%AA%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E6%A0%A1%E8%B5%9B/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="001a0245037260f819133edd593b7365597729c2f7f9710895b441e7a2abaf8e">6fcf1523ddce79b7eefea9a75525b52456aa6a5c9c524aa70c0a88cdedf99703afb514a4326fca45193d5abe3812f0fd558c3fa39c56c370ddf8aae4e6fbb0b785831b68c4c595e8ddb10e6d5fdc67e662ecf00bf63bf2036e5a255ce171494be1068bfbf176d17cccef4c298588b81766d030274ce7d49b4c7b55d323876b90903df3b47106b302c3570f3cf3411834b0c1c0b25edddea4060427cbfcbddfe932de5585e225d61478c19e6284a31d3fc040af16dd81321a39ac5d187313ecf216264cd7d669042f28ab83b73dc98d9120d9edaae7b0c8c4b4284432316d1e6fb36bb0f0ac862ae5f2b3a4bbc8b09ca4d27b635adae9e4471ca07e077c1b8104c9bf37282b2dd5524bb6ae89dc7a0f7b567ca356e72341966ce4b05fd08acfc211ad9180762c6e7307312a46a223e03b8296d3524cc80c709ed09708027182660272b9e9d650c2cd5f6a7668934e6a5912afc2d911d73381913fba12777db3d7858e70db0fefe1780d85be530d18be997ac3cf42e26ad548914b30b6d49eeb0df539a5c6923905c8ce82e870a9ed617a5a7825b392a310d0826e5a534ce9fa1972d453631293526605b7b0dee7975ad5a530daf5e3361cd8cf180f968cbf89ef37601b573f1a93317d76616ca7bf1b37ac170cd6517e27b7ae94ea83ea12c0688831d9b6e083ecabc1c5c9a7e8aaa40782418c84e0c4e6fd3de74b249bb3327c485e5fe72929fa40bdabbe82f4928fea2804f426b99ca00420f1f0f2ac8425b779a630c88732898e38219743b57c2b8164fd40cdcfe24ed763c57dc4c5f519f1579e7c3c249c8aa6b3ffdf47139717149355da2f087a51128bcadc5d652e81ede8ad0c61cb8e087c3a498adedca01d9960e2dc41e55743708a0a17657dfa85d1ed0b904a24e5152a99478e8270b6d6da6f4b498d76bbd4849f350ece4b1ce67568b2a04da69a3302c174b905773e9e9449a3f6033c799f7198819569ae49f5433e870bdd6356ce62e5312b7ac25d9bb270f058cb38b08634cc72183442de7f2b28049111210681f805941b3304ccb1c6e41c694ef343cc185cc96403233711b5815011df6fa1da4041d349656214b40593059336d9978d6aed6cd329dac42c2f09738a3086fc569af8e531d7d0d7ed4b236de73e2dfdd008ac81fbc7cb34f92d4a6ad4d8b879e0e8cd06245eaa0239ec8950b7322b6bee4928265cb442dc77260f03c7c0d4fabad8b6ee427438b657d1194285ccc2b845bfebf3bfd2caedb2cc26238c119cf387b48b563a58a3a61d39d8e681fa14c3e09c18ab4a0476099085140442869a287d8ddbb84fcc9b890c197d51c16a3b211490888206acfee3d3efc2da997896e34882faadbdd878a65cf750af91e11ef9e1fb3004907e24eb00da9b839c0c13c79037bf8948c055749522aad9d82e37eb8e72bf8ac3a311f31e0333a8e03bd6769af5337880be5c6ced5d1541a60378f8b37da5d91173ae170078cc724896c8211df8f79d6e6bda46ed7c91abbf86ef1fc1e76cadecf70d4e6a1dc6db7bf266ebc01b1181c4acee71a2713e2ead7810a814196d95e9d6ff4aee82bc218d8db7b6a84e6e0f3457abc92b4af424909dab85350f8fa73b0f7a25e2864bef39e35a4b02d56027eea28620bf4c7ef47e4520c78995d6193b26a09dbfcb964089afa57f78489a31e1340da4843f4f34f1255a5dced462a6aba7afcc2d1c4f6575e1290a0ffc65018db4eb51412bbac1fb1f22f66fd14e31dd4b0e4351c1ec1770a492f43d545424df3c50d68259bed49d633d7eeffcd3b9fa96480f56343fa3dfb7e5581641cc12c1562105ccfd6509c00c2d4442b3a3e7245c9627f84c10e89b5994a01450b5bdf45afb5e14cfb645d90e541c5d2c2c38fe74d97d4678705798731fa9e8bf474654967c274664905026367a8fa7db61cc7b1ac7fb3899fd3a2b0889f0e48772271febbae66a79e99c3b04e3e9cb57c06ae1291ea3870c539cee36794dea553a133d2701ec85c18e63e53245efed31f2f58c320a4f1ca7bc13e78eb46dc59212ed6dc98389b4bdcc1c21d8169ab6211ea5b5974fb16382932e42bd07ea06de59d7f11d7ed9f80d7d5fa7f0997a061af4835440c1eb70f484c95a5dd029a7152f1f8581f3041a21</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>数学建模竞赛</tag>
      </tags>
  </entry>
  <entry>
    <title>插值和拟合</title>
    <url>/2022/02/09/%E6%8F%92%E5%80%BC%E5%92%8C%E6%8B%9F%E5%90%88/</url>
    <content><![CDATA[<p>插值和拟合是数学建模中一种基本的数据分析手段。</p>
<p><strong>插值：</strong>已知函数在某区间（域）内若干点处的值，求该函数在该区间（域）内其它点处的值。</p>
<p><strong>拟合：</strong>根据离散数据求数据间近似函数关系。</p>
<p><strong>区别：</strong></p>
<ul>
<li>插值函数过已知点，拟合函数不一定过已知点。</li>
<li>插值主要用于求函数值，拟合主要用于求函数关系，从而进行预测等进一步分析。</li>
</ul>
<p>当然，某些特定问题既可以用插值也可以用拟合。</p>
<h1 id="插值"><a href="#插值" class="headerlink" title="插值"></a>插值</h1><p>已知函数在某区间（域）内若干点处的值，求该函数在该区间（域）内其它点处的值。</p>
<p>常用的有拉格朗日（Lagrange）插值法和牛顿（Newton）插值法。</p>
<h2 id="拉格朗日插值法"><a href="#拉格朗日插值法" class="headerlink" title="拉格朗日插值法"></a>拉格朗日插值法</h2><p>在节点上给出节点基函数，然后做基函数的线性组合，组合系数为节点函数值的一种插值多项式。</p>
<p>$$<br>f(x) &#x3D; y_1 f_1(x) + y_2 f_2(x) + y_3 f_3(x)<br>$$</p>
<p>$$<br>f(x) &#x3D; \sum^k_{i&#x3D;0} y \prod {x - x_j \over x_i - x_j}<br>$$</p>
<h2 id="高次插值的Runge（龙格）现象"><a href="#高次插值的Runge（龙格）现象" class="headerlink" title="高次插值的Runge（龙格）现象"></a>高次插值的Runge（龙格）现象</h2><p>插值多项式的次数超过七时，插值多项式会出现严重的震荡现象，称之为Runge现象。</p>
<p>因此，在实际中不应使用七次以上的插值。</p>
<p>避免的常用方法：将插值区间分成若干小区间，在小区间内使用低次（二次，三次）插值，即分段低次插值，如样条函数插值。</p>
<h2 id="Matlab一维插值"><a href="#Matlab一维插值" class="headerlink" title="Matlab一维插值"></a>Matlab一维插值</h2><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">yi = interp1(x, y, xi, <span class="string">&#x27;method&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>x，y为插值点，xi，yi为被插值点和插值结果，四者通常为向量。</p>
<p>‘method’表示插值方法：</p>
<ul>
<li>‘nearest’：最邻近插值</li>
<li>‘linear’：线性插值</li>
<li>‘spline’：三次样条插值</li>
<li>‘cubic’：立方插值</li>
<li>缺省：线性插值</li>
</ul>
<p><strong>例子：</strong></p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">x = <span class="number">0</span> : <span class="number">2</span>: <span class="number">24</span>;</span><br><span class="line">y = [<span class="number">12</span> <span class="number">9</span> <span class="number">9</span> <span class="number">10</span> <span class="number">18</span> <span class="number">24</span> <span class="number">28</span> <span class="number">27</span> <span class="number">25</span> <span class="number">20</span> <span class="number">18</span> <span class="number">15</span> <span class="number">13</span>];</span><br><span class="line">x1 = <span class="number">13</span>;</span><br><span class="line">y1 = interp1(x, y, x1, <span class="string">&#x27;spline&#x27;</span>);</span><br><span class="line">xi = <span class="number">0</span> : <span class="number">1</span>/<span class="number">3600</span> :<span class="number">24</span>;</span><br><span class="line">yi = interp1(x, y, xi, <span class="string">&#x27;spline&#x27;</span>);</span><br><span class="line"><span class="built_in">plot</span>(x, y, <span class="string">&#x27;*&#x27;</span>, xi, yi)</span><br></pre></td></tr></table></figure>

<h2 id="Matlab二维插值"><a href="#Matlab二维插值" class="headerlink" title="Matlab二维插值"></a>Matlab二维插值</h2><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">zi = interp2(x, y, z, xi, yi, <span class="string">&#x27;method&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>x，y，z为插值点，xi，yi为被插值点，zi为输出的插值结果。</p>
<p>x，y为向量，xi，yi为向量或矩阵，z，zi为矩阵。</p>
<p>‘method’表示插值方法：</p>
<ul>
<li>‘nearest’：最邻近插值</li>
<li>‘linear’：双线性插值</li>
<li>‘spline’：双三次样条插值</li>
<li>‘cubic’：双立方插值</li>
<li>缺省：双线性插值</li>
</ul>
<p><strong>例子：</strong></p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">x = <span class="number">1</span> : <span class="number">5</span>;</span><br><span class="line">y = <span class="number">1</span> : <span class="number">3</span>;</span><br><span class="line">temps = [<span class="number">82</span> <span class="number">81</span> <span class="number">80</span> <span class="number">82</span> <span class="number">84</span>; <span class="number">79</span> <span class="number">63</span> <span class="number">61</span> <span class="number">65</span> <span class="number">81</span>; <span class="number">84</span> <span class="number">84</span> <span class="number">82</span> <span class="number">85</span> <span class="number">86</span>];</span><br><span class="line"><span class="built_in">figure</span>(<span class="number">1</span>);</span><br><span class="line">mesh(x, y, temps);</span><br><span class="line">xi = <span class="number">1</span> : <span class="number">0.2</span> : <span class="number">5</span>;</span><br><span class="line">yi = <span class="number">1</span> : <span class="number">0.2</span> : <span class="number">3</span>;</span><br><span class="line">zi = interp2(x, y, temps, xi, yi&#x27;, <span class="string">&#x27;cubic&#x27;</span>);</span><br><span class="line"><span class="built_in">figure</span>(<span class="number">2</span>);</span><br><span class="line">mesh(xi, yi, zi);</span><br><span class="line"><span class="built_in">figure</span>(<span class="number">3</span>);</span><br><span class="line">contour(xi, yi, zi, <span class="number">20</span>, <span class="string">&#x27;r&#x27;</span>);</span><br><span class="line">[<span class="built_in">i</span>, <span class="built_in">j</span>] = <span class="built_in">find</span>(zi == <span class="built_in">min</span>(<span class="built_in">min</span>(zi)));</span><br><span class="line">x = xi(<span class="built_in">j</span>), y = yi(<span class="built_in">i</span>), zmin = zi(<span class="built_in">i</span>, <span class="built_in">j</span>)</span><br><span class="line">[<span class="built_in">i</span>, <span class="built_in">j</span>] = <span class="built_in">find</span>(zi == <span class="built_in">max</span>(<span class="built_in">max</span>(zi)));</span><br><span class="line">x = xi(<span class="built_in">j</span>), y = yi(<span class="built_in">i</span>), zmax = zi(<span class="built_in">i</span>, <span class="built_in">j</span>)</span><br></pre></td></tr></table></figure>

<p>xi为行向量，yi为列向量</p>
<p>plot3（空间曲线），mesh（空间曲面），surf（空间曲面），contour（等高线）是三维作图中的常用命令。</p>
<p>mesh和surf的区别：mesh是曲面网格图，surf是曲面表面图。</p>
<p>contour(x, y, z, n)是做出由点(x, y, z)插值而成曲面的n条等高线。</p>
<p>meshc和surfc可在曲面下方画等高线。</p>
<p>meshz和surfz是画垂帘图。</p>
<p>程序最后部分为求最高（低）点。</p>
<h2 id="Matlab散乱点插值"><a href="#Matlab散乱点插值" class="headerlink" title="Matlab散乱点插值"></a>Matlab散乱点插值</h2><p>前面的插值点(x, y)均为网格点。当点为散乱点时使用本方法进行二维插值。</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">griddata(x, y, z, xi, yi, <span class="string">&#x27;method&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>例子：</strong></p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">x = [<span class="number">129</span> <span class="number">140</span> <span class="number">103.5</span> <span class="number">88</span> <span class="number">185.5</span> <span class="number">195</span> <span class="number">105.5</span> <span class="number">157.5</span> <span class="number">107.5</span> <span class="number">77</span> <span class="number">81</span> <span class="number">162</span> <span class="number">162</span> <span class="number">117.5</span>];</span><br><span class="line">y = [<span class="number">7.5</span> <span class="number">141.5</span> <span class="number">23</span> <span class="number">147</span> <span class="number">22.5</span> <span class="number">137.5</span> <span class="number">85.5</span> <span class="number">-6.5</span> <span class="number">-81</span> <span class="number">3</span> <span class="number">56.5</span> <span class="number">-66.5</span> <span class="number">84</span> <span class="number">-33.5</span>];</span><br><span class="line">z = [<span class="number">-4</span> <span class="number">-8</span> <span class="number">-6</span> <span class="number">-8</span> <span class="number">-6</span> <span class="number">-8</span> <span class="number">-8</span> <span class="number">-9</span> <span class="number">-9</span> <span class="number">-8</span> <span class="number">-8</span> <span class="number">-9</span> <span class="number">-4</span> <span class="number">-9</span>];</span><br><span class="line">[xi, yi] = <span class="built_in">meshgrid</span>(<span class="number">75</span> : <span class="number">0.5</span> : <span class="number">200</span>, <span class="number">-70</span> : <span class="number">0.5</span> : <span class="number">150</span>);</span><br><span class="line">zi = griddata(x, y, z, xi, yi, <span class="string">&#x27;cubic&#x27;</span>);</span><br><span class="line"><span class="built_in">figure</span>(<span class="number">1</span>);</span><br><span class="line">meshz(xi, yi, zi);</span><br><span class="line">xlabel(<span class="string">&#x27;X&#x27;</span>), ylabel(<span class="string">&#x27;Y&#x27;</span>), zlabel(<span class="string">&#x27;Z&#x27;</span>);</span><br><span class="line"><span class="built_in">figure</span>(<span class="number">2</span>), contour(xi, yi, zi, [<span class="number">-5</span> <span class="number">-5</span>], <span class="string">&#x27;b&#x27;</span>);</span><br><span class="line">grid;</span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line"><span class="built_in">plot</span>(x, y, <span class="string">&#x27;+&#x27;</span>);</span><br><span class="line">xlabel(<span class="string">&#x27;X&#x27;</span>), ylabel(<span class="string">&#x27;Y&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h1 id="拟合"><a href="#拟合" class="headerlink" title="拟合"></a>拟合</h1><p>根据离散数据求数据间近似函数关系。</p>
<h2 id="拟合的计算"><a href="#拟合的计算" class="headerlink" title="拟合的计算"></a>拟合的计算</h2><p>曲线拟合需要解决两个问题：</p>
<ul>
<li>线型的选择</li>
<li>线型中参数的计算</li>
</ul>
<p>线型的选择是拟合计算的关键和难点，通常主要根据专业知识和散点图确定。</p>
<p>线性拟合中参数的计算可采用最小二乘法，非线性拟合中参数的计算要应用Gauss-Newton迭代法。</p>
<h2 id="Matlab多项式拟合"><a href="#Matlab多项式拟合" class="headerlink" title="Matlab多项式拟合"></a>Matlab多项式拟合</h2><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">[a, S] = polyfit(x, y, n)</span><br></pre></td></tr></table></figure>

<p>x，y是被拟合数据的自变量和因变量。</p>
<p>n为拟合多项式次数。</p>
<p>a为那你和多项式系数构成的向量。</p>
<p>S为分析拟合效果所需的指标（可省略）。</p>
<table>
<thead>
<tr>
<th align="center">参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">x</td>
<td>被拟合数据的自变量</td>
</tr>
<tr>
<td align="center">y</td>
<td>被拟合数据的因变量</td>
</tr>
<tr>
<td align="center">n</td>
<td>拟合多项式次数</td>
</tr>
<tr>
<td align="center">a</td>
<td>拟合多项式系数构成的向量</td>
</tr>
<tr>
<td align="center">S</td>
<td>分析拟合效果所需的指标（可省略）</td>
</tr>
</tbody></table>
<p><strong>例子：</strong></p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">x = <span class="number">1</span> : <span class="number">12</span>;</span><br><span class="line">y = [<span class="number">5</span> <span class="number">8</span> <span class="number">9</span> <span class="number">15</span> <span class="number">25</span> <span class="number">29</span> <span class="number">31</span> <span class="number">30</span> <span class="number">22</span> <span class="number">25</span> <span class="number">27</span> <span class="number">24</span>];</span><br><span class="line">a = polyfit(x, y, <span class="number">9</span>)</span><br><span class="line">xp = <span class="number">1</span> : <span class="number">0.1</span> : <span class="number">12</span>;</span><br><span class="line">yp = polyval(a, xp);</span><br><span class="line"><span class="built_in">plot</span>(x, y, <span class="string">&#x27;.k&#x27;</span>, xp, yp, <span class="string">&#x27;r&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="Matlab非线性拟合"><a href="#Matlab非线性拟合" class="headerlink" title="Matlab非线性拟合"></a>Matlab非线性拟合</h2><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">[b, r] = polyfit(x, y, fun, b0, option)</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">x</td>
<td>被拟合数据的自变量</td>
</tr>
<tr>
<td align="center">y</td>
<td>被拟合数据的因变量</td>
</tr>
<tr>
<td align="center">fun</td>
<td>拟合函数</td>
</tr>
<tr>
<td align="center">b0</td>
<td>拟合函数的初始迭代值</td>
</tr>
<tr>
<td align="center">option</td>
<td>拟合选项</td>
</tr>
<tr>
<td align="center">b</td>
<td>拟合参数</td>
</tr>
<tr>
<td align="center">r</td>
<td>拟合残差</td>
</tr>
</tbody></table>
<p><strong>例子：</strong></p>
<p>$$<br>找好的关系式：y &#x3D;A_1 e^{-x \over t_1} +A_2 e^{-x \over t_2} + y_0<br>$$</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">x = <span class="number">1</span> : <span class="number">16</span>;</span><br><span class="line">y = [<span class="number">4.00</span> <span class="number">6.40</span> <span class="number">8.00</span> <span class="number">8.80</span> <span class="number">9.22</span> <span class="number">9.50</span> <span class="number">9.70</span> <span class="number">9.86</span> <span class="number">10.00</span> <span class="number">10.20</span> <span class="number">10.32</span> <span class="number">10.42</span> <span class="number">10.50</span> <span class="number">10.55</span> <span class="number">10.58</span> <span class="number">10.60</span>];</span><br><span class="line">y1 = @(b, t)b(<span class="number">1</span>) * <span class="built_in">exp</span>(-t / b(<span class="number">2</span>)) + b(<span class="number">3</span>) * <span class="built_in">exp</span>(-t / b(<span class="number">4</span>)) + b(<span class="number">5</span>);</span><br><span class="line">b0 = [<span class="number">-1</span> <span class="number">1</span> <span class="number">-1</span> <span class="number">1</span> <span class="number">0</span>];</span><br><span class="line">a = nlinfit(x, y, y1, b0)</span><br><span class="line">xp = <span class="number">1</span> : <span class="number">0.1</span> : <span class="number">16</span>;</span><br><span class="line">yp = y1(a, xp);</span><br><span class="line"><span class="built_in">plot</span>(x, y, <span class="string">&#x27;.k&#x27;</span>, xp, yp, <span class="string">&#x27;r&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="Matlab拟合工具箱"><a href="#Matlab拟合工具箱" class="headerlink" title="Matlab拟合工具箱"></a>Matlab拟合工具箱</h2><p>使用Matlab编程进行拟合不便：</p>
<ul>
<li>需要编程。如匿名函数等。</li>
<li>拟合结果不完整。Matlab拟合命令一般只提供拟合系数等基本结果。若要获取表示拟合优劣的统计量有时需要另外计算。</li>
</ul>
<p>因此使用Matlab拟合工具箱。</p>
<p><strong>工具箱的启动：</strong></p>
<p>在命令窗口键入cftool。</p>
<p><strong>数据的录入：</strong></p>
<p>在命令窗口录入自变量x和函数y的数据，然后再Data菜单中即可选中上述数据，并产生Data sets。</p>
<p>此时工具箱会自动画出散点图。</p>
<p><strong>拟合：</strong></p>
<p>点击Fitting -&gt; New fit，可以修改Fit name，选择Data sets（自动）和Type of Fit。</p>
<p>Apply后即可完成拟合。</p>
<table>
<thead>
<tr>
<th align="center">名称</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Custom Equations</td>
<td>用户自定义的函数类型</td>
</tr>
<tr>
<td align="center">Exponential</td>
<td>指数逼近，2种，a * exp(b * x)、a * exp(b * x) + c * exp(d * x)</td>
</tr>
<tr>
<td align="center">Fourier</td>
<td>傅里叶逼近，7种，基础型是a0 + a1 * cos(x * w) + b1 * sin(x * w)</td>
</tr>
<tr>
<td align="center">Gaussian</td>
<td>高斯逼近，8种，基础型是a1 * exp(-((x - b1) &#x2F; c1)^2)</td>
</tr>
<tr>
<td align="center">Interpolant</td>
<td>插值逼近，4种，linear、nearest neighbor、cubic spline、shape-preserving</td>
</tr>
<tr>
<td align="center">Polynomial</td>
<td>多形式逼近，9种，…</td>
</tr>
<tr>
<td align="center">Power</td>
<td>幂逼近，2种，…</td>
</tr>
<tr>
<td align="center">Rational</td>
<td>有理数逼近，分子分母共有的类型是linear、quadratic、cubic、4-6th degree；此外分子还包括constant型</td>
</tr>
<tr>
<td align="center">Smoothing Spline</td>
<td>平滑逼近（翻译不太恰当）</td>
</tr>
<tr>
<td align="center">un of Sin Functions</td>
<td>正弦曲线逼近，8种，基础型是a1 * sin(b1 * x + c1)</td>
</tr>
<tr>
<td align="center">Weibull</td>
<td>只有一种，a * b * x^(b - 1) * exp(-a * x^b)</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>数学建模竞赛</tag>
      </tags>
  </entry>
  <entry>
    <title>收藏夹清理计划</title>
    <url>/2022/06/12/%E6%94%B6%E8%97%8F%E5%A4%B9%E6%B8%85%E7%90%86%E8%AE%A1%E5%88%92/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="4697aac375d73ce24579c7238134185763a3c30a6501b3904f54bc6c26838088">6fcf1523ddce79b7eefea9a75525b5243f08a75f6b09a0fd512a46cfd7edd7abd27142abe5fb9fc6a974b0e4ead151e599dab868ff292c96abaf7644a0cd7d362bc1aeb354c086bd306c08125bb5fe3af7ad3fe5d318e4f6e4dc30e70cd2f68d4ea762ecda02d3ac59c40eb87f7c76f524543e94fc8cd89bfce2a6f4dda43a69b115c7305212e996abcf4d578360ca676de77cea341cc17b7c7361a43c163419ca9f24629a75bac18444a9e06d690c2dac857ef7dbde2557b71cdbf6e5ff3afed64f76a845d57f129ff157792cdf611d87e3cc55b1770447dfe4a02ff8ef1d5c7c08e956438252d48785ea65c9b6a7872c5f4d4c46c9906f84976f070cf3039385c7ad2f0ac337b4415e091f8e13880741e735e073b566032b64d867d8ab6eece6682c666c51d6e177ec21060f2fa9cc6d0f7d8f64a3418ecfa198897620a081d9e1cb16c6493f9b898318c904bcf194d7177765a2e43b21812787c3adac9c26d0e182f90e62449d2a676e99f4a739dcbd3c05e613ce5982528ac35c40e4c4d451e1df37fa166870909339f4762f48e9525c9ce47bac8ada65a1429be93bda58110afc0c2da8f1cd61c8a7dead3c4f08a553ad474225db792a431d05bc1c235eaeee2877a0d55d846246f9e3c0102b5c10826552cc10f98511024b5f944ffddbd39495a8b53f4bb11b67b9577a8ea6522aa908c8218bbbd3c1d316866d0aac7a2174f4fa488bd33fb62f1fa2aaccf20014dc4ff54368928977033e6de00a649327dc243689a4ff55542aedc834e5815f0eb3881b6695547092b0aa89be9866816a5eb1c89079282dce0757991816658f91c1f7cc75cb2acfeaff76d8e33e937fe5014aac6fef0d81c6a189c193ffb2f2e138f35f4f00a119b515c146dd1ecd8634bcb49a741b9c343daa7c1adde42826c7764bb38a439ad059571696ecdbffc64101b07c42ac76cf4ccd35c626c6bb363fd41f04581a0dc44a3f158e6461c0e49d29cf756203f063183610d3251bae64c03e8d0b7dbc81fe50ed637ed39e8c12cbbd69ae58bd5be00fdbc67a91a387f152ea6453a777fd58a725690e5046a2653d01beac581709def8ac10709a69928eec445c633eddee67d35f71a24e2ae278854dfb5fd45057b17ff815fdf9412d3a3e13836e59007621775706ab7bcb38a52050870009045a24638c5510ecd379c595db21aa9f6842cb8d2ca68705e7c1e745c8a3637856b78269addbbd90f482feefe64d2e1a7c5d09cb155ed7e78b566a60dc6ac3cee212bd36fe2f28d3a6df125b65ca9bef6b04c6e872715f5091a01e485e9faded32f2700094750071730061f227aad5d5fee9a4d04de704a5f8bdf309ea2cd03ef11aae034be3fb5d106ee93e0b89243a700e3c624c8cfc4a711979b6699e941e2d3b4e4a28fe927ded549225ad38819a90cf516f868e6a500e9cdec915920ffd0b323219570110127f831679f6d6cb72986bacd60e7c4a4bcbd6142d4da33e2156a57ea8ebcf81d0efd14c337f45e71caadaa49c6ba98f2d8fbbbeff10fe2881b26442ec13df6cc19f5b74235699f226480a82844615df627fa5f6</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>日常</category>
      </categories>
  </entry>
  <entry>
    <title>日记：熬夜、科三</title>
    <url>/2022/07/08/%E6%97%A5%E8%AE%B0%EF%BC%9A%E7%86%AC%E5%A4%9C%E3%80%81%E7%A7%91%E4%B8%89/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="2df9d79dd6a1096327dd2832c5ebf26b3a8239614f4df3aae508f4d186abe345">6fcf1523ddce79b7eefea9a75525b5241b9894898e486f05b565d7c464f992d3c42e0cab048e061da2865e7159a6d2bd8e544652a065fa12c16a0fa3ca79e9c905a502f66036c3508230fad007d77da9284d7d13ca8570e1210388484ddd152b69602bbe0fb93f3099161fba65ceffe6c997372aeb641809487c1763b9f1ebc20affaf82a626e385eb07844f345f6020db881224c0d6086aef43d7913c1f10ad0823333fe48af5f541d8cb6af3d80dc2f8d69227a5dc1dc0b8e52939acc2c1fad8ab8c0ac229db36043dfc1822fd47652b81cbaa345cb0d4d7a06d5ba8a1701a3ad02a31ecdb82e3c2c5f65df264702037443237d52797ff2a4897f420c2453de7862bd70e23ab11449e8427bc05d1fc5fda45f6145f982559ac20dab858dd0878d678bd4864c1b62bbc9ee16bb5550cac6ed3733c70709065be6dfc3cca8cfd4c24f1b2fa8ba8b49eff2001117a24889fce8736ea73d4b3551178199eb347a7e24a1bda58325d1b998ee9089f86eb0c932195e01ab3047c1ec8c05cc776b02eff61d5aca530e82ed9260df2ba5933794f6c3fc74280c7ac9981df3e537b9adf2de8264de4d6274c2afb52abde8ac9939df5ecb38fff361f617e7eb08dac37efae1ca783dddee173eaa3f75514c9e468ff7adb78e01c84051555ca4f76acd92cd5ea52ff1e9dcddeab38c42f64f0b33b63e10e3c6a88b003d89ad754b9eba826f6503f67d1b116ddc60acbd5a21083cc704a3e0c75b569c09ec938cf84614a7df04ee96c1172e26dbf77e99bea1c3a4ba067c9d4a3c5e7cce0fec166aff2a6e6c24a2f3dee965baa07bf85f8f605f0c845c7da8827ee966345e2cb4a65086100310a6f67de8fdd2a9430b64d540879a731defef89348f6dfd658e22ba8b60bdb09e4743dab47f652c05b7dd17cacb86df938eecb8e4fdb8c8a1223d6119727dbc7d280d930be4a2706be5149a8b653195a1a51a9d3883ebd874084d71d46edd9f428cc00947f947219cebde9b9f63f39d6dd6589c8e38136d3e44aa5cb5eccb3d1e153822c12b061409ed6167783c49bf3bd06338003aabb010749e4d7dc8e7688ac5c1fde39c46194a83251211a43624c1148a8739d1b05a69eb1658df59e258fdd5dd0ca1166d4f2c024e0ba902b4c1c70b1a6c3f333d5336ca8c2d4a8980c9b02004a5e1167d948b8f25bafed217b39dd44607eda3e2d6879d2506f6b26e166377c570933807ae5bd8d237db7f7787445931e463a475ee8cba647c432f0a4e8a57227869b1e522c66dbf02717c23cdc9961be4f8e8b679aa4489f605202190c19fff2b570907bc879d9b85ac1f1c410664b4870a265b9486ea3fb12d44e74fe58d62c5b0568751fb01ec7de57138250ade69fc03c8337d9e8ebf5cafdca75f613807621881ee29e567735475f27a0c3992ff6a8d9a863487e2098c6bf679d1c59c6c8a974bb59703ade7d7f4d0eada746448a4d9d83509ea1d128e2593bd2c802d862dfb7194e8d82d15bdf8966c8171cc45f170523fb6a1aa41abcd258da7eb686d24c059cdd9363ae15c493d2e1cd3002d1c92549e8690365919a360ceb127e84219e970c4b53f44a18ab9274c228b3306e1a6298ef613f8dfdac3bd7a9270386eff82a9e0f0d434e99638db127bca1bf72961cf4cb50264d8f2bd1affc26816a9776e36995b4e7ec6f8a2c650740cbe94d77facbdde6a7ef97d3dbc97ec5f23169c3d71399eb6bcfad9da523fb155d58ef1b5b6acc6deda551f918122aa4e69101ab92f82d33e3dc42d980da5e01a76bd50081f255dcd8516e56ca9fa28c4e582f0f39a4037bb5f0110b873b869ab066237ab129662835428f1052bb39fde04455a8ff083f7db3981f8c0d98eba6e6529b95c4cfafcd98598b660189190ef48b936d422dc90404e20b59a64c05d72b53b86a00ca013a482442109a802ddd77f852cda91994eac13c32067c6341fc49b9107b432b45fef5480ae9e8486da82eb63d26d63eb9eacc3222416f1f0f0b9af4ddae39f9e6d99079689ec52f93686f06c795c7c46da57f6b168122ce888ad0458638c8b5de3750a942ca8df2be85a1c7b61dba662cde906ddcf5b06f32ed2d54dd14727aeefa8ba0a820877a93fb187bda64846c1cb646f5aa1d980765b266a2b8c368aeebb0edd93701f647fad00302fab88d058325eff4b0b0d1e256fbe5745597376319bbaf62f09ef3685d169587e8ad9817f12481b195c0e7ea7702e8840f660c300015a75e5cf00eddd92ee73d27ecb22c869e32d1ed8e28088aeab2e7493dac74ac979f873e9a817bb8375e900b79e6ae98bbb94c4339f8aecb652730a969a480b2262abcda06ba90928562f7a8f7e965ad0bc180efdefe69062da955c211df59837355d80aceb6fb92f062facafe80065ac6067885f7295dcb2cb521a82cca8866bbbeaf7b6502286901f0e035b3e7b5e0f4586c2c93d4864ffb046fbc2163a6920e839ffa1da44bf006223caa4e5b24abd0ec3132d5bbe37de053fe4e489b522a0604103fa0364e3ac39fad0dc1975406b6b7ef24b443df99a3f4cd541445b2aa8ade85efd2e5f31e9af0bed423e684636f8ad9207701b1e0c66308e47759ebf95b00429c61c27cb52d10c6de31ad77dd9b7c8c0b933c94f431a8eae9c28011781016e80df969d0e581b5e154999ca42d3be4fc0518a6ab79d4a4266d4b8ab5c8aded902809219dfa4bfe5e9b212b5991bf863105947324df9a62f739186d8e591d8f7ffdde5c8cb520de508f3f1ed9d8dc7eae394d28614534048c52c7958cdfa0627b632ac09cbfce5670751a6229345221e96a2a9f37c7b3cddd71521343aeb35b993684462ea834250e1f01425f3e9fe328a74d3ba691aa2c7a2fd9acd34b9003369bfd5be47daf6443807a875601197277fb42ebd3f1be15834d389e242a262ac2389cd489c3c0f0b93d7f61266d35a248ef3fe9583401bfa24d067c0a4f5fc6aa535f4f9538b90ab5817f17da7e3c04b941c832baf467345ccb7035aabf4c12ddfd6f228f12e90d597f329f740bd3b65d197adb5d5bceff8aedc76201ef923ffa01785883a3b58a61fd31ca508fbacac110e0af325485895f883fdb4b209fa3070d8e92c484b3603bf0b671f6f231af4ad9829058d22e6599bc2cbdce80444a09036f09a6438fddafec3b2f05c02dbb1c23fee5b7e3d7217a91ebe3bdaba1508ed33ae95a69062b844e6788867469a3fc412d128c058239cb9e51faf0cf14b199cb7b4b08594fb43570fed976a993dcdee2427ecf2ec7994ccc72ebb56fee1b80bce81981c01b4f5193aa672f0be0d920738f8812c546c472072304bc7f22f298a5ce0ab618ae05b31a6c808b07c04b061cf8ab32d53488f327a6ff147110720f080f14b09880d44ece31d2d4c00ce40442e11ad4386845eeb8f3799cd1a48db08157923ea88d003c077911ac8994856a7987a962eb1a8141fcee2e0d778796341ff8624f3a549b9f5f1cf6a9f6f7cbcb6db789dc9939ae2f2205cdf9c77800583c8203a9a1c50a20826b1029ed8b4c5a7c6473ab49cfa8ed565e7369a983b4fd093922befaee923bd38faf667318bcdc52c5938f83f3ac555e191bc6b4b19b7cf887897d6d18bbd74c271371d7c46f8fc038341d70a569bb188976815a6aaa748df9ea0487a1d8543e875831c6008062bdca8ebde74867dadf29f15c1eff801539076535d58ae1ada976ef38bc454ed7dfe0e0f0de3946ec1c254df605fac727aca5c20ae0ef7572fcbe82443aa44b7360f417d7b84f66b8551556716dab9c3fca033ec9939874dd29dd9ca75ca69bcd2f539276ee515adbbe51d2844a7b5139f93ad6c566fb4eb883bb503582f7357f200c0ef7faed3cda62d39f42798ba33aac4bf0b267155249e85683d73cddf09b8c946dc84447905d5278b2619e28db24ee9bc7cef152249b2af2bd1a2daa156d8f790228f7d1ceac3bc4ac1b85ce6ce42b70c46c493ffe7ce7a6b2d86ead1bfa4590cd1aad584f1d9f72e589794c3d6c7fba2679a40d25546ab8584f3e7bfd7ac5bd5b573532c4addd926fc43bed7851affcf3999fcc1345dcdc31225a63f14760d9a34159aec1bc167898839790891411d5c84840c30cf4e0edaa0ef5fe1c87792206e8f19688820bebb7476bf2984ada8647d31eee608805e13475b29bf297db19001d2dfc0b1bde5b0425b85729b573aa38c45715d591a5ffacb441847b30ddfb71fd10d18173ece942030619da6bc1dc06168b6e9b8b4fc1a7dcb5ef18a08da9b9caddd8d0933f4122c92dd8e559fedf62c29363517751079c69d1518de42768a28608b6dd004de4d032ef8f31f1f7893705984e71a20fd0341b7a091def38d984c94917d182342560927db02bf71429d9078a0da77dbd8c8c3f0543e020a89403e16ff6101dea5baa5db4cb6cd05244b02450b3cab7e4b44eeda228d87b57f22ab2fbd02f26e364d2623487ac6e6411f79a9a87d5f4d59d9c1847048ca7bcd36e4c1eb2ec036227f4d956798e78f9368d0e5dbf6c83039a86cd523ecbe48e072803956ee86b68d77e10f75c1c6f60915d8b0bbe73fdb605adac3a745d1c16425f373d6fd30e9ba2ef09ace58727798e4f3646253bf6b3b074ab3498915fdaf61a13d42f50fe92ae75ff4266385ce19b8c4a29c613d9dd01c5c893a3a84fc7eddbb399dbbaf870d0f8499e3df1196acad021184cdaf90f33c8ea7ec315d11ced82367abc7987bc3b2811d58116da2ecc64303cb059e41aab4ba933af9a33079cb949462f4e0562e238358413a8219e015345b89547e4d9421a6bf356abb7ff758a5310768fdde1087864e9e593a640c104d79cb535a22ff7021eff8f2302d33a4afef77fcedeed622679636f093767070457fad55839300ae72c849836f69541e8b24159656d950ea2002c22842ce8bd97fa0e7988e951a2c45267668e2a6c1b840d49a3bbe628e76385159cb7337cb0ee4d078fb2791d5da288142c6e4047258f8b81119a51302ec9980761254e569e8a39ce498c1cf9801c42945344ce574ab78aef87e218f0b7deb1245143820f66b60f5794547cb26f235bd266254d293b9fba4c096cd4fffe175c293bb2c967899d6fee60b2c159146a89b1db5e8d0e0133cb4092b3bf93e04427eefb69830b6c4793e5f198bd918aa9158e0c7e89f28f26e0a708b9645b504bbb397bdb9d49b9bd1686d538e261a37a466664c673dcacf67d8922d6be0fe7b1588ac5b9d11e35576ad0b42b5f7739555470d187175b8f90dd9bd8ed704992e51de832e917df988e5d55</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>日常</category>
      </categories>
  </entry>
  <entry>
    <title>树的直径及其性质与尺取法</title>
    <url>/2023/05/03/%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84%E5%8F%8A%E5%85%B6%E6%80%A7%E8%B4%A8%E4%B8%8E%E5%B0%BA%E5%8F%96%E6%B3%95/</url>
    <content><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>题目名称：<a href="https://www.luogu.com.cn/problem/P1099">P1099 [NOIP2007 提高组] 树网的核</a></p>
<p>题目大意：给定一棵带边权无根树，在其直径上求出一段长度不超过 s 的路径 F，使得离路径距离最远的点到路径的距离最短。（摘自题解）</p>
<p>我在求解这道题时使用到了求取树的直径、树的直径的性质与尺取法，于是在此统一总结。</p>
<h1 id="求树的直径"><a href="#求树的直径" class="headerlink" title="求树的直径"></a>求树的直径</h1><p>思路是在树上跑两遍 dfs ，第一遍 dfs 找到最深的点后将其作为起点再跑一遍 dfs ，两次找到的最深的点之间的路径即一条树的直径。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	pt[u].book=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=a[u];i;i=e[i].next)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> v=e[i].to;</span><br><span class="line">		<span class="keyword">if</span>(pt[v].book) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		pt[v].fa=u;						<span class="comment">//fa存父亲节点</span></span><br><span class="line">		pt[v].fa_dist=e[i].w;			<span class="comment">//fa_dist存到父亲节点的距离</span></span><br><span class="line">		pt[v].dist=pt[u].dist+e[i].w;	<span class="comment">//dist存到根节点的距离</span></span><br><span class="line"></span><br><span class="line">		<span class="built_in">dfs</span>(v);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) pt[i].book=pt[i].dist=pt[i].fa=pt[i].fa_dist=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> rt,x=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">if</span>(pt[i].dist&gt;pt[x].dist) x=i;</span><br><span class="line">	rt=x,x=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) pt[i].book=pt[i].dist=pt[i].fa=pt[i].fa_dist=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">dfs</span>(rt);</span><br><span class="line">  </span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">if</span>(pt[i].dist&gt;pt[x].dist) x=i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//记录直径，del存直径节点，len存直径长度</span></span><br><span class="line">	<span class="type">int</span> len=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) pt[i].book=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(pt[x].fa)</span><br><span class="line">	&#123;</span><br><span class="line">		pt[x].book=<span class="number">1</span>;	<span class="comment">//此处会把找到的直径点都标记，可以不标</span></span><br><span class="line">		del[++m]=x;</span><br><span class="line">		len+=pt[x].fa_dist;</span><br><span class="line"></span><br><span class="line">		x=pt[x].fa;</span><br><span class="line">	&#125;</span><br><span class="line">	pt[rt].book=<span class="number">1</span>,del[++m]=x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="树的直径的性质"><a href="#树的直径的性质" class="headerlink" title="树的直径的性质"></a>树的直径的性质</h1><p>这里只做简单推导，且全部基于<strong>图上所有边权均为正</strong>这一前提。</p>
<p><strong>性质1：同一颗树若存在多条直径，所有直径必至少交于一点。</strong></p>
<p>这个不证了。</p>
<p><strong>性质2：同一颗树若存在多条直径，则这些直径关于他们的重合部分对称。</strong></p>
<p>可以想象假如不对称那么完全可以选取重合部分和两边较长的部分作为直径，就不再有这多条直径了。</p>
<p><strong>性质3：对于直径上一点，到它本身距离最远的点一定是直径的某个端点。</strong></p>
<p>假如真的有一个距离更远的点，那么完全可以用另一半直径接到这个点再从这个点接到那个距离更远的点组成一条更长的直径。</p>
<h1 id="解这道题的一些思考"><a href="#解这道题的一些思考" class="headerlink" title="解这道题的一些思考"></a>解这道题的一些思考</h1><p>题解里有些部分解释的不是很清楚，我再基于我的理解进行复述，以下简称<strong>直径上选择的路径</strong>为<strong>路径</strong>：</p>
<p>对一条路径来说，有两种距离可以左右最终答案：</p>
<ol>
<li>路径端点到直径端点的距离。</li>
<li>非直径上的其它点到路径的最短距离。</li>
</ol>
<p>之后是核心部分，我们发现将<strong>非直径上的其它点到路径的最短距离</strong>替换为<strong>非直径上的其它点到直径的最短距离</strong>后答案不会改变。这种替换使得程序能够对这种距离进行<strong>预处理</strong>，从而在量级上提高时间效率。那么为什么可以这样替换？</p>
<p>其实我们可以 2 中的路径再次细分为两类：</p>
<ol>
<li>路径端点到直径端点的距离。</li>
<li>非直径上的其它点到路径的最短距离，<strong>且这个最短距离不包括任何一段直径</strong></li>
<li>非直径上的其它点到路径的最短距离，<strong>且这个最短距离中包含了直径</strong></li>
</ol>
<p><img src="/2023/05/03/%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84%E5%8F%8A%E5%85%B6%E6%80%A7%E8%B4%A8%E4%B8%8E%E5%B0%BA%E5%8F%96%E6%B3%95/1.png" alt="img"></p>
<p>这张图片中红色为直径，黄色为路径，蓝色就是 2 的情况，绿色就是 3 的情况。我们发现蓝色部分就可以总结为<strong>非直径上的其它点到直径的最短距离</strong>，而绿色部分永远小于黄色部分的端点到直径端点的距离，即<strong>非直径上的其它点到路径的最短距离，且这个最短距离中包含了直径</strong>永远小于<strong>路径端点到直径端点的距离</strong>，而答案是取最大值，则 3 永远会被 1 覆盖而使答案不受影响，同时绿色部分刨去在直径上的长度就更小了，即通过预处理多求出来的<strong>非直径上的其它点到直径的最短距离</strong>更短，更不会对答案造成影响。</p>
<p>再多看一下那段黑色，假设那段加中间部分加左下蓝色部分也是一条直径也没什么问题，只是会得到一个和<strong>路径端点到直径端点的距离</strong>相等的距离。同时假如绿色部分冒出的部分非常长，长过了黑色部分，那么此时也就不是这两条直径了，<strong>包含上绿色部分会组成一个新的更长的直径</strong>。</p>
<h1 id="尺取法"><a href="#尺取法" class="headerlink" title="尺取法"></a>尺取法</h1><p>尺取法是一种线性算法。记 ( l , r ) 为一个序列内以 l 为起点的最短合法区间，如果有 r 随 l 的增大而增大的话，我们就可以使用尺取法。具体的做法就是不断的枚举 l ，同时求出 r 。因为 r 随 l 增大而增大，所以 r 只有 n 次变化的机会，所以时间复杂度为 O(n) 。</p>
<p>此题最后剩余的问题变成了在一段线段上找一段长度小于 s 的区间使得这段区间到线段两端点的距离的最大值最小，自然想到了尺取法。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> l=<span class="number">1</span>,r=<span class="number">1</span>,ss=<span class="number">0</span>;		<span class="comment">//l记录左端点位置，r记录右端点位置，ss记录当前长度</span></span><br><span class="line"><span class="type">int</span> disl=<span class="number">0</span>,disr=len;	<span class="comment">//disl记录左端点到左边界距离，disr记录右端点到右边界距离</span></span><br><span class="line"><span class="type">int</span> ans=<span class="number">99999999</span>;</span><br><span class="line"><span class="keyword">while</span>(r&lt;=m)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(ss&lt;=s)</span><br><span class="line">	&#123;</span><br><span class="line">		ans=<span class="built_in">min</span>(ans,<span class="built_in">max</span>(disl,disr));	<span class="comment">//如果当前合法就更新答案</span></span><br><span class="line">		ss+=pt[del[r]].fa_dist;</span><br><span class="line">		disr-=pt[del[r]].fa_dist;</span><br><span class="line">		r++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		ss-=pt[del[l]].fa_dist;</span><br><span class="line">		disl+=pt[del[l]].fa_dist;</span><br><span class="line">		l++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="关于题目的其它"><a href="#关于题目的其它" class="headerlink" title="关于题目的其它"></a>关于题目的其它</h1><p>题目本身数据很小，所以许多做法都能通过，还有跑最短路或者二分的解法，就不再一一看了。</p>
<p>还有一种说我使用尺取法的这一部可以写用了单调队列优化的动归，具体的代码因为我太蒻了没有看太明白，看上去感觉还是尺取法…只能说仁者见仁智者见智了。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>OI 知识</tag>
      </tags>
  </entry>
  <entry>
    <title>格雷码</title>
    <url>/2023/06/05/%E6%A0%BC%E9%9B%B7%E7%A0%81/</url>
    <content><![CDATA[<p>格雷码是一种二进制数系，它的特点是每两个相邻数的二进制位有且只有一位不同。如 3 位二进制数的格雷码序列为：</p>
<p>$$<br>000, 001, 011, 010, 110, 111, 101, 100<br>$$</p>
<p>在我的生涯为止遇到过两次格雷码相关的题。一次是在 CSP 中： <a href="https://www.luogu.com.cn/problem/P5657">P5657 [CSP-S2019] 格雷码</a> ，另一次是最近参加的 HBCPC ，需要求解二维格雷码。在此对格雷码做出部分总结，更多内容请参考：<a href="https://oi-wiki.org/misc/gray-code/">格雷码 - OI Wiki (oi-wiki.org)</a></p>
<h1 id="二维格雷码"><a href="#二维格雷码" class="headerlink" title="二维格雷码"></a>二维格雷码</h1><p>二维格雷码就是对于一个数而言，其上下左右四个相邻数的二进制位都与其有且只有一位不同，下面是一个例子：</p>
<p>$$<br>G_{10} &#x3D;<br>\begin{pmatrix}<br>0 &amp; 1 &amp; 3 &amp; 2 \\<br>4 &amp; 5 &amp; 7 &amp; 6 \\<br>12 &amp; 13 &amp; 15 &amp; 14 \\<br>8 &amp; 9 &amp; 11 &amp; 10<br>\end{pmatrix}<br>, G_2 &#x3D;<br>\begin{pmatrix}<br>0000 &amp; 0001 &amp; 0011 &amp; 0010 \\<br>0100 &amp; 0101 &amp; 0111 &amp; 0110 \\<br>1100 &amp; 1101 &amp; 1111 &amp; 1110 \\<br>1000 &amp; 1001 &amp; 1011 &amp; 1010<br>\end{pmatrix}<br>$$</p>
<p>观察每行的第一个数后不难发现其实就是在更大尺度上重复一维格雷码的规律。</p>
<h1 id="格雷码构造"><a href="#格雷码构造" class="headerlink" title="格雷码构造"></a>格雷码构造</h1><h2 id="手动构造"><a href="#手动构造" class="headerlink" title="手动构造"></a>手动构造</h2><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="k"> $k$ 位的格雷码可以通过以下方法构造。我们从全 $0$ 格雷码开始，按照下面策略：</p>
<ol>
<li>翻转最低位得到下一个格雷码，（例如 $000 \rightarrow 001$ ）；</li>
<li>把最右边的 $1$ 的左边的位翻转得到下一个格雷码，（例如  $001 \rightarrow 011$ ）；</li>
</ol>
<p>交替按照上述策略生成 $2^{k - 1}$ 次，可得到 $k$ 位的格雷码序列。</p>
<h2 id="镜像构造"><a href="#镜像构造" class="headerlink" title="镜像构造"></a>镜像构造</h2><p>$k$ 位的格雷码可以从 $k - 1$ 位的格雷码以上下镜射后加上新位的方式快速得到，如下图：</p>
<img src="1.png" alt="img" style="zoom:50%;" />

<h2 id="基于分治的一维格雷码构造"><a href="#基于分治的一维格雷码构造" class="headerlink" title="基于分治的一维格雷码构造"></a>基于分治的一维格雷码构造</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ten2two</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> bits)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">	<span class="keyword">while</span>(x||bits)</span><br><span class="line">	&#123;</span><br><span class="line">		bits--;</span><br><span class="line">		s.<span class="built_in">push</span>(x%<span class="number">2</span>);</span><br><span class="line">		x/=<span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(!s.<span class="built_in">empty</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,s.<span class="built_in">top</span>());</span><br><span class="line">		s.<span class="built_in">pop</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> re)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l==r)</span><br><span class="line">	&#123;</span><br><span class="line"><span class="comment">//		printf(&quot;%d&quot;,l);</span></span><br><span class="line">		<span class="built_in">ten2two</span>(l,<span class="number">3</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">if</span>(!re)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">dfs</span>(l,mid,<span class="number">0</span>);</span><br><span class="line">		<span class="built_in">dfs</span>(mid+<span class="number">1</span>,r,<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">dfs</span>(mid+<span class="number">1</span>,r,<span class="number">0</span>);</span><br><span class="line">		<span class="built_in">dfs</span>(l,mid,<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">0</span>,<span class="number">7</span>,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="基于分治的二维格雷码构造"><a href="#基于分治的二维格雷码构造" class="headerlink" title="基于分治的二维格雷码构造"></a>基于分治的二维格雷码构造</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> bits=<span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ten2two</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> bits)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">	<span class="keyword">while</span>(x||bits)</span><br><span class="line">	&#123;</span><br><span class="line">		bits--;</span><br><span class="line">		s.<span class="built_in">push</span>(x%<span class="number">2</span>);</span><br><span class="line">		x/=<span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(!s.<span class="built_in">empty</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,s.<span class="built_in">top</span>());</span><br><span class="line">		s.<span class="built_in">pop</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> re)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l==r)</span><br><span class="line">	&#123;</span><br><span class="line"><span class="comment">//		printf(&quot;%d&quot;,l);</span></span><br><span class="line">		<span class="built_in">ten2two</span>(l,bits);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">if</span>(!re)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">dfs</span>(l,mid,<span class="number">0</span>);</span><br><span class="line">		<span class="built_in">dfs</span>(mid+<span class="number">1</span>,r,<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">dfs</span>(mid+<span class="number">1</span>,r,<span class="number">0</span>);</span><br><span class="line">		<span class="built_in">dfs</span>(l,mid,<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">row</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> re)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l==r)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">dfs</span>(l*bits,l*bits+bits<span class="number">-1</span>,<span class="number">0</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">if</span>(!re)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">row</span>(l,mid,<span class="number">0</span>);</span><br><span class="line">		<span class="built_in">row</span>(mid+<span class="number">1</span>,r,<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">row</span>(mid+<span class="number">1</span>,r,<span class="number">0</span>);</span><br><span class="line">		<span class="built_in">row</span>(l,mid,<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">row</span>(<span class="number">0</span>,bits<span class="number">-1</span>,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="基于递推的二维格雷码构造"><a href="#基于递推的二维格雷码构造" class="headerlink" title="基于递推的二维格雷码构造"></a>基于递推的二维格雷码构造</h2><p>网上看到的，比我写得好。</p>
<p><a href="https://www.acwing.com/solution/content/181546/">PAT 1. HBCPC—7-2 二维格雷码</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">550</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[N][N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,num,count1,count2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    num=<span class="built_in">pow</span>(<span class="number">2</span>,n);  <span class="comment">//num为2^n</span></span><br><span class="line">    count1=<span class="number">1</span>,count2=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;<span class="built_in">i</span>&lt;num;i++)     <span class="comment">//初始化第一行</span></span><br><span class="line">    &#123;</span><br><span class="line">        a[<span class="number">0</span>][i]=a[<span class="number">0</span>][i-count1]+count2;   </span><br><span class="line">        count1+=<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(count1&gt;(i+<span class="number">1</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            count1=<span class="number">1</span>;</span><br><span class="line">            count2*=<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;num;i++)     <span class="comment">//初始化第一列</span></span><br><span class="line">    &#123;</span><br><span class="line">        a[i][<span class="number">0</span>]=a[<span class="number">0</span>][i]*num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;num;i++)      <span class="comment">//每个a[i][j]=a[i][0]+a[0][j]</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;num;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            a[i][j]=a[i][<span class="number">0</span>]+a[<span class="number">0</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;num;i++)      <span class="comment">//格式化输出</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;num;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,a[i][j]);</span><br><span class="line">            <span class="keyword">if</span>(j!=num<span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i!=num<span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/06/05/%E6%A0%BC%E9%9B%B7%E7%A0%81/2.png" alt="img"></p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>OI 知识</tag>
      </tags>
  </entry>
  <entry>
    <title>清算</title>
    <url>/2022/11/26/%E6%B8%85%E7%AE%97/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="35e6663a23bb51eee44fc1339ff0adf6b0434d614aeb5458ca14e1c9384cfd13">6fcf1523ddce79b7eefea9a75525b52411ba0544d18a79f36c9d1fbb1605a3dc4b0f90d74a95e86db4ed91f8452db1594a85f0fbd2c4a0f992806414cd27eef88f7fb1b9c49099fa8c4129673d0fa0e0f3b614d6f12d5bcf6b0eeb3b4d18ddb3d30866feecf317334582baacaf3cb09d78c7ef020a51a9ab990e220eebb7ed0c43a99a73e1dedba29ac8227a9c3815dbfe3cc96ce4e5cb7a08d5c96a0feb393ea410109738a579f227f260f7010d3e318b41dc78fb1d0d74639b3c9fb4e31baf556d2364b6efaaf4ef81bf02a018b2f9f1fb660cef800b93130aaa0aedd4b00f17c21a63387ba29ed601079d397ccec9e9d38c8b819f0fb22df5b9acde4cc67e943bcd5910158ba29b0f4706a999e56009b6d95d3ca9809086d7f16138fe1eb7295cecea6c95f8489f03481c22c3a424744ade5ebf04eddbbf092ea498fecac97da9d5b9e8323eb9b462bde43aab2cfc96d937bbacbd707d04ddc246ca98cc44893a12a958f3ff7a3c9a32380f61dd7acd7770a9cf7c33d2ed1df3f55f20dcdcda455c2ec4667a5336c05bba8db5afbc55e549dd43c8398c6c826486697dded65695cb15a0075b2055101b1b095b38e5c8c59da68d9c2b50aa06cc23c26b0437aaec6897aee0b68bff22f23a9d1ed388bc7acbf96f8b2432b75effafac37aebe215e89d540a0b045dad3cb8b626ab9ef3cf25fb89db6c9d5e9a4739043386b4925b870155aaa32bb1fed16200b6e2ba18a944bce93b152abbbad0895be525eb72451b9bc5d6d5345967df3bcec7587453838c5cbc1631f89293d9fbda7a4e76cb031653c54cc995b9e54f342ac643a07ce3cf0608d57103235e3a204b3fb9c578e1dab4be6ff33fb51b699dd3983ff9b281680327bebb3d699e91ed0e29302f98a1212ac91ce60a9706517365dfd1d4d07096f296bd5161c25a8407307e446c8c60e05bae7ffd55255e19d522b5dd0e4d93a2f895e71878fe1637384a1e8fdccef8dca15c16547b943292ed2c1b2210b98c993ad193690eeffd41021028b89786960450e09a401236ba69fa99ce3bd9ee3bb63455a920f9b482ed55b64fc31bb62a1df942ed0c02f24f2ce7833bb9f0a88a248ce8f452dd8252fddca1d79dbf5488092f827c7e5c9efff46fdb7e00a55db68ddfe97c1bde75b9f985b1cd45fd1cfb2edbfbf64e47a98e29bbaad1e5044ab4439964137030803ad7340b575eac2918fc61972845c17ad0e382981cf46ab352f964fe0ea48b9985ecd6628ca0ca5e9ae0c3fce47d40adb4734dba3bfac337c8dd4039a8050ebf58bb02132cbfe9a7981c44b8850dc8ec1a30b015d1667a6fa1abe1bdc9c174964f2cfdc3e24ead8b98b48fcae6982f50778bacad715380e7736cabba301828a9b27c556bdb26c8e59d28bd943c757eef70bda425ad6a3a01c1ec9aba82b25bb38e45289907de70c0a3548f36bbeb41de687f36569ba4f805516e6a756c07832f4029ef3cfae2b60ad3c5ccbebb2c8f4d9eaeaca68d48f5e12d2b2968cbd7547e7dea20525dcff2a6e692771c2f4f76cecc184573a1680bd4707bd0a70aeac9a0d997346d9b18f164ef3b003dbcf32eeb64b8037931313950fd7fcaeaa8bc782c91ed7ba7c35791f68394f039a8346752651b59b5d5154e7659425906d258bf2b37a667ed6a0ba6cc2a7d201022dc992061b6256d031bf8bbde04a43a22d9bf9086527c77870472a702b67b09b92912f877ef785b1666d46e86043d8e792ecf5e823a26bb16d8b9fdca8c3eacb8dddbcf8fb4e2c3ff4d048eead8a9cf2cccbacdbfd5c851c7cbabae0740f4da9717089e2aac16fe61b0eaa2cd5385372c5580b5e5926b9ed216be1df515b3d76e6955786842f5b0007cf7322e7272926f2704715814bebc8ee0eb2af057714fa73ba8cd24fd72ac7ca057df6254aad1417012af7b64a06d64ea0f9d598d7db709ed8995717a5304c0b496062b019bd69147afa642cd793cfe45265dc02ec3b10b28d17f152609138daff1367257a5c4b28545d9ffd04e69528297eb89bab4600c2640bb56490198216594f6e19ff485b8aa4b32ba54711fa0de89e955d64a305b3c07fc7e3f82a9026521943a84758aca98700dd9a1fe39d2cf48c9cbdb9d818ca5faf6d257f030bd083746dec52e74e260ff773f557474f043ca34d018c84de46f6d34184c5883606f526626b7329559934c3e4ed3ad14cd81ca07790deb49426ad6df3a5ff50aaf6957ebd70eda78b8fe4062e0dfd905d48f0a16ae09640973991b18f964d1d21148c2bcea70ecbab1e0b502ed13e989340cbbff1f211c639817ce7a12d99a98b0e1598fc77fc203b99fe98c149ba38b14a03c9a9f670e3f718b9030e4ef7c7cf3646f78405bf0a1ccaa55b438b66c2b7ac977f555d531ea5e6b92dd6b69b1427eeb4e76f40e319e201d8d19d8c43cae0b2b42d47e1937de3d6481ea7fc2c4168f8775e926c13d8ffc2ec03cfbfa30ac09ff2e6f0aceb268d6c581bd11f866de6e7659eb2fccf1fe19356f4cc9278e66e62cf23ce3786668f3d5ebc5392c37563d03c99d9641db3b2686fa6ecc5d5118d25a8f53800b2d0145f57b4baf50915e1b32db8d523a0150bc42db9f68d7f18e949ca6e4e6602a002fd84b457014f1af40d8f2b1dc740168ced708c0b6ace81008cc3abfadc15e65c81d7c0fbbece0306f02d232602b91cd0d55eefb75a33c5fa878f22af830d7dfe2502218b65b9546b78de38bb8c4bf3b42cbbf635b9a11d59546dec8d6b3a14e2c9cce3875ba1b061abac8ac3286f40f1d606d46987bdb28fbc3db3ecc68feb7d70afaf2a7f8ed3b71c75419b4ac59dae964e7e085cb2f59b043b10f6a9bca66868e544d2646c734b307e858f4665e45f17a4a2b01bd5bee8b513f444957a76077556d60ff6d17377807680b85c6726818c1a7ec0261ef6485a8f60</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>日常</category>
      </categories>
  </entry>
  <entry>
    <title>网络流</title>
    <url>/2022/02/11/%E7%BD%91%E7%BB%9C%E6%B5%81/</url>
    <content><![CDATA[<h1 id="相关定义"><a href="#相关定义" class="headerlink" title="相关定义"></a>相关定义</h1><p>首先想象一张有n个点，m条边的有向图。</p>
<p><strong>源点</strong>：只出不进的点。</p>
<p><strong>汇点</strong>：只进不出的点。</p>
<p><strong>容量</strong>：边的属性，通常使用c[i, j]表示。</p>
<p><strong>流量</strong>：边的属性，通常使用f[i, j]表示。</p>
<p>可以把边想象成道路，容量即本路最多能承载的车流量，流量即车流量，显然<strong>流量≤容量</strong>。</p>
<p>可以把不是源点和汇点的点想象成没有储存功能的货物中转站，<strong>进入的流量&#x3D;出去的流量</strong>。</p>
<p><strong>最大流</strong>：若把源点比作工厂，问题就是求从工厂最大发出多少货物同时不超过道路的容量限制，即<strong>最大流</strong>。</p>
<p><strong>可行流</strong>：所有边上的流量都不超过容量的这一组流量（或者说这个流）。</p>
<p><strong>零流</strong>：所有流量都为0的流，易得零流是可行流。</p>
<p><strong>增广路</strong>：一条从源点到汇点的比之前的流大delta的流。（后面解释）</p>
<p><strong>残量网络</strong>：在原图的基础之上，添加每条边对应的反向边，并储存每条边的当前流量。残量网络会在算法进行的过程中被修改。</p>
<h1 id="求解思路"><a href="#求解思路" class="headerlink" title="求解思路"></a>求解思路</h1><ol>
<li>从零流开始考虑。假设存在一条从源点到汇点的路，其每一段都满足流量＜容量（注意不是≤）。</li>
<li>则一定能找到本路上每一段的(容量 - 流量)的<strong>最小值delta</strong>，显然本路上的每一段的流量加上delta仍是可行流。</li>
<li>于是我们得到了一个更大的流，他的流量为其原来的流量+delta，这条路被叫做<strong>增广路</strong>。我们不断地从起点开始寻找增广路，每次都对其进行增广，直到源点和汇点不连通，也就是找不到增广路为止。</li>
<li>当找不到增广路时，当前的流量就是最大流。</li>
</ol>
<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><ul>
<li>寻找增广路可以简单的从源点开始做BFS，并不断修改这条路上的delta量，直到找到源点或者找不到增广路。</li>
<li>程序实现时，通常只用一个数组c记录容量，当流量+delta时使用容量-delta实现，从而方便程序实现。（个人认为此时数组c的意义发生了改变，叫做<strong>能容量</strong>，也就是当前状态下能容下的量更为准确，后面也使用本叫法）</li>
</ul>
<h1 id="增加反向边"><a href="#增加反向边" class="headerlink" title="增加反向边"></a>增加反向边</h1><p><strong>为什么增加反向边：</strong>在寻找增广路时不同的寻找顺序可能会导致结果不同，加入反向边使得能够自我调整寻找顺序。</p>
<p><strong>例子：</strong></p>
<p>求本模型最大流。</p>
<p><img src="/2022/02/11/%E7%BD%91%E7%BB%9C%E6%B5%81/1.jpg" alt="img"></p>
<p>找到1-2-3-4这条增广路，delta显然是1，进行修改。</p>
<p><img src="/2022/02/11/%E7%BD%91%E7%BB%9C%E6%B5%81/2.jpg" alt="img"></p>
<p>此时找不到增广路了，当前流量是1。但显然这不是正确答案。</p>
<p>正确答案应该是走1-2-4和1-3-4，得到流量为2的流。</p>
<p>因此可以看到，错误的找增广路顺序使程序得出了错误的答案，应当给程序一个“后悔”改路的机会，于是引入反向边。</p>
<p>反向边初始能容量均为0，每一次找到增广路时，进行如下操作。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">c[i][j]-=delta;	<span class="comment">//正向边减delta</span></span><br><span class="line">c[j][i]+=delta;	<span class="comment">//反向边加delta</span></span><br></pre></td></tr></table></figure>

<p>按此方法重新寻找到增广路1-2-3-4并修改。</p>
<p><img src="/2022/02/11/%E7%BD%91%E7%BB%9C%E6%B5%81/3.jpg" alt="img"></p>
<p>再次寻找增广路，找到1-3-2-4这条，delta为1，将这条路增广后不再有增广路，得到了最大流2。</p>
<p><img src="/2022/02/11/%E7%BD%91%E7%BB%9C%E6%B5%81/4.jpg" alt="img"></p>
<p>可以认为，两次通过的2、3的相反的等大小流相互抵消了，因此1-2-3-4与1-3-2-4这两个流合起来的作用效果也就是1-2-4和1-3-4这两个流加起来的作用效果。</p>
<h1 id="最大流"><a href="#最大流" class="headerlink" title="最大流"></a>最大流</h1><p><a href="https://www.luogu.com.cn/problem/P3376">模板题点我</a></p>
<p>听说有dinic和sap（isap），这里只写dinic。</p>
<h2 id="FF"><a href="#FF" class="headerlink" title="FF"></a>FF</h2><p>FF为一种直接深搜找增广路的暴力方法。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m,s,t;</span><br><span class="line"><span class="type">int</span> a[<span class="number">210</span>],tot=<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> vis[<span class="number">210</span>];</span><br><span class="line">LL ans=<span class="number">0</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	tot=1是为了更方便的找到反向边。 </span></span><br><span class="line"><span class="comment">	tot=1会使第一条边编号为2（二进制10），第二条边编号为3（二进制11），以此类推。</span></span><br><span class="line"><span class="comment">	又由于在加边时会把相反的两条边依次加入，所以每条边与他的反向边在编号上只在末位差1。</span></span><br><span class="line"><span class="comment">	因此只要将现编号与1异或就可以方便的得到反向边的编号。 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">bian</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> to;</span><br><span class="line">	LL w;</span><br><span class="line">	<span class="type">int</span> next;</span><br><span class="line">&#125;e[<span class="number">10010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> from,<span class="type">int</span> to,LL w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	tot++;</span><br><span class="line">	e[tot].next=a[from];</span><br><span class="line">	a[from]=tot;</span><br><span class="line">	e[tot].to=to;</span><br><span class="line">	e[tot].w=w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">dfs</span><span class="params">(<span class="type">int</span> now,LL delta)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(now==t) <span class="keyword">return</span> delta;</span><br><span class="line"></span><br><span class="line">	vis[now]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> v=a[now];v;v=e[v].next)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> tto=e[v].to;</span><br><span class="line">		LL ww=e[v].w;</span><br><span class="line">	</span><br><span class="line">		<span class="keyword">if</span>(vis[tto]||!ww) <span class="keyword">continue</span>;</span><br><span class="line">	</span><br><span class="line">		LL res=<span class="built_in">dfs</span>(tto,<span class="built_in">min</span>(delta,ww));</span><br><span class="line">	</span><br><span class="line">		<span class="keyword">if</span>(res)</span><br><span class="line">		&#123;</span><br><span class="line">			e[v].w-=res;</span><br><span class="line">			e[v^<span class="number">1</span>].w+=res; </span><br><span class="line">		</span><br><span class="line">			<span class="keyword">return</span> res;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	LL x,y,z;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;s,&amp;t);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld%lld&quot;</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line">		<span class="built_in">add</span>(x,y,z);</span><br><span class="line">		<span class="built_in">add</span>(y,x,<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	LL lin;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="built_in">sizeof</span>(vis));</span><br><span class="line">		lin=<span class="built_in">dfs</span>(s,<span class="number">1e18</span>);</span><br><span class="line">		<span class="keyword">if</span>(lin) ans+=lin;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于每次只找一条路，这条路还可能绕远路，而且增加流量是路上最小的权值，所以效率低。</p>
<p>网上有些题解试图简单卡 FF：</p>
<p><img src="/2022/02/11/%E7%BD%91%E7%BB%9C%E6%B5%81/5.gif" alt="img"></p>
<p>虽然这种图卡不掉FF，但是你可以看出，<strong>FF的复杂度和流量有关</strong>，这很糟糕。</p>
<h2 id="Dinic"><a href="#Dinic" class="headerlink" title="Dinic"></a>Dinic</h2><p>Dinic可解决FF效率低的问题。</p>
<ul>
<li><p>每次多路增广：u 点通过一条边，向 v 输出流量以后，v 会尝试到达汇点（到达汇点才真正增广），然后 v 返回实际增广量。这时，<strong>如果 u 还有没用完的供给，就继续尝试输出到其它边。</strong></p>
<p>但是要警惕绕远路、甚至绕回的情况，不加管制的话极易发生。怎么管？</p>
</li>
<li><p>源点<strong>顺着残量网络</strong>想要到达其它点，需要经过一些边对吧？<strong>按照经过的边数（即源点出发以后的距离）把图分层，即用 bfs 分层。</strong> 每次尝试给予时，<strong>只考虑给予自己下一层的点</strong>，就可以防止混乱。</p>
</li>
<li><p>综合上面两条。每回合也是从源点出发，<strong>先按照当前残量网络分一次层</strong>，随后多路增广，尽可能增加流量。增广过程中，会加入一些反向边，这些反向边逆着层次图，本回合并不会走。所以还需要进入下一回合。一直到 bfs 分层时搜不到汇点（即残量网络断了）为止。</p>
</li>
</ul>
<p>可是它每次只按照 bfs 分层的固定方向进行增广，还能保证正确性吗？这个好理解：只要图中还有增广路（源点顺着残量网络到达汇点的路），<strong>bfs 分层就会搜索到汇点</strong>，于是增广就不会停止，最终也止于没有增广路的局面。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m,s,t;</span><br><span class="line"><span class="type">int</span> a[<span class="number">210</span>],tot=<span class="number">1</span>;	<span class="comment">//tot为1和FF同理 </span></span><br><span class="line"><span class="type">int</span> dep[<span class="number">210</span>];</span><br><span class="line">LL ans=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">bian</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> to;</span><br><span class="line">	LL w;</span><br><span class="line">	<span class="type">int</span> next;</span><br><span class="line">&#125;e[<span class="number">10010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> from,<span class="type">int</span> to,LL w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	tot++;</span><br><span class="line">	e[tot].next=a[from];</span><br><span class="line">	a[from]=tot;</span><br><span class="line">	e[tot].to=to;</span><br><span class="line">	e[tot].w=w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(dep,<span class="number">0</span>,<span class="built_in">sizeof</span>(dep));</span><br><span class="line">	<span class="type">int</span> l=<span class="number">1</span>,r=<span class="number">1</span>,q[<span class="number">210</span>];</span><br><span class="line">	q[l]=s;</span><br><span class="line">	dep[s]=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(l&lt;=r)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> now=q[l++];</span><br><span class="line">	</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> v=a[now];v;v=e[v].next)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> tto=e[v].to,ww=e[v].w;</span><br><span class="line">		</span><br><span class="line">			<span class="keyword">if</span>(ww&amp;&amp;!dep[tto])</span><br><span class="line">			&#123;</span><br><span class="line">				dep[tto]=dep[now]+<span class="number">1</span>;</span><br><span class="line">				q[++r]=tto;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> dep[t];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">dfs</span><span class="params">(<span class="type">int</span> now,LL in)</span>	<span class="comment">//in不一定真的能用掉 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(now==t) <span class="keyword">return</span> in;</span><br><span class="line"></span><br><span class="line">	LL out=<span class="number">0</span>;	<span class="comment">//in是前面流入这点的流量，out是这点向下层发出的总流量 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> v=a[now];v;v=e[v].next)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> tto=e[v].to;</span><br><span class="line">		LL ww=e[v].w;</span><br><span class="line">	</span><br><span class="line">		<span class="keyword">if</span>(ww&amp;&amp;dep[tto]==dep[now]+<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			LL res=<span class="built_in">dfs</span>(tto,<span class="built_in">min</span>(in,ww));</span><br><span class="line">			e[v].w-=res;</span><br><span class="line">			e[v^<span class="number">1</span>].w+=res;</span><br><span class="line">			in-=res;</span><br><span class="line">			out+=res;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(!out) dep[now]=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	LL x,y,z;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;s,&amp;t);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld%lld&quot;</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line">		<span class="built_in">add</span>(x,y,z);</span><br><span class="line">		<span class="built_in">add</span>(y,x,<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">bfs</span>()) ans+=<span class="built_in">dfs</span>(s,<span class="number">1e18</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/02/11/%E7%BD%91%E7%BB%9C%E6%B5%81/6.gif" alt="img"></p>
<p>注意理解多路增广：虽然一个点要枚举所有出边，但<strong>实质仍然是dfs</strong>，过程图类似于树。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.cnblogs.com/ZJUT-jiangnan/p/3632525.html">https://www.cnblogs.com/ZJUT-jiangnan/p/3632525.html</a></p>
<p><a href="https://blog.csdn.net/weixin_43907802/article/details/84705855">https://blog.csdn.net/weixin_43907802/article/details/84705855</a></p>
<p><a href="https://www.luogu.com.cn/problem/solution/P3376">https://www.luogu.com.cn/problem/solution/P3376</a></p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>OI 知识</tag>
      </tags>
  </entry>
  <entry>
    <title>筛法</title>
    <url>/2020/10/25/%E7%AD%9B%E6%B3%95/</url>
    <content><![CDATA[<p>筛法是一种用来求素数的方法。一般来说可以循序渐进的掌握暴力判断素数、埃氏筛法、欧拉筛法。</p>
<h1 id="暴力判断素数"><a href="#暴力判断素数" class="headerlink" title="暴力判断素数"></a>暴力判断素数</h1><p>时间复杂度$O(n^2)$(对于打出素数表来说)</p>
<p>利用素数只能被$1$和它本身整除的性质，我们可以把需判断的数$x$与$2…n - 1$取余。如果结果均不等于$0$，则为素数。</p>
<p><strong>代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"> <span class="number">2</span> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"> <span class="number">3</span> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"> <span class="number">4</span> </span><br><span class="line"> <span class="number">5</span> <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> <span class="number">6</span> </span><br><span class="line"> <span class="number">7</span> <span class="type">int</span> n;</span><br><span class="line"> <span class="number">8</span> <span class="type">bool</span> flag;</span><br><span class="line"> <span class="number">9</span> </span><br><span class="line"><span class="number">10</span> <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">11 </span>&#123;</span><br><span class="line"><span class="number">12</span>     <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line"><span class="number">13</span>   </span><br><span class="line"><span class="number">14</span>     <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line"><span class="number">15</span>     &#123;</span><br><span class="line"><span class="number">16</span>         flag=<span class="literal">true</span>;</span><br><span class="line"><span class="number">17</span>         <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">2</span>;j&lt;=i<span class="number">-1</span>;j++)</span><br><span class="line"><span class="number">18</span>         &#123;</span><br><span class="line"><span class="number">19</span>             <span class="keyword">if</span>(i%j==<span class="number">0</span>)</span><br><span class="line"><span class="number">20</span>             &#123;</span><br><span class="line"><span class="number">21</span>                 flag=<span class="literal">false</span>;</span><br><span class="line"><span class="number">22</span>                 <span class="comment">//当出现第一个能被整除的数时立即跳出循环，可提高一定效率</span></span><br><span class="line"><span class="number">23</span>                 <span class="keyword">break</span>;</span><br><span class="line"><span class="number">24</span>             &#125;</span><br><span class="line"><span class="number">25</span>         &#125;</span><br><span class="line"><span class="number">26</span>       </span><br><span class="line"><span class="number">27</span>         <span class="keyword">if</span>(flag) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,i);</span><br><span class="line"><span class="number">28</span>     &#125;</span><br><span class="line"><span class="number">29</span>   </span><br><span class="line"><span class="number">30</span>     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="number">31</span> &#125;</span><br></pre></td></tr></table></figure>

<p>这个最简单的写法在只判断几个素数时绰绰有余，但是当要打出一个很大的素数表时效率不足。</p>
<h1 id="埃氏筛法"><a href="#埃氏筛法" class="headerlink" title="埃氏筛法"></a>埃氏筛法</h1><p>时间复杂度$O(n \log n)$</p>
<p>任意一个素数的倍数是合数是埃氏筛法筛出素数表的主要原理。假设要打出$n$以内的素数表。我们从$2$开始向后遍历，每当遇到一个素数$p$时，便利用此素数将$2…n$内$p<em>2，p</em>3，p*4…$这些合数全部筛去。</p>
<p><strong>代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"> <span class="number">2</span> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"> <span class="number">3</span> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"> <span class="number">4</span> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"> <span class="number">5</span> </span><br><span class="line"> <span class="number">6</span> <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> <span class="number">7</span> </span><br><span class="line"> <span class="number">8</span> <span class="type">int</span> n;</span><br><span class="line"> <span class="number">9</span> <span class="type">int</span> p[<span class="number">10000010</span>];</span><br><span class="line"><span class="number">10</span> </span><br><span class="line"><span class="number">11</span> <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">12 </span>&#123;</span><br><span class="line"><span class="number">13</span>     <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line"><span class="number">14</span>   </span><br><span class="line"><span class="number">15</span>     <span class="comment">//初始化</span></span><br><span class="line"><span class="number">16</span>     <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++) p[i]=<span class="number">1</span>;</span><br><span class="line"><span class="number">17</span>   </span><br><span class="line"><span class="number">18</span>     <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=<span class="built_in">sqrt</span>(n)+<span class="number">0.5</span>;i++)</span><br><span class="line"><span class="number">19</span>         <span class="keyword">for</span>(<span class="type">int</span> j=i*<span class="number">2</span>;j&lt;=n;j+=i) p[j]=<span class="number">0</span>;</span><br><span class="line"><span class="number">20</span>   </span><br><span class="line"><span class="number">21</span>     <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line"><span class="number">22</span>         <span class="keyword">if</span>(p[i]) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,i);</span><br><span class="line"><span class="number">23</span>   </span><br><span class="line"><span class="number">24</span>     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="number">25</span> &#125;</span><br></pre></td></tr></table></figure>

<p>这个算法在一般的数据面前已经足够了。不过还可以更快。</p>
<h1 id="欧拉筛法"><a href="#欧拉筛法" class="headerlink" title="欧拉筛法"></a>欧拉筛法</h1><p>时间复杂度$O(n)$</p>
<p>首先观察一下埃氏筛法。我们发现有这样一个问题：在使用素数$2$进行筛去操作时，会筛去素数$6$；在之后利用素数$3$进行筛去操作时，会再筛去一次素数$6$。可见在埃氏筛法的筛去过程中，会出现同一个合数被筛去多次的情况，从而影响了效率。</p>
<p>相比之下，欧拉筛法是一种线性筛法。它便解决了埃氏筛法中一个合数会被筛去多次的问题，确保了每一个合数都只会被筛去一次，因此具有$O(n)$的效率。它的实现原理是<strong>确保每个合数都只会被它的最小质因数筛掉</strong>。过程大概如下：</p>
<p>首先我们会建立$2$个数组：$isp$（值为$1&#x2F;0$，$isp[i]$用来表示$i$是否是素数），$p$（用来储存所有的素数）。依旧是打出到$n$的素数表。</p>
<ol>
<li>从$2$开始遍历$i$。如果$i$是素数，就把它加入到数组$p$中。</li>
<li>对于每个$i$使用$j$遍历数组$p$，筛去$i * p[j]$，若$i * p[j] &gt; n$（已经没必要筛去了）或$i \mod p[j] &#x3D;&#x3D; 0$（<strong>这是确保每个合数只筛一次的核心</strong>）就退出循环。</li>
</ol>
<p><strong>对核心的解释：</strong>假设在$i \mod p[j] &#x3D;&#x3D; 0$时我们继续进行，便筛去了合数$i * p[j+1]$。由于此时$i \mod p[j] &#x3D;&#x3D; 0$，则这个由一个素数和一个合数的乘积组成的合数，一定能转化为一个更小的素数和一个更大的合数的乘积，那么当继续运行时，此合数必然还会被$p[j]$再次筛去，便进行了多余的筛去工作。因此可以说在$i \mod p[j] &#x3D;&#x3D; 0$时退出循环是确保每个合数都只会被它的最小质因数筛掉，即确保了每个合数只被筛一次。</p>
<p><strong>代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"> <span class="number">2</span> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"> <span class="number">3</span> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"> <span class="number">4</span> </span><br><span class="line"> <span class="number">5</span> <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> <span class="number">6</span> </span><br><span class="line"> <span class="number">7</span> <span class="type">int</span> n;</span><br><span class="line"> <span class="number">8</span> <span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line"> <span class="number">9</span> <span class="type">int</span> isp[<span class="number">10000010</span>],p[<span class="number">10000010</span>];</span><br><span class="line"><span class="number">10</span> </span><br><span class="line"><span class="number">11</span> <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">12 </span>&#123;</span><br><span class="line"><span class="number">13</span>     <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line"><span class="number">14</span>   </span><br><span class="line"><span class="number">15</span>     <span class="comment">//初始化</span></span><br><span class="line"><span class="number">16</span>     <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++) isp[i]=<span class="number">1</span>;</span><br><span class="line"><span class="number">17</span>   </span><br><span class="line"><span class="number">18</span>     <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line"><span class="number">19</span>     &#123;</span><br><span class="line"><span class="number">20</span>         <span class="keyword">if</span>(isp[i])</span><br><span class="line"><span class="number">21</span>         &#123;</span><br><span class="line"><span class="number">22</span>             num++;</span><br><span class="line"><span class="number">23</span>             p[num]=i;</span><br><span class="line"><span class="number">24</span>         &#125;</span><br><span class="line"><span class="number">25</span>         <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=num&amp;&amp;i*p[j]&lt;=n;j++)</span><br><span class="line"><span class="number">26</span>         &#123;</span><br><span class="line"><span class="number">27</span>             isp[i*p[j]]=<span class="number">0</span>;</span><br><span class="line"><span class="number">28</span>             <span class="comment">//确保每个合数都只会被它的最小质因数筛掉</span></span><br><span class="line"><span class="number">29</span>             <span class="keyword">if</span>(i%p[j]==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line"><span class="number">30</span>         &#125;</span><br><span class="line"><span class="number">31</span>     &#125;</span><br><span class="line"><span class="number">32</span>   </span><br><span class="line"><span class="number">33</span>     <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=num;i++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,p[i]);</span><br><span class="line"><span class="number">34</span>   </span><br><span class="line"><span class="number">35</span>     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="number">36</span> &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>OI 知识</tag>
      </tags>
  </entry>
  <entry>
    <title>蓝桥杯省二反思</title>
    <url>/2023/04/23/%E8%93%9D%E6%A1%A5%E6%9D%AF%E7%9C%81%E4%BA%8C%E5%8F%8D%E6%80%9D/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="d0c1223aa624c031e2e58c9d90ff732a5559bc1064c1313eaa81cc65a7a3b0d8">6fcf1523ddce79b7eefea9a75525b524cc28394ed74c15007beed5e4609071a7656fea4ebf48db4e7430448fac03e5cacb0fca42682612294c53278a7098e862bcb2fed72525bf5021084bbe8a794ce743391111720b90d81c315fede0baef4b3f46a73a53a45ca10e2f2f93caed71fcebd7fa1708ec50f1d86b64ca1f2191294a31e960cd72dfca8c6fb444d48ab650b45c6177e94810ceb0b785c3793aa9afe6238e8ff8f353282e5c8909644a1dffd65541e1398f8bb5ec58fda6fd6b422e8d0a167c1487a710c41f4dfb0f3d79c99d7af97481a168a9c8ff1a44e6f7b5008ac99202b5ea70fdd373d1dc41350aa4628c085d260258a5943aa0801b78029e752ac6e7d5a06bc94e36e83ccc21b55f81516ae4ccb205c5562568b0ccfbd357add8c430049b0a1898a39c330fbb8400580aeda12078dd2a96015afa148d5ba2cb3559998e9fe84d43e58155c612680371fdfa72bb20c7fa15b5b251e674c300bcab725c6fff0d2d1e537b3c283695d34b3b3d27b1dd328b8bea119626617d0d4b71de98cf5eb8aef7ee6e3a58075b25ce821834c4ea6ab16495978da97350db2f5369be09b293de52d99a2a349c116c207b0c92670d9eede7ff66edff113c1d8b5936431e587b8272a1be93f6d1a493af54d15034bd41591b2c59087a6ca8a2502fb7e4630214ef614ba3d2d450c2acb4af51dba5d05a68c8b6c4a0202b23a4a7f50a7a56de2a01313fe6d7c474fcfeedb059d4c58fb85c69f011048b1efb763c06f7ff3f30893eaf18f0f677c4ddded5aeb252c9bf551842c2f1c73d687dd0356928412b70bf702652cb024d6007f9a99262ccc7a56385118ba436796bc53269078b22d240139a8ec3834b271256f355a75caa2b9581ca0da2d4f722796c641fa257b3e76b3af9be8e98d7017962c2b814fd3230cdfa4b706fba36562a4eaa486ac3c4591ff15aac8f452e11034880160f00f7e079ece48f39f1b1a701b4816845448d97a28d951efe8856ad31e0f828e94f2ced80b3688e47371b6ecc3b3e6f99b4bdf1ab3ab87cc9181d853be1625fd6c4be97a67e5ba54351e20eda6180a9d847606cc0b1ce6767303672f71ee9f7ec5c6a7310e1f73ce6fef0409b6e9803f5adf94724baabfb3911925a0207fefbf65307cd9aaa25b4687caaf6f35b6338ec7b10240e8b1b2b9da819e7e4568cf29658ce14c79f27f228673323cc84883781c0f0ffd2484b13e5873be2a8669903c5e9544c1cac17a54d911507dde388ce9717a572e8c3fa60fc01f70bc650a50653f096d6a5e2675408a00f24ac655837571ca27a73991fb6991d8a1ffba1d418da8164b1e35c477fb9da0203edf287b349fb3076408e77029653474519b11c932dda853b0ff51e4437e4d70311f505f5065eb2e714f2ff09bd0b3ec4c828f25a900230658a6e9a2a802baf9eda9fd2eb7de4405f39e93d3e4009676ceece40d1c55cc97a765ceb8bb83fdeb7ca27bb9179987038a362fe47d402d57be23d7ca430a2448af7f15441ea54e421e6fa36b24c7bf947f59f0cd179e337e9f6d1077359fdc5ebdc2ef3b1ebe667386ff3273647afb5bddb5ab6deb3917e73cfff0645155a4cda5652625f4b56887bce8fdec59a008f188049bc4eeca70705f2a6ff956bbda5dbe134d63fcee8c386ccdbbea5af54e1d9ed8047d5d0f2c2d360d57190a5133d2c83ea8834833a6aff85cf0817913eb1482be7d018e6e8d255cf2817a5dfd915fb6c0ffec51cbc94488d246cd69f01db8dbf8422dabc6188ecf72aaec2e8a5beceebd985a8ee3ad47647228955f9811cbf83e63675543bc9bff06ff8fe92610a17be1e189b58a382056b22b94a65be552196e90f4b450a7070646d52c3f466ab358d7a776c146207f5270fb61b3fc741e2d00470b953604151bd6c309633cff8f87746b053ec70479da83da530ca947919bdaeaf775f0475ad81c2bc1e87c0a6d726746a2e1c362b5ef0430f3d84761d0a5cf69e56200a3b6c5510ba232231e1e5885cdb1c5823f1f76ce7e31beffec5cd1bf21ae18dcd926380efeffbd2b612977b100d40b3181f62f873b0aadde7a5aeb91d6a483187454ca0a3f66b2b8b8a142ca667cf57675999c1a7d530f687c63a21b64815ce41958f7b167633b066b9798291b83c207a44ed128fec581fb3bcd6bfa18491494e2e6efdbc29e6694fe5d91ec4ea733f310377504f17869e39f0b4d34cc2e02b5422c2dceda5472c188ce80f8fff2bedaca2b776b1af</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>OI 比赛</tag>
      </tags>
  </entry>
  <entry>
    <title>质因数分解（待完善）</title>
    <url>/2022/03/23/%E8%B4%A8%E5%9B%A0%E6%95%B0%E5%88%86%E8%A7%A3/</url>
    <content><![CDATA[<p>时间复杂度：$O(\log n)$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 200000</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> p[N+<span class="number">10</span>];			<span class="comment">//p[i]为i是否为素数</span></span><br><span class="line"><span class="type">int</span> vv[N+<span class="number">10</span>];			<span class="comment">//vv[i]为i的一个质因数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=N;i++)</span><br><span class="line">&#123;</span><br><span class="line">	p[i]=<span class="number">1</span>;</span><br><span class="line">	vv[i]=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=<span class="built_in">sqrt</span>(N)+<span class="number">0.5</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(!p[i]) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j=i*<span class="number">2</span>;j&lt;=N;j+=i)</span><br><span class="line">	&#123;</span><br><span class="line">		p[j]=<span class="number">0</span>;</span><br><span class="line">		vv[j]=i;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接除的方法使用：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> f[N+<span class="number">10</span>];			<span class="comment">//f[i]为质因数i的个数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(x&gt;<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">	f[vv[x]]++;</span><br><span class="line">	x/=vv[x];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>开辟vector记录所有分解结果：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; factors;		<span class="comment">//factors[i]为i的质因数分解结果</span></span><br><span class="line"></span><br><span class="line">factors.<span class="built_in">resize</span>(N+<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=N;i++)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> temp=i;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(temp&gt;<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		factors[i].<span class="built_in">push_back</span>(vv[temp]);</span><br><span class="line">		temp/=vv[temp];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> p:factors[x]) f[p]++;		<span class="comment">//和直接除一样储存到f中的方法</span></span><br></pre></td></tr></table></figure>

<p>在$n$过大质因数数组无法存储时这一个数的求法：</p>
<p>需要先求得一个素数数组p[50010]，对于一个数的效率为$n^{1 \over 2}$。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;p[i]*p[i]&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span>(n%p[i]==<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		n/=p[i];</span><br><span class="line">		np[p[i]]++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(n&gt;<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(n&lt;=<span class="number">50000</span>) np[n]++;</span><br><span class="line">	<span class="keyword">else</span> np[<span class="number">0</span>]+=n;		<span class="comment">//在np[0]处存储大素数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>似乎还有一种$n^{1 \over 4}$效率的求法，待完善。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>OI 知识</tag>
      </tags>
  </entry>
  <entry>
    <title>除法取模</title>
    <url>/2022/03/23/%E9%99%A4%E6%B3%95%E5%8F%96%E6%A8%A1/</url>
    <content><![CDATA[<p>由费马小定理可推出：${1 \over a} \% m &#x3D; a^{m - 2} \% m$，其中$m$为素数。</p>
<p>那么，${b \over a} \% m$就可以变成$b \cdot a^{m - 2} \% m$。</p>
<p>当$m$太大时，可以使用<strong>快速幂</strong>。</p>
<p><a href="https://blog.csdn.net/qq742762377/article/details/83278688">来源</a></p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>OI 知识</tag>
      </tags>
  </entry>
  <entry>
    <title>近日训练与日常杂谈</title>
    <url>/2023/01/30/%E8%BF%91%E6%97%A5%E8%AE%AD%E7%BB%83%E4%B8%8E%E6%97%A5%E5%B8%B8%E6%9D%82%E8%B0%88/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="2c69797581bc4ddb614b3b0a7c2eedfc2a09be54b6b79ec216ecd7be292cbaea">6fcf1523ddce79b7eefea9a75525b524c632e7fbe3608e66b9e9b6d15757346c0e625f120b006f958dadacd5665fe9994f1516ffef23cfb1ed072d96dd3d14015a9f4fd06bdc57a75bc13e9b7b86ba3976f744bbde858e123c7b995543bc73a189968a4df5599dc1301da4ba23a3edc6b9577a027948b52561d2f9c1a9d02503d46077fb4ce13ef2090da9667edf167e0c6e47f482081e1312502c3d7a0a2b2192b99559c01264181757a761a8c578d51f4d567031aa18837b7ca2f96eae56536e526f3d95dbfa024c541d12d6629fb4827aa0cd7c7e85aafc6e40789c3c33bf74b64897c528a05f97e77eecd2d10e1bbdc8cc850063a48c1bf614170d81f5cab8b11090c0d6020aabc7704d738fd21a71ec6a3b0649cec9b415991c7dd8d86ee4e1001ac27a38ca72ffddf80b338ea063a858644fde1a9b17f6213ff6d7e0a9990b530602006445378886ce64d6cc6c6bdec38011392139c69ebadd771b279e54057d04c1207861174336321156a773e484bc68b59d20784e8e16a93f5507f92b825fe346ee041eab518e17d8f064ce9af7032cb61710ec8d333521350e9aa8b8579a4dffa5df5fdeaf0734b5fcf4ceb831a536df036db6c8477a86ac39641f2b6dca2b6cb3c50d0010d67b1132cfa604e6d9e8f6767a5f45b1e0b6d12697ffd620a1cb07d3fe94fd12b26e7333eaf8bcb3ea871ea6537949a75ccc6c4d505a77694a582553132d85ce108f46d900c990efb0e7e845270550b209c226c2fcd5d57c7c321e1879d87ef989201182b7471d0614f895d6e6f271fd5520ebbf709bdb0872715fd2bef081bfac911955175ea20ff61db18ec8663be1716067ad94cd58144cddea04bf1b60f7f9e3c6f15584d000ff635fd7aa544f19bd9f4f64c62d338d5e33e3d6503c227a9c860b38159e87822e9b0d8857226b5c15e8f325803528cf0487ec1782bb9f2145830eb8338bf54889f26a6a3edc018de95f911e3e4c188f30b7c0cc920165ca6b83837d27c3ba4dfba145cb6aaa999dc91113a5f3f1ad69942f510aa27e229f912fea177eb010b44029d24af0da189857f06e9a6f03197bf5b3a89501582672b9fa932b1d14048ff9879995343f319d1f2a22c8d409bf1da8e961cf3457d31a0ed31b839b0083ce2171e688a79a0854942b177aec2b4ac49c47ce85910a8a2ba8e4dae450b740036db72f6e97f2233aaee2c6e32f00f047e6f4a93241fe654fe23d9a55697d31082acde4c9cf191ac78a6e5da3a8e9bbec5ded085b66cca6806098b661fd986c427c56c05154ce148d1a6a5f7150ce00949ba083512293933ae4183c6c763a9abbf0937bf9681cb20d779122fc23df1c503777b0d9d03621f70041ce68416f2144e1fe99ba431ad6d51f43e1a29f03bc7d5bc5bae863f37ed9c745528dc6d1464cbe51de95ffb868c0b1d38d220ce825b9a270fb492b15e6d8241afed9207336e5051fbcec6029c092da1439729f6a15d874f556f08bf60283c1340f3557c39db00de63b46ed8aaf9afad23cca31804cf34e470b7e7781483d024eafc04132ecabcf0d0e5b6f5967b28cda58324a36466f6ced1bdcba0620baddcff1c0b0310b9768acd6634c039377dc3048e8e1f45119e92a74aa607b3f035bdeac79f08faa66c266bb9a7cef063c579b395f804a4223841002ab08366b350683f29a577ef5a63866897556aeb40b28e5985907ba3b287dd62d5ebcb65d64a0a4d4894ddef6389266097f227379d1b7ff8b4094a796a336de6c3bccead59e0c0322e7ebf5da9304bec65a8576186f9766704ad2d88703015f1ecd4742612bba5f04e317780ba02bef1ed911a043a2d5ee1eca87008949f7627939bcd8f64291d84e67143db554afdf32657dfdb23da4f48013398082bb0506f1b3f5c10305cb8ba2e8f51d1cc64346373983fdd13099e3eb06267e427203218ec4bce1f02aadb56365850d38e94ca5128464b0fca78acc2b7512c7033f5aef5bda79675c7e3607c2bfeaad8fab903c6259cae826f8dc01f80d338a00f4cb9b8c14b867b35731a4f46b0542bdc43a9eac4e309a90d6901cda5b5c82e4846330de279e4dddeac4c54ebdd40ca4f6016474a7cd80a7cf965a8c5e58fe7364be80636e4f2b5b14e5c11bb3c4b6dbe29c3a543e416bad23cea07b040fc1f86fcd686e23417ff74f7df4bb5cc265b35844e8da0f9cd1ea84d7d23cd115b179637ea2b526b34e890d00427699e4209deb6db2ab66748e03468c4ecd93bbee76c2f400200dd5e981e5ea028c831f82a0c04cdf9699d078a8454105dedfaab16c03e9da816115349ea29760844767f56f77c9f8896f7146342ff5864c63d5e3a5f5cc792ae906c54ef2036eb5878d28b9339b67532334aeab8c40b6c0661980983d0883e0dabed443fbf4cdfd4a0b12a6b141a4d3bb7e2f8ac200b1a8b36129f7194ad2e154b5b4e4ab13071945ad402509b465f0c155090d77b2a3175e1669334dec2ddd5a8004e884d17d841aa9e980141e5b131b55948d9e4ca1961cd179d0c2f416fb51575af3e0703ba32f5d25fa25fd89036e8bd6a91605abfc8eb1400e00b04caf5f3b159ccbb980e747c2572f8ff907394dad5b12e9fb39e786fb60e78f8cfc6142c8546ec1c5e5cc66c7073b46ecac07763cd12f9a16f81524a7eab0097585f671f6f2c64cd47aa97a2980e969716cf170f7a53f94b1167cf2f04ea754f5e4cb8e536e9549d11d17d2b90da2319fbebd74f3ab40dd8047074056c371454d804df137b12ec90eb48f008de38e03ba297c7d56f3c79a326f163817f1e10ad89be15fbb1850936074493b4132dd07fb81127fa269a5ba154369da88375fc9da60707026f2c4953de694cee99a050593d9100791d64081aa7322aa46d90d76ebe6e752f62e7b796333b24a98fe8b42bd0efd787e8567af2bfc1dafd4113f62eecd588170399a0be51c7c6c163033a99dc2762df4ffb1aea016f7178361bc6ada18ed3288ae3bb76127a1d7ab742f1a59c897215391fb70fc4ca10b8630dc3a9a4e0c125ba1e667e07185495d8cd6b9fa91e55f621b8bb48fbcc187739ec3544bd078d001cba8bfb863a0bf48c0d4789ee02b8dfb10cac82e5d5c5fbda80d7685bf08cc343013f07cc1d9deb1bc6d2e51099c96ed7179f625e91e78fc6245f85a522141d6a60ec6de4d7443a22165babe4d2d3c0cc1501085396c1cb20d055cc230c42429cdec1b74073dcd7ddff9d986c1ef20bf7d461212eef28b33e32fef84378072814b7dc333a6ff6c145b34182f8fc9017156ebc7083f279dc4ea126fa4a862aa8a8d8b0f9ec2ef067f8f496657ef1aad9a4c28dc614bf919c0217cc814b744105f155e352fcbd93e71e8870ce32e61053282347fec66ad6b421b0f14e2512b68c7a505a3088b42c977fbf4519de7bbdb7e555ba34274f87a76d826dcf3ae3c4fc6f4479859366bd57d1d6a11c2cc8b0a1d984833af898e2c1c17c14eb1dc779e93ec0026917f6156bf79fcfdb8ce84f005ebc6a4b6e8dde9b27bb5a80e7c187faa03af3f54ab92e96cee795eed5dc001f04ce440b9062df8e6c117d0f9bee2347a467894ed5aa3856d9f02232e2ef89239dc0aa374a02cdd0e65f2c8576905dbf83dd6bb81321e67c82dba6ee425f00ba54f8cca356411e55793dae174e8332492067cd3ac5df857b6a79a988beb0209e7c78557e0caa688574f7efae44f10dbc04ca49dfaede45ecd33237bbcfcfcf9d5cdc5b6322ea2d22cdc9fb787489f6672c5991224a804e5dd2dea4306e33f72f0f6e36ce1f77222f7cbdf87e7ad0657bd603f429f417a7cc8c3d55aecb505ce59ac9729d40f624a751330b2c65bfc5871d9107fe50f57efa912632af1a417b662a83862c86ad68c36819f3dfda74e2e29e8b7f9f42f506c578e3e53c1126b05e31931f9256fa36d427f7893dc23388bf54c981f19dde10f08287611701655f14779807ad4ecb51983a1583777aafcb9fbe143db0867f03c1a5e1c46e9a0e8a4eda63ecfb1b08df2e007f0d6a87e103e1ac18671b501a54a1788b735c57ffe7fdad9f10c88d01bea9bcf53995b16b6c44556e908a0185bbe66a67f748a7fae14e76befcd44df80d034f22b2d2b834cffbe24f1eda80d8287537fbd6c9614694d68bedfc099ff57cac2d099bdba9c4aea9ea49026e6a7a16fcd2f8667af315afb925893be0efdfe210d5dda1dc927f7d555149254998e07bba4da8f3e8393d20d07d1afaf4f78935568f86fce0e9e2fe44fb2452100c22f0b7e348efc9705f46418000870ad0cc18a4656f72eb557e5229a40bf74d12091989a267dcdcdd73c6c89bcf300fb85ea4f4d29a75c75f348cedc985e2a93c286243b0c650493b1be8b86667c510f92635263ca3d607ce507e67cbd75de4206f00d99a4dafaab1f89c2e1160217bc63e7dedb25d36b355126287aaf38afb037ede9c13969220a5cb43a6c612f3f9fab1e330aff75f0a667939b25a407bc934019c119782c5d4a9ad3871ea4030899ea46fd8dfe1b4aab169df2d7d341f89c2c416a9d4cada22d287d998cc3df4c3c8c85b7fd74fdbe07fea0ac913c38d491b69c83b419bd832992fa146a1fd2057af208206de6da02608790676e213476fec21a3e0c1572c853933899c1a1c9fc26dbbb06e34dd9a9c84a6e6fa4df08e6d7b7ce10408a991a11d52196d54dc0863ed798cfa628bfce35a0494b9dd0179fa1079635fe3b4f475b7c26978bf9bcbdc87397024430ea64d86606d553cafa373bfa8a8d87ecf117fe6a388692f036f4a4367161a829f7dfe9038d9c19979166a55e93bc138af08d8bc44392e4e58fdf8b0f5e4494d6a27af56a5f1706400259712548968cf6fe135c94c1f9e0a29859c675f6f57e867cb9169adc4c57e3726be062d68ea9a339582e65770ca1a21438faf03bc29c38da375c5412bae107bba0de16905f9bfd05a2a39ca95fd7c374e6b64fda9442c0d71c0cc9f0815be7e8f1a4595c69b921fd83a8f7dad643a5da3ce775441a1fc88adb70a985ca3c8ad4e4c4dcca9289dc2ca4afb49f0dbca437831447f1ee8f3a27d8c6d407591c846b328f16d4e9c96213dbdfcf215b2251f273c6da6021b69b002af709992cab1f46185ff3d0e4b687212a1d05c02abc150d5ac1d1fd48535c98afc2a817b5f2eda418ea3e2f2852850021a09bc693619dbe078d3eda0b905d1daf81ae933efa865aac8951c0a7ea61cbd85ff66093692d917b2d6b5baa4556514025d7de192eaee52c7b30577ee46d9a1dfdc4433a8098ad1dd62a679192780ee86c521870fe1d5c65ea9c8e257f8ae594d34f4d5c62001ef2c8ab3c1b8317f927f1508bfadfdfce9285d42a50ba13fb80ed72feffd8b4312664d84e8c1613ca89db9e290da8a201744a37df1c4e057e471f97cc1cc110b9490f199fc06de2ac2c3d98f732dcc93ef54a28a1fdc334c6258ad6f75b1a378003708728ede1a23805db0040c706edb51085f6227b77f07e820c41d167605e1105265c228a176b</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>OI 知识</tag>
      </tags>
  </entry>
  <entry>
    <title>保研日记</title>
    <url>/2023/10/29/%E4%BF%9D%E7%A0%94%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="个人背景"><a href="#个人背景" class="headerlink" title="个人背景"></a>个人背景</h1><p><strong>学校：</strong>某农业大学四非CS（弱势专业）；</p>
<p><strong>成绩：</strong>前五学期 7&#x2F;316，88.4；前六学期 9&#x2F;320，88.3；综合成绩 7&#x2F;320，89.2；</p>
<p><strong>英语：</strong>CET4 457，CET6 451；</p>
<p><strong>科研：</strong>遥感方向，时长 2 年，有 DL 基础；</p>
<p><strong>竞赛：</strong>蓝桥杯国二，CCPC 省一，农林杯数学建模省一等；</p>
<p><strong>论文：</strong>一篇 2023 年 5 月左右刚投递的遥感方向 SCI 一区，二作。（夏令营结束后过一审）</p>
<p><strong>最终去向：</strong>华东理工大学计算机技术（专硕）。</p>
<p><img src="/2023/10/29/%E4%BF%9D%E7%A0%94%E6%97%A5%E8%AE%B0/%E5%BE%85%E5%BD%95%E5%8F%96%E9%80%9A%E7%9F%A5.png" alt="img"></p>
<h1 id="填报思路"><a href="#填报思路" class="headerlink" title="填报思路"></a>填报思路</h1><p><strong>学位选择</strong></p>
<p>夏令营期间：此时对自己的定位还不清晰，反感专硕，希望能够上学硕或者直博，总体而言希望读博深造。</p>
<p>夏令营结束后：经过了几轮大佬的打击，明确了自己与顶尖选手间的明显差距。结合上 CS 35 岁瓶颈期、博士压力与自身情况，目光转向专硕与学硕。</p>
<p><strong>学校、方向、导师选择</strong></p>
<p>夏令营期间：学校 &gt; 导师 &gt; 方向。全部海投，能入哪个去哪个。</p>
<p>夏令营结束后：学校 &gt; 方向 &gt; 导师。由于此时已经基本决定读硕后工作，因此学校最为重要，希望为 985。确定了自己更倾向于传统计算机方向，虽然对 AI 有兴趣但因为其卷上加卷的特性，因此 CV 与 NLP 都是第二手的选择。在此前基础上尽量避免坑导。</p>
<p><strong>投递选择</strong></p>
<p>夏令营期间：全部海投，能入哪个去哪个。</p>
<p>预推免期间：因为有了华中师范保底（211，CS 第四轮评估B-），因此层次上筛掉所有 211 以下学校，地区上筛掉所有偏远 211（相对于我来说），专业上筛掉 CS 第四轮评估低于 B 的学校（除了几个个例）。之后放弃网安（在中科大感受到了内容差距），主投计科，副投软工。</p>
<h1 id="保研过程"><a href="#保研过程" class="headerlink" title="保研过程"></a>保研过程</h1><h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h2><h3 id="资料准备"><a href="#资料准备" class="headerlink" title="资料准备"></a>资料准备</h3><ul>
<li>各种尺寸的证件照</li>
<li>各种常用个人信息汇总、套磁模板、个人简历、个人简介</li>
<li>专家推荐信（我最终也没有准备好，也导致了我和一些学校无缘）</li>
<li>电子成绩单、成绩排名证明、学信网学籍在线验证报告、学生证身份证</li>
<li>英语、竞赛等证书、论文原文的复印件电子版</li>
</ul>
<h3 id="复习内容"><a href="#复习内容" class="headerlink" title="复习内容"></a>复习内容</h3><ul>
<li>英语口语（可以背模板）</li>
<li>408（数据结构、操作系统、计网、计组）</li>
<li>数学（高数、线代、概率论）</li>
<li>机器学习</li>
</ul>
<h2 id="夏令营"><a href="#夏令营" class="headerlink" title="夏令营"></a>夏令营</h2><h3 id="投递"><a href="#投递" class="headerlink" title="投递"></a>投递</h3><p>海投，一共投递了 40 多所学校，可以说把所有不需要推荐信的开了夏令营的学校全投了一个遍。当然最后的结果也是意料之中的惨淡。</p>
<h3 id="入营"><a href="#入营" class="headerlink" title="入营"></a>入营</h3><p><strong>天津大学智能计算学部</strong></p>
<p>线上海王营，点击就送。进群后发现有 2000 多人，之后经历一轮机试初筛后剩 600 人左右。机试是在天大的评测网站上进行的，做好双机位线上答题，算是半 ACM 半 OI 赛制。提交可以进行小数据评测返回结果，最后所有程序还要在整个数据上再跑一遍，也就是小数据正确不保证全部数据正确。题目很简单，大概是竞赛入门到中等的难度，因为有竞赛基础，遂很轻松就进了。</p>
<p>之后是线上团队宣讲，宣讲后自己进入喜欢的团队的招生群，之后再由各团队组织面试（可以进多个群，但有问卷只能在一处面试）。因为 600 人海王的原因，看到了有些群里进 60 人争抢 4 人名额的情况，但相比于此更令我反感的是我加入的团队自己又进行了一轮筛选，导致我根本没有面试机会。我选的是一个和强化学习有关的团队，如果同样有和我一样实力不足的四非学子建议避开，毕竟每一场面试所能积累下的经验都是很可贵的。于是在参加了机试和宣讲，耗费了我近 2 天的时间下，我与天大无缘。</p>
<p><strong>浙江大学软件学院</strong></p>
<p>线上海王营，点击就送。同样是几千人大群。时间跨度很长，宣讲很多。不同的团队会发布不同的课题供你选择，你选择其中一个在大概一周的时间内做完并向老师展示，就基本能敲定优营名额。虽然听起来很美好，但有几个致命的问题：</p>
<ul>
<li>浙软优营不等于录取，只是获得了免筛入预推免的机会。</li>
<li>7 天不短，完全有可能在在这段时间内与各种其它营相互冲突，导致最后没有太多时间放在项目上。</li>
<li>浙软风评很差，具体可以上某乎查查。</li>
</ul>
<p>基于以上三点，在我对项目进行简单尝试后放弃。不过虽然入营很多，但大部分人都跟我一样并不会做到底。因此若你的意愿非常强烈，基本上项目做完就是优营。</p>
<p><strong>中科大信工所</strong></p>
<p>线上海王营，点击就送。同样是几千人大群。同样时间跨度很长，宣讲很多。与天大智算十分类似，但组织更加规范，流程更长，名额也更多。需要预先填写一大堆资料，听完各室宣讲后只能选择一个室参加面试。有了天大的前车之鉴，这次我没有花费大量时间处理那堆资料，而是先选了六室后观望了一下，最后果然没给我面试机会。但信工所的老师都很负责，后续态度也很友好，只是我个人水平问题与信工所无缘。不过听说今年三室没有筛任何人，其他四非学子可以在选择时多考虑一下。</p>
<p><strong>华中师范计算机学院</strong></p>
<p>可线上可线下，略微海王营。进了 500 人左右，最后有大概不到 50 人参加了线下，350人左右线上。夏令营只有两天，第一天是宣讲，印象中是笼统介绍了计算机、人工智能、软工与一些网安内容。第二天的考核是写一篇文章，谈谈你对昨天老师所讲的看法与自己的兴趣方向，中英文各写一遍。我觉得自己写的还蛮丑陋的，但最后还是拿到了优营。但发布的优营同样很海，是 165 个优秀营员与 70 个合格营员，且对于优营是否是 offer 这一点老师一直不做正面回应，只是说拿到优营还需要参加预推免，但几乎不再可能被筛掉。遂当时将其当作一个保底了，但也没有联系老师，没想到到了预推免了无音讯。</p>
<p><strong>上海大学通信学院</strong></p>
<p>需线下。与信工所、华中师范冲突，且考虑到学院不对口、似乎是纯宣讲不发优营，遂放弃。</p>
<p><strong>东北师范大学计算机学院</strong></p>
<p>需线下。组织较差且海王，大概是开营前 2 天才发出了具体通知。此时我已拿到华中师范优营，遂放弃。</p>
<p><strong>中国科学技术大学网络安全学院</strong></p>
<p>线下营，仅 120 人，最难忘的经历。能进入中科大夏令营我是极其意外的，意外到以为对方看错了我的信息。整个名单中 985 占比约 6 成，211 约 4 成，1 个双非和 1 个四非（我），因此我几乎是以倒数第一的身份入营。犹豫一番后，顶着巨大的心理压力参营。整个流程的体验极好，这一趟也让我收获了诸多内容。</p>
<p>前一天下午去安排的酒店签到，同时送了中科大大礼包，有书包衣服卡包等等内容，也见到了我的大佬舍友，对了一对背景就几乎已经知道我自己这一趟的结局了。</p>
<p>第一天的上午是开营仪式，在中校区一个很大的场馆举行，在 B 站上还有直播。下午就是听一下院内老师的介绍后就可以自由活动了，是悠闲的一天，也是在这一天了解到了中科大的录取方式。首先几乎入营即优营，老师给出的优营比例大概有 80%。但优营并不意味录取，你需要自己联系老师达成双选后才算录取。这个制度本身很好，但对于我这种摸奖进了中科大的人来说，算是进一步抹杀了被录取的机会。一是这说明在这个时间点上，大部分老师很可能已经被预先预定得差不多了；二是少有中科大的老师会选择要一个普通的四非学子。</p>
<p>开幕式的场馆：</p>
<p><img src="/2023/10/29/%E4%BF%9D%E7%A0%94%E6%97%A5%E8%AE%B0/%E4%B8%AD%E7%A7%91%E5%A4%A7%E5%BC%80%E5%B9%95%E5%BC%8F.jpg" alt="img"></p>
<p>网安夏令营的牌子：</p>
<p><img src="/2023/10/29/%E4%BF%9D%E7%A0%94%E6%97%A5%E8%AE%B0/%E4%B8%AD%E7%A7%91%E5%A4%A7%E7%BD%91%E5%AE%89%E7%89%8C%E5%AD%90.jpg" alt="img"></p>
<p>中校区的样子：</p>
<p><img src="/2023/10/29/%E4%BF%9D%E7%A0%94%E6%97%A5%E8%AE%B0/%E4%B8%AD%E7%A7%91%E5%A4%A7%E4%B8%AD%E6%A0%A1%E5%8C%BA.jpg" alt="img"></p>
<p>第二天是正式的网安宣讲。网安学院不在主校区那边，需要坐大巴去高新校区，虽然偏一些，但看上去的确整洁与广阔很多。此时就在带领下周转各个团队的办公室。不过听我的舍友说（他是网安的）中科大的方向不太传统，我印象比较深的是有图像识别、遥距感知、量子计算这些看上去不太网安的方向，但如隐私计算，硬件安全等也都有涉及。</p>
<p>高新校区的样子：</p>
<p><img src="/2023/10/29/%E4%BF%9D%E7%A0%94%E6%97%A5%E8%AE%B0/%E4%B8%AD%E7%A7%91%E5%A4%A7%E9%AB%98%E6%96%B0%E6%A0%A1%E5%8C%BA1.jpg" alt="img"></p>
<p><img src="/2023/10/29/%E4%BF%9D%E7%A0%94%E6%97%A5%E8%AE%B0/%E4%B8%AD%E7%A7%91%E5%A4%A7%E9%AB%98%E6%96%B0%E6%A0%A1%E5%8C%BA2.jpg" alt="img"></p>
<p>第三天是面试，分上午下午两场，分组后按照顺序一个一个去。我几乎排到本组最后一名，每场面试都要等近 2 小时，加上这竟是我保研期间的第一场面试，当时自己已经游离在崩溃的边缘了。上下午流程相同，进去后有 3 位老师。我那两场里没有固定流程，进去后看老师的心情做英文&#x2F;中文自我介绍，之后就进入了唠背景环节（也可能是高优营率的缘故）。上午的老师追问了我一些校区和我那篇论文中一小部分图像识别的问题，整体氛围还算轻松；到了下午看到老师见到我简历后皱眉的表情，顿感事情不妙，之后给我的感觉有些像压力面，不过这也可能只是老师风格的原因。依旧是追问我的论文，没有问任何英语问题或专业问题，但因为老师始终在追问我论文中涉及到图像识别的一小部分，而这部分并非论文的核心也并非我负责的核心，因此几乎被问崩了。也是这两场后我直接将那一小部分经历从我的简历上划去了，因为如果不划去，做遥感方向的老师本身就少一些，反而大部分老师均被我不熟练的那小部分图像识别所吸引。之后就是出去和舍友玩了一场，南方的火锅还蛮好吃的，但是南方的麻酱做的确实不行。</p>
<p>第四天早上收到了遗憾未优营的通知。虽然这是早就预计到的结果，但这则通知让最后一点侥幸也消失了。就这样离开了中科大，同时也意味着我的夏令营阶段落幕。</p>
<p>结束后去到了门口打卡：</p>
<p><img src="/2023/10/29/%E4%BF%9D%E7%A0%94%E6%97%A5%E8%AE%B0/%E4%B8%AD%E7%A7%91%E5%A4%A7%E5%A4%A7%E9%97%A8.jpg" alt="img"></p>
<h2 id="预推免"><a href="#预推免" class="headerlink" title="预推免"></a>预推免</h2><h3 id="投递-1"><a href="#投递-1" class="headerlink" title="投递"></a>投递</h3><p>继续海投，不过因为自己根据以为的华中师范 offer 做了筛选，所以最终只投了不到30所学校，其中 211 的占比也更大。</p>
<h3 id="入推免"><a href="#入推免" class="headerlink" title="入推免"></a>入推免</h3><p><strong>苏州大学计算机学院</strong></p>
<p>线下机试，通过即获得与导师双选的资格。内容简单，但难度在于时间短题目多，同时虽然像 OI 但并非 OI ，算法题还要强制使用与完善给好的树的板子，因此很不适应。机试完几天后邮件告知未获取资格。不过也许并非完全是我题目做的很差，一是机试共三轮（一轮夏令营，两轮预推免），我参加了最后一轮，很有可能因为饱和的原因越靠后越难进；二是因为机试结果完全不透明，很难说是否是完全按照机试排名分配资格的。但当时也无暇考虑那么多，因为同期我还收到了华东理工的面试通知，机试结束后就做高铁从苏州直奔上海。</p>
<p><strong>华东理工大学计算机学院</strong></p>
<p>线下面试，他们学院下分点，计算机点进进出出最后大概也就 70 人左右参加了面试。本趟的体验很好，老师也很和蔼，对我来说几乎算是背景面，但由于签了保密协议，因此就不再透露面试的具体流程了。大概一周后收到专硕的 offer，悬着的心终于放下，在此之后进入了一种半躺平的状态。不过要注意华理的学硕名额极少，因为还要留给本校生所以外校保研几乎是拿不到的。</p>
<p><strong>兰州大学计算机学院</strong></p>
<p>太太太远了，计算机的评级低，地方偏，思考后放弃。</p>
<p><strong>上海大学计算机学院</strong></p>
<p>坑人。面试资格无邮件无短信无电话，只有站内通知，看到时已经错过了。</p>
<p><strong>北京工业大学计算机学院</strong></p>
<p>坑人。面试资格无邮件无短信无电话，只有站内通知，看到时已经错过了。</p>
<p><strong>南京航空航天大学计算机学院</strong></p>
<p>线下面试，线下还海，体验极差。当时在去南京的路上联系到了华理的老师，导致我一度想要放弃面试，但最终抱着来都来了的想法还是去面了，但说实话面完后悔了，完全没有体验。线下都有几百人去了，所有人进等候厅都用了快 2 个小时，在此之前全程站着。还好我在组内的面试顺序比较靠前。当时坐在我身边是一个南大的同学，足可见是真的一点没筛，但他排名十分靠后，我记得是 20 多的样子，不知道他会不会后悔来南航……面试是三个老师，面试流程比较规范，我还有些印象就列一下：</p>
<ol>
<li>中文介绍，3 分钟左右；</li>
<li>英语问题，介绍你的学校，如何应对 deadline 带来的压力；</li>
<li>背景提问，问了我的学校，论文情况；</li>
<li>专业问题，什么是虚拟内存，栈的应用，为什么选择排序比冒泡排序快，100 个队伍打比赛多少场决出冠军。</li>
</ol>
<p>当时几乎完全躺平了，心里主要着急找时间和华理老师沟通，于是一点没复习，答得也是稀烂，但倒也没什么心理压力。面完后在南京玩了 1 天，之后我的预推免阶段结束。</p>
<p>一些玩的照片，只是乱转：</p>
<p><img src="/2023/10/29/%E4%BF%9D%E7%A0%94%E6%97%A5%E8%AE%B0/%E5%8D%97%E4%BA%AC%E6%B8%B8%E7%8E%A91.jpg" alt="img"></p>
<p><img src="/2023/10/29/%E4%BF%9D%E7%A0%94%E6%97%A5%E8%AE%B0/%E5%8D%97%E4%BA%AC%E6%B8%B8%E7%8E%A92.jpg" alt="img"></p>
<p><strong>天津大学智能计算学部</strong></p>
<p>天大的预推免同样是先机试后获得资格，机试时间在去南航之前，内容与夏令营筛选完全一致，只不过筛的人更多一些，但还是很轻松就入了。比较有趣的是遇到了一个负责的二次元学长，在我犹豫要不要机试时打电话问我，于是才参加的。结果在南航后出了，且面试时间与南航很紧，需要面完南航直奔天津。当时考虑到苏大的经历（天大预推免也是两轮，我是末轮），加上天大鸽人的坏名声、夏令营的状况、自身已经状态不佳等因素，最终鸽掉，也算是体验了一次鸽海王学校的感觉。不过隔天调整面试次序也能看到有几乎一半入选后决定参加面试的同学都和我一样鸽掉了。</p>
<h2 id="九推"><a href="#九推" class="headerlink" title="九推"></a>九推</h2><p>929 当天系统炸了一会，不过还是稳稳上岸华理了，没有参与后续九推的捡漏环节，算是为整个保研经历画上了句号。</p>
<h1 id="经验总结"><a href="#经验总结" class="headerlink" title="经验总结"></a>经验总结</h1><p>因为各个阶段都可能有一些感悟或者遇到一些坑点，所以就把这些内容统一留在末尾了：</p>
<ol>
<li>保研是一场信息战，大部分人走到最后都会或多或少错过些什么或者忘准备些什么。</li>
<li>由于 CS 专业实在太卷了，对于大部分四非 CS 学子进一所 211 是常态，不要被网上那么多四非 CS 进 985 名校的帖子所影响，他们或许来自计算机强校、或许自身硬实力强劲、或许有论文竞赛加持、或许有运气成分，但一定不是常态。</li>
<li>对于大部分保研选手尤其是四非保研选手来说，保研的是一场痛苦的拉锯战。在这近 2 个月的时间里你会填资料填到头疼，见识到各种大佬，在一趟趟旅程中消磨金钱与耐心，体会到每一场面试前的心跳加速，等待学校回应的煎熬与被拒绝时的失落。但请不要失去信心，几乎所有坚持到最后的同学都能有一个不错的去向，就像我能进中科大和华理一样，你可以用 2 个月的不断努力来搏得那几次属于你自己的幸运。</li>
<li>准备工作要趁早，因为为了海投需要准备大量内容类似但格式不同的资料；报名也要趁早，很多学校都是动态审核，报的越晚入的难度越高。</li>
<li>如果不报最卷的 CS 的话不建议 CS 报网安，虽然好入但感觉二者的内容还是有一定差别的。相对来说计算机报 SE 契合度较高，如果有 AI 基础的话报 AI 也是可以考虑的。</li>
<li>不要仅看绿裙提供的汇总信息，其中是有遗漏的，有时间还是要自己去翻翻各高校官网。华理预推免就没在汇总中。</li>
<li>同校保研选手间多联系，少扎堆入同一学校，不然的话很有可能学校只会重点关注绩点高的前几个人。</li>
<li>夏令营与预推免之间没有明确的间隔期。有些学校有夏令营有预推免，那么它的预推免可能会晚些；有些学校只有预推免，那么它的预推免就可能会早些。我因为在夏令营结束后大概 20 天没有继续关注学校动态而错失了一些学校。</li>
<li>套磁一定要做且一定要早做（尽可能在夏令营前开始）。套磁不仅能在某些老师那里直接拿到资格，还有可能能让老师捞你入营。当然套磁是一个很折磨的过程，因为你如果没有过硬的水准，大部分老师都是已读不回或官回，但即使这样也一定不要害怕套磁或受到打击，海投就对了。</li>
<li>所有的协议都是君子协议，即使校方再肯定的跟你说要你，但它最后放弃你也不需要付任何法律责任，每年也确实有部分学院是这样做的，因此对于学生而言必须多留几个 offer 保底。学校失去你只是失去了一个名额，而你失去所有学校则意味着保研失败。</li>
</ol>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>我是大三下才仓促开始为保研做准备的。当时的我以为进入一所 985 是一件极有希望的事情，也曾无数次在脑海中想象最后接受梦校的拟录取时的场面。但随着保研流程开始推进，当其它名校的学生与我进入同一条拥挤的赛道，当自己的眼界穿过本校看向全国，巨大的压力随之而来时，我才真切的意识到自己的微不足道与脆弱。虽偶尔也会因身边发生的名场面而乐在其中，亦或是与其他保研选手交流以相互慰藉，但在保研的路上压力与孤独并存才是常态。我总于深夜在软件上浏览其他人的保研经历与有关保研失败的帖子长达数小时，甚至在预推免期间因为压力导致心脏都会疼，每一次尝试靠近曾经的梦想都会感受到深渊般的绝望。于是在这场几乎只存在高手的对局中，我必须承认自己学校的平庸，竞赛与科研水平的不足，自己与他人的差距，于是才能放下不切实际的幻想，才能够沉下心为每一场面试做好准备，才能够在诸多学校中找到属于自己水平的位置。最后系统开启，提示我接受华东理工大学拟录取时，原以为自己会十分激动，但实际上就是点击鼠标后长舒一口气，仅此而已。大概是因为这就是放下名校情结后匹配的上自己 2 个月的奔波的结局吧。</p>
]]></content>
      <categories>
        <category>日常</category>
      </categories>
  </entry>
  <entry>
    <title>神经网络与深度学习</title>
    <url>/2022/05/31/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="神经网络"><a href="#神经网络" class="headerlink" title="神经网络"></a>神经网络</h1><p>机器学习包括神经网络，神经网络是深度学习的重要前置知识点。</p>
<p>神经网络是一种模拟人脑神经元的方法。</p>
<p>经典神经网络结构图包括输入层、隐藏层、输出层。中间有单向的连线，每个连线对应一个不同的<strong>权重</strong>，相当于人工神经网络的<strong>记忆</strong>，这是需要<strong>训练</strong>得到的。</p>
<h2 id="基本特征"><a href="#基本特征" class="headerlink" title="基本特征"></a>基本特征</h2><ol>
<li>非线性：不按比例，不成直线的关系。</li>
<li>非局限性：一个神经网络通常由多个神经元广泛连接而成。</li>
</ol>
<p>联想记忆是一个典型例子。</p>
<ol start="3">
<li>非常定性</li>
</ol>
<p>人工神经网络具有自适应、自组织、自学习能力。神经网络不但处理的信息可以有各种变化，而且在处理信息的同时，非线性动力系统本身也在不断变化。经常采用迭代过程描写动力系统的演化过程。</p>
<p>人工神经网络像一个黑盒子，用于模拟任何函数。由于其采用整体逼近的方式，不会由于个别样本误差而影响整个模型特性，即容错特性。</p>
<ol start="4">
<li>非凸性</li>
</ol>
<p>指这种函数有多个极值，故系统具有多个较稳定的平稳态，这将导致系统演化的多样性。</p>
<h1 id="人工神经元MP模型与-Hebb-学习律"><a href="#人工神经元MP模型与-Hebb-学习律" class="headerlink" title="人工神经元MP模型与 Hebb 学习律"></a>人工神经元MP模型与 Hebb 学习律</h1><p>这里需要一些图。</p>
<p>当时的权值都是固定的，预先设置好的。</p>
<h2 id="Hebb-学习律"><a href="#Hebb-学习律" class="headerlink" title="Hebb 学习律"></a>Hebb 学习律</h2><p>Hebb 考虑调整权值来机器学习。</p>
<p>反复刺激会加强刺激效果。</p>
<h3 id="线性联想器"><a href="#线性联想器" class="headerlink" title="线性联想器"></a>线性联想器</h3><p>这里需要一些图。</p>
<p>用目标输出代替实际输出。</p>
<p>$$<br>w_{ij} &#x3D; w_{ij} + t_i p_j<br>$$</p>
<p>$$<br>W &#x3D; TP^T<br>$$</p>
<p>带入</p>
<p>$$<br>Wp_1, Wp_2<br>$$</p>
<h1 id="感知器网络"><a href="#感知器网络" class="headerlink" title="感知器网络"></a>感知器网络</h1><p>监督学习：使用已标记的数据集训练</p>
<p>分类、回归</p>
<p>半监督学习：使用一部分标记数据和大量未标记数据做数据集训练</p>
<p>分类、回归、聚类</p>
<p>无监督学习：使用未标记的数据集训练</p>
<p>聚类</p>
<ul>
<li>感知机由美国计算机科学家罗森布拉特于1957年提出，其神经元结构就是 MP 模型。</li>
<li>感知机神经元是在 MP 模基础上加上了学习功能，其权值根据设计目的加以调节。</li>
<li>感知机特别适合简单的模式分类问题，可解决线性划分问题。</li>
</ul>
<p><img src="/2022/05/31/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%84%9F%E7%9F%A5%E5%99%A8%E7%A5%9E%E7%BB%8F%E5%85%83%E6%A8%A1%E5%9E%8B.png" alt="img"></p>
<p>$$<br>n &#x3D; \sum^r_{j &#x3D; 1} w_j p_j + b	\quad a &#x3D; f(n) &#x3D;<br>\begin{cases}<br>1 \quad n \geq 0 \\<br>0 \quad n &lt; 0 \\<br>\end{cases}<br>$$</p>
<p>$$<br>a &#x3D; f(W P + b) &#x3D; f(\sum^r_{j &#x3D; 1} w_j p_j + b) &#x3D;<br>\begin{cases}<br>1 \quad n \geq 0 \\<br>0 \quad n &lt; 0 \\<br>\end{cases}<br>$$</p>
<ul>
<li>一般感知机结构是一单层神经网络，其激活函数为二值函数。</li>
</ul>
<p><img src="/2022/05/31/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%84%9F%E7%9F%A5%E5%99%A8%E7%9A%84%E7%BD%91%E7%BB%9C%E7%BB%93%E6%9E%84.jpg" alt="img"></p>
<p><strong>感知器的权值与偏差</strong></p>
<p>设置偏差 b 是为了增加神经网络可塑性，多一个可调参数。</p>
<p>$$<br>W_{s \cdot r} &#x3D;<br>\begin{bmatrix}<br>w_{11} &amp; w_{12} &amp; \cdots &amp; w_{1r} \\<br>w_{21} &amp; w_{22} &amp; \cdots &amp; w_{2r} \\<br>\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\<br>w_{s1} &amp; w_{s2} &amp; \cdots &amp; w_{sr} \\<br>\end{bmatrix}<br>,<br>B_{s \cdot 1} &#x3D;<br>\begin{bmatrix}<br>b_1 \\<br>b_2 \\<br>\vdots \\<br>b_s \\<br>\end{bmatrix}<br>$$</p>
<p><strong>感知器的多组输入输出</strong></p>
<p>$$<br>P_{r \cdot q} &#x3D;<br>\begin{bmatrix}<br>p_{11} &amp; p_{12} &amp; \cdots &amp; p_{1q} \\<br>p_{21} &amp; p_{22} &amp; \cdots &amp; p_{2q} \\<br>\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\<br>p_{r1} &amp; p_{r2} &amp; \cdots &amp; p_{rq} \\<br>\end{bmatrix}<br>,<br>A_{r \cdot q} &#x3D;<br>\begin{bmatrix}<br>a_{11} &amp; a_{12} &amp; \cdots &amp; a_{1q} \\<br>a_{21} &amp; a_{22} &amp; \cdots &amp; a_{2q} \\<br>\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\<br>a_{s1} &amp; a_{s2} &amp; \cdots &amp; a_{sq} \\<br>\end{bmatrix}<br>,<br>B_{s \cdot q} &#x3D;<br>\begin{bmatrix}<br>B_{s \cdot 1} &amp; B_{s \cdot 1} &amp; \cdots &amp; B_{s \cdot 1}<br>\end{bmatrix}<br>$$</p>
<p><strong>感知器的图形解释</strong></p>
<p>任意一组参数 W 和 b ，在输入矢量空间中，可决定一条（超）直线或（超）平面等，在该直线或平面上方输出为 1 ，下放输出为 0 。</p>
<p><strong>感知器的输入输出关系</strong></p>
<p>分类能力：感知器只能进行线性分类。</p>
<p>分类数目：单个神经元可将输入空间的矢量非储层两类。</p>
<p>s 个神经元组成的感知器将输入空间分成$2^s$类。</p>
<p>我们将构成 W 的第 i 个行向量定义为：</p>
<p>$$<br>i^W &#x3D;<br>\begin{bmatrix}<br>w_{i, 1} \\<br>w_{i, 2} \\<br>\vdots \\<br>w_{i, R} \\<br>\end{bmatrix}<br>$$</p>
<p>据此，可将权值矩阵 W 重写为：</p>
<p>$$<br>W &#x3D;<br>\begin{bmatrix}<br>{1^W}^T \\<br>{2^W}^T \\<br>\vdots \\<br>{S^W}^T \\<br>\end{bmatrix}<br>$$</p>
<p>这样就可以将网络输出向量的第 i 个元素写成：</p>
<p>$$<br>a_i &#x3D; hardlim(n_i) &#x3D; hardlim({i^W}^T p + b_i)<br>$$</p>
<h2 id="单神经元感知器"><a href="#单神经元感知器" class="headerlink" title="单神经元感知器"></a>单神经元感知器</h2><p>s &#x3D; 1, r &#x3D; 2。</p>
<p><img src="/2022/05/31/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E5%8F%8C%E8%BE%93%E5%85%A5%E6%84%9F%E7%9F%A5%E6%9C%BA%E5%88%A4%E5%AE%9A%E8%BE%B9%E7%95%8C.jpg" alt="img"></p>
<p>边界上所有点输入向量与权值向量的内积相同。因此该边界一定与权值向量垂直。</p>
<p>阴影区内任意输入向量都有着大于 -b 的内积，无阴影区内任意输入向量都有着小于 -b 的内积。</p>
<p>因此权值向量$1^W$总是指向神经元输出为 1 的区域。</p>
<h3 id="与门逻辑感知器"><a href="#与门逻辑感知器" class="headerlink" title="与门逻辑感知器"></a>与门逻辑感知器</h3><p>图</p>
<h3 id="或门逻辑感知器"><a href="#或门逻辑感知器" class="headerlink" title="或门逻辑感知器"></a>或门逻辑感知器</h3><p>图</p>
<h3 id="线性不可分问题"><a href="#线性不可分问题" class="headerlink" title="线性不可分问题"></a>线性不可分问题</h3><p>异或问题</p>
<p>不能解决</p>
<h2 id="感知器的学习规则"><a href="#感知器的学习规则" class="headerlink" title="感知器的学习规则"></a>感知器的学习规则</h2><ul>
<li>如果第 i 个神经元输出正确，即$a_i &#x3D; t_i$，权值与偏差保持不变。</li>
<li>如果第 i 个神经元输出不正确，改变权值与偏差。<ul>
<li>若$a_i &#x3D; 0, t_i &#x3D; 1$，则修正的算法为：$w_{new} &#x3D; w_{old} + p^T, b_i &#x3D; b_i + 1$。</li>
<li>若$a_i &#x3D; 1, t_i &#x3D; 0$，则修正的算法为：$w_{new} &#x3D; w_{old} - p^T, b_i &#x3D; b_i - 1$。</li>
</ul>
</li>
</ul>
<p>一点说明：在$a_i &#x3D; 1, t_i &#x3D; 0$的情况中，$旧 n_i &#x3D; W_i P + b \geq 0$，但$新 n_i &#x3D; (W_i - p^T) P + b &#x3D; 旧 n_i - P^T P &lt; 旧 n_i$。</p>
<p><strong>学习的统一表达式：</strong></p>
<p>感知器修正权值公式：</p>
<ul>
<li>分量表示：</li>
</ul>
<p>$$<br>\begin{aligned}<br>&amp; \Delta  w_{ij} &#x3D; (t_i - a_i) \cdot p_j^T \\<br>&amp; \Delta  b_i &#x3D; (t_i - a_i) \cdot 1 \\<br>\end{aligned}<br>$$</p>
<ul>
<li>矩阵表示：</li>
</ul>
<p>设$E &#x3D; T - A$为误差矢量，</p>
<p>$$<br>\begin{aligned}<br>&amp; W &#x3D; W + E P^T \quad or \quad \Delta W &#x3D; E P^T \\<br>&amp; B &#x3D; B + E \quad or \quad \Delta B &#x3D; E \\<br>\end{aligned}<br>$$</p>
<p><strong>学习的收敛性：</strong>该算法属于梯度下降法，有解时收敛。</p>
<h1 id="BP-神经网络"><a href="#BP-神经网络" class="headerlink" title="BP 神经网络"></a>BP 神经网络</h1><ul>
<li>单层感知器只能进行线性可分的运算（如不能解决异或问题）</li>
<li>多层感知器可解决线性不可分问题，双隐层感知器就足以解决任何复杂的分类问题<ul>
<li>隐层的权值怎么训练</li>
<li>隐层节点不存在期望输出</li>
<li>无法通过感知器的学习规则来训练多层感知器</li>
</ul>
</li>
</ul>
<p>多层前馈网络</p>
<p>单隐层网络</p>
<p>多隐层网络</p>
<p>层与层之间为全互连结构</p>
<p>&#x3D;&#x3D;分割线&#x3D;&#x3D;</p>
<ul>
<li><p>BP 网络的输入层和输出层节点个数确定</p>
<ul>
<li>输入个数根据特征的维度来定</li>
<li>输出个数根据要进行分类的类别数来定</li>
</ul>
</li>
<li><p>如何确定隐层节点的个数</p>
<ul>
<li>经验公式</li>
</ul>
<p>$$<br>h &#x3D; \sqrt {m + n} + a<br>$$</p>
<p>其中 h 为隐层节点的个数， m 为输入个数， n 为输出个数， a 为 1~10 之间的调节常数</p>
</li>
</ul>
<p>隐层神经元个数越多，分类效果越好，但计算量会增大</p>
<p>&#x3D;&#x3D;分割线&#x3D;&#x3D;</p>
<ul>
<li>由于线性模型的表达能力不够，考虑通过激活函数来加入非线性因素， BP 算法要求激活函数可导。</li>
<li>由于 S 形函数是可导的（导函数是连续函数），因此适合用在 BP 神经网络中。</li>
</ul>
<p>Sigmoid 函数</p>
<p>$$<br>f(x) &#x3D; {1 \over 1 + e^{-x}}<br>$$</p>
<h2 id="（信息）正向传播过程"><a href="#（信息）正向传播过程" class="headerlink" title="（信息）正向传播过程"></a>（信息）正向传播过程</h2><p>正向传播过程：输入数据从输入层传播到输出层的过程。</p>
<h2 id="（误差）反向传播过程"><a href="#（误差）反向传播过程" class="headerlink" title="（误差）反向传播过程"></a>（误差）反向传播过程</h2><p>从输出节点开始，反向地向第一隐含层传播由总误差引起的权值修正</p>
<ul>
<li>首先计算输出层单元地误差，并用该误差调整输出层地权值</li>
<li>根据输出层的误差计算隐层单元的误差，并用<strong>对应计算误差</strong>调整输出层的权值</li>
</ul>
<h2 id="BP-学习算法"><a href="#BP-学习算法" class="headerlink" title="BP 学习算法"></a>BP 学习算法</h2><h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><ul>
<li>正向传播时，输入样本从输入层经各隐层逐层处理后，传向输出层。若输出层的实际输出与期望的输出不符，则转入<strong>误差</strong>的反向传播阶段。</li>
<li>反向传播时，将<strong>输出误差</strong>以<strong>某种形式</strong>通过隐层向输入层逐层反转，并将<strong>误差</strong>分摊给各层的所有单元，使各层单元获得<strong>误差</strong>信号作为修正各单元权值的依据。</li>
</ul>
<h3 id="误差与损失函数"><a href="#误差与损失函数" class="headerlink" title="误差与损失函数"></a>误差与损失函数</h3><p><strong>误差定义</strong></p>
<p>$$<br>E(w) &#x3D; {1 \over 2} \sum_{d \in D} (t_d - o_d)^2<br>$$</p>
<p>其中，$D$为训练样例集合，$t_d$为训练样例$d$的期望输出，$o_d$为训练样例$d$的实际输出。</p>
<p>以误差作为误差函数的经验风险，在不考虑正则项的情况下，就以误差函数作为损失函数。</p>
<h3 id="学习目的和学习方法"><a href="#学习目的和学习方法" class="headerlink" title="学习目的和学习方法"></a>学习目的和学习方法</h3><p><strong>学习目的</strong></p>
<p>最小化误差：$min E(w)$</p>
<p><strong>学习方法</strong></p>
<p>梯度下降</p>
<p>$$<br>\Delta w_{ij} &#x3D; - \eta {\partial E_d \over \partial w_{ij}}<br>$$</p>
<p>其中$E_d$为训练样本$d$的误差，$w_{ij}$与单元$j$的第$i$个输入相关连的权值</p>
<p>$$<br>w_{ij}(t + 1) &#x3D; w_{ij}(t) + \Delta w_{ij}<br>$$</p>
<h3 id="求导的链式法则"><a href="#求导的链式法则" class="headerlink" title="求导的链式法则"></a>求导的链式法则</h3><p>高数里的，不去记了，要将该法拓展到向量</p>
<p>后面的推导要记</p>
<h1 id="Pytorch"><a href="#Pytorch" class="headerlink" title="Pytorch"></a>Pytorch</h1><h2 id="张量（Tensor）"><a href="#张量（Tensor）" class="headerlink" title="张量（Tensor）"></a>张量（Tensor）</h2><p><img src="/2022/05/31/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E4%BB%80%E4%B9%88%E6%98%AF%E5%BC%A0%E9%87%8F.jpg" alt="img"></p>
<p><strong>Pytorch0.4.0 以前</strong></p>
<p><code>Variable</code> 是 <code>torch.autograd</code> 中的数据类型，主要用于封装 Tensor ，进行<strong>自动求导</strong>。</p>
<table>
<thead>
<tr>
<th>值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>data</code></td>
<td>被包装的 Tensor</td>
</tr>
<tr>
<td><code>grad</code></td>
<td>data 的梯度</td>
</tr>
<tr>
<td><code>grad_fn</code></td>
<td>创建 Tensor 的 Function ，是自动求导的关键</td>
</tr>
<tr>
<td><code>requires_grad</code></td>
<td>指示是否需要梯度</td>
</tr>
<tr>
<td><code>is_leaf</code></td>
<td>指示是否叶子结点（张量）</td>
</tr>
</tbody></table>
<p><strong>Pytorch0.4.0及以后</strong></p>
<p>单独有了 Tensor 类型。</p>
<table>
<thead>
<tr>
<th>值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>dtype</code></td>
<td>张量的数据类型，有 9 种</td>
</tr>
<tr>
<td><code>shape</code></td>
<td>张量的形状</td>
</tr>
<tr>
<td><code>device</code></td>
<td>张量所在设备（GPU or CPU）</td>
</tr>
</tbody></table>
<p><code>dtpye</code> 常用 32 位浮点型（<code>torch.float32</code> or <code>torch.float</code>）或 64 位整型（<code>torch.int64</code> or <code>torch.lang</code>）。</p>
<h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><h4 id="直接创建"><a href="#直接创建" class="headerlink" title="直接创建"></a>直接创建</h4><p><strong><code>torch.tensor()</code></strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torch.tensor(data,       </span><br><span class="line">             dtype = <span class="literal">None</span>,</span><br><span class="line">             device = <span class="literal">None</span>,</span><br><span class="line">             requires_grad = <span class="literal">False</span>,</span><br><span class="line">             pin_memory = <span class="literal">False</span>)</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>data</code></td>
<td>数据，可以是 list ， numpy</td>
</tr>
<tr>
<td><code>dtype</code></td>
<td>数据类型，默认与 <code>data</code> 的一致</td>
</tr>
<tr>
<td><code>device</code></td>
<td>所在设备， cuda&#x2F;cpu （cuda 就是 gpu）</td>
</tr>
<tr>
<td><code>requires_grad</code></td>
<td>是否需要梯度</td>
</tr>
<tr>
<td><code>pin_memory</code></td>
<td>是否存于锁页内存</td>
</tr>
</tbody></table>
<p><strong><code>torch.from_numpy()</code></strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torch.from_numpy(ndarray)</span><br></pre></td></tr></table></figure>

<p>功能：从 numpy 创建 tensor</p>
<p><strong>注意事项</strong>：从 <code>torch.from_numpy</code> 创建的 tensor 与原 ndarray <strong>共享内存</strong>，当修改其中一个的数据，另一个也将会被改动</p>
<h4 id="依据数值创建"><a href="#依据数值创建" class="headerlink" title="依据数值创建"></a>依据数值创建</h4><p><strong><code>torch.zeros()</code></strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torch.zeros(*size,</span><br><span class="line">            out = <span class="literal">None</span>,</span><br><span class="line">            dtype = <span class="literal">None</span>,</span><br><span class="line">            layout = torch.strided,</span><br><span class="line">           	device = <span class="literal">None</span>,</span><br><span class="line">           	requires_grad = <span class="literal">False</span>)</span><br></pre></td></tr></table></figure>

<p>功能：依 <code>size</code> 创建全 0 张量</p>
<table>
<thead>
<tr>
<th>值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>size</code></td>
<td>张量的形状，如 (3, 3) ， (3, 224, 224)</td>
</tr>
<tr>
<td><code>out</code></td>
<td>输出的张量</td>
</tr>
<tr>
<td><code>layout</code></td>
<td>内存中布局形式，有 <code>strided</code> ， <code>sparse_coo</code> 等</td>
</tr>
<tr>
<td><code>device</code></td>
<td>所在设备， gpu&#x2F;cpu</td>
</tr>
<tr>
<td><code>requires_grad</code></td>
<td>是否需要梯度</td>
</tr>
</tbody></table>
<p><strong><code>torch.zeros_like()</code></strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torch.zeros_like(<span class="built_in">input</span>,</span><br><span class="line">                 dtype = <span class="literal">None</span>,</span><br><span class="line">                 layout = <span class="literal">None</span>,</span><br><span class="line">                 device = <span class="literal">None</span>,</span><br><span class="line">                 requires_grad = <span class="literal">False</span>)</span><br></pre></td></tr></table></figure>

<p>功能：依 <code>input</code> 形状创建全 0 张量</p>
<table>
<thead>
<tr>
<th>值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>input</code></td>
<td>创建与 <code>input</code> 同形状的全 0 张量</td>
</tr>
<tr>
<td><code>dtpye</code></td>
<td>数据类型</td>
</tr>
<tr>
<td><code>layout</code></td>
<td>内存中布局形式</td>
</tr>
</tbody></table>
<p><strong><code>torch.ones()</code><strong>、</strong><code>torch.ones_like()</code><strong>、</strong><code>torch.full()</code><strong>、</strong><code>torch.full_like()</code></strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torch.ones()		<span class="comment"># 与上面同理，全1</span></span><br><span class="line">torch.ones_like()	<span class="comment"># 与上面同理，全1</span></span><br><span class="line"></span><br><span class="line">torch.full()		<span class="comment"># 与上面同理，在第1、2个参数间多一个参数fill_value，表示张量的值</span></span><br><span class="line">torch.full_like()	<span class="comment"># 与上面同理，在第1、2个参数间多一个参数fill_value，表示张量的值</span></span><br></pre></td></tr></table></figure>

<p><strong><code>torch.arrange()</code></strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torch.arrange(start = <span class="number">0</span>,</span><br><span class="line">              end,</span><br><span class="line">              step = <span class="number">1</span>,</span><br><span class="line">              out = <span class="literal">None</span>,</span><br><span class="line">              dtype = <span class="literal">None</span>,</span><br><span class="line">              layout = torch.strided,</span><br><span class="line">              device = <span class="literal">None</span>,</span><br><span class="line">              requires_grad = <span class="literal">False</span>)</span><br></pre></td></tr></table></figure>

<p>功能：创建等差的 1 维张量</p>
<p>注意事项：数值区间为 [start, end)</p>
<table>
<thead>
<tr>
<th>值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>start</code></td>
<td>数列起始值</td>
</tr>
<tr>
<td><code>end</code></td>
<td>数列“结束值”</td>
</tr>
<tr>
<td><code>step</code></td>
<td>数列公差，默认为 1</td>
</tr>
</tbody></table>
<p><strong><code>torch.linspace()</code></strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torch.linspace(start,</span><br><span class="line">               end,</span><br><span class="line">               step = <span class="number">100</span>,</span><br><span class="line">               out = <span class="literal">None</span>,</span><br><span class="line">               dtype = <span class="literal">None</span>,</span><br><span class="line">               layout = torch.strided,</span><br><span class="line">               device = <span class="literal">None</span>,</span><br><span class="line">               requires_grad = <span class="literal">False</span>)</span><br></pre></td></tr></table></figure>

<p>功能：创建均分的 1 维张量</p>
<p>注意事项：数值区间维 [start, end]</p>
<table>
<thead>
<tr>
<th>值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>start</code></td>
<td>数列起始值</td>
</tr>
<tr>
<td><code>end</code></td>
<td>数列结束值</td>
</tr>
<tr>
<td><code>steps</code></td>
<td>数列长度（数列有几个数）</td>
</tr>
</tbody></table>
<p><strong><code>torch.logspace()</code></strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torch.logspace(start,</span><br><span class="line">               end,</span><br><span class="line">               step = <span class="number">100</span>,</span><br><span class="line">               base = <span class="number">10.0</span>,</span><br><span class="line">               out = <span class="literal">None</span>,</span><br><span class="line">               dtype = <span class="literal">None</span>,</span><br><span class="line">               layout = torch.strided,</span><br><span class="line">               device = <span class="literal">None</span>,</span><br><span class="line">               requires_grad = <span class="literal">False</span>)</span><br></pre></td></tr></table></figure>

<p>功能：创建对数均分的 1 维张量</p>
<p>注意事项：长度为 <code>steps</code> ，底为 <code>base</code></p>
<table>
<thead>
<tr>
<th>值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>start</code></td>
<td>数列起始值</td>
</tr>
<tr>
<td><code>end</code></td>
<td>数列结束值</td>
</tr>
<tr>
<td><code>steps</code></td>
<td>数列长度（数列有几个数）</td>
</tr>
<tr>
<td><code>base</code></td>
<td>对数函数的底，默认为 10</td>
</tr>
</tbody></table>
<p><strong><code>torch.eye()</code></strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torch.eye(n,</span><br><span class="line">          m = <span class="literal">None</span>,</span><br><span class="line">          out = <span class="literal">None</span>,</span><br><span class="line">          dtype = <span class="literal">None</span>,</span><br><span class="line">          layout = torch.strided,</span><br><span class="line">          device = <span class="literal">None</span>,</span><br><span class="line">          requires_grad = <span class="literal">False</span>)</span><br></pre></td></tr></table></figure>

<p>功能：创建单位对角矩阵（2 维张量）</p>
<p>注意事项：默认为方阵</p>
<table>
<thead>
<tr>
<th>值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>n</code></td>
<td>矩阵行数</td>
</tr>
<tr>
<td><code>m</code></td>
<td>矩阵列数</td>
</tr>
</tbody></table>
<h4 id="依概率分布创建"><a href="#依概率分布创建" class="headerlink" title="依概率分布创建"></a>依概率分布创建</h4><p><strong><code>torch.normal()</code></strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torch.normal(mean,</span><br><span class="line">             std,</span><br><span class="line">             out = <span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">torch.normal(mean,</span><br><span class="line">             std,</span><br><span class="line">             size,</span><br><span class="line">             out = <span class="literal">None</span>)</span><br></pre></td></tr></table></figure>

<p>功能：生成正态分布（高斯分布）</p>
<table>
<thead>
<tr>
<th>值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>mean</code></td>
<td>均值</td>
</tr>
<tr>
<td><code>std</code></td>
<td>标准差</td>
</tr>
<tr>
<td><code>size</code></td>
<td>前二者都是<strong>标量</strong>时的创建个数</td>
</tr>
</tbody></table>
<p>四种模式：</p>
<table>
<thead>
<tr>
<th><code>mean</code></th>
<th><code>std</code></th>
</tr>
</thead>
<tbody><tr>
<td><strong>标量</strong></td>
<td><strong>标量</strong></td>
</tr>
<tr>
<td><strong>标量</strong></td>
<td>张量</td>
</tr>
<tr>
<td>张量</td>
<td><strong>标量</strong></td>
</tr>
<tr>
<td>张量</td>
<td>张量</td>
</tr>
</tbody></table>
<p><strong><code>torch.randn()</code><strong>、</strong><code>torch.randn_like()</code></strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torch.randn(*size,</span><br><span class="line">            out = <span class="literal">None</span>,</span><br><span class="line">            dtype = <span class="literal">None</span>,</span><br><span class="line">            layout = torch.strided,</span><br><span class="line">            device = <span class="literal">None</span>,</span><br><span class="line">            requires_grad = <span class="literal">False</span>)</span><br></pre></td></tr></table></figure>

<p>功能：生成<strong>标准正态分布</strong></p>
<table>
<thead>
<tr>
<th>值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>size</code></td>
<td>张量的形状</td>
</tr>
</tbody></table>
<p><strong><code>torch.rand()</code><strong>、</strong><code>torch.rand_like()</code></strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torch.rand(*size,</span><br><span class="line">           out = <span class="literal">None</span>,</span><br><span class="line">           dtype = <span class="literal">None</span>,</span><br><span class="line">           layout = torch.strided,</span><br><span class="line">           device = <span class="literal">None</span>,</span><br><span class="line">           requires_grad = <span class="literal">False</span>)</span><br></pre></td></tr></table></figure>

<p>功能：在区间 [0, 1) 上，生成<strong>均匀分布</strong></p>
<p><strong><code>torch.randint()</code><strong>、</strong><code>torch.randint_like()</code></strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torch.randint(low = <span class="number">0</span>,</span><br><span class="line">              high,</span><br><span class="line">              size,</span><br><span class="line">              out = <span class="literal">None</span>,</span><br><span class="line">              dtype = <span class="literal">None</span>,</span><br><span class="line">              layout = torch.strided,</span><br><span class="line">              device = <span class="literal">None</span>,</span><br><span class="line">              requires_grad = <span class="literal">False</span>)</span><br></pre></td></tr></table></figure>

<p>功能：区间 [low, high) 生成整数<strong>均匀分布</strong></p>
<table>
<thead>
<tr>
<th>值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>size</code></td>
<td>张量的形状</td>
</tr>
</tbody></table>
<p><strong><code>torch.randperm()</code></strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torch.randprem(n,</span><br><span class="line">               out = <span class="literal">None</span>,</span><br><span class="line">               dtype = <span class="literal">None</span>,</span><br><span class="line">               layout = torch.strided,</span><br><span class="line">               device = <span class="literal">None</span>,</span><br><span class="line">               requires_grad = <span class="literal">False</span>)</span><br></pre></td></tr></table></figure>

<p>功能：生成从 0 到 n - 1 的随机排列</p>
<table>
<thead>
<tr>
<th>值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>n</code></td>
<td>张量的长度</td>
</tr>
</tbody></table>
<p><strong><code>torch.bernoulli()</code></strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torch.bernoulli(<span class="built_in">input</span>,</span><br><span class="line">                *,</span><br><span class="line">                generator = <span class="literal">None</span>,</span><br><span class="line">                out = <span class="literal">None</span>)</span><br></pre></td></tr></table></figure>

<p>功能：以 <code>input</code> 为概率，生成伯努利分布（0 - 1 分布，两点分布）</p>
<table>
<thead>
<tr>
<th>值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>input</code></td>
<td>概率值</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>背包问题</title>
    <url>/2022/03/01/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>背包问题是一类特殊的动态规划问题。</p>
<p>如有需要，请优先看<a href="%E8%83%8C%E5%8C%85%E4%B9%9D%E8%AE%B2.pdf">背包九讲</a>这篇文章，本文只是为了自己学习理解的翻版：）</p>
<h1 id="01背包问题"><a href="#01背包问题" class="headerlink" title="01背包问题"></a>01背包问题</h1><p><strong>题目：</strong></p>
<p>有$N$件物品和一个容量为$V$的背包。放入第$i$件物品占用的容量为$C_i$，得到的价值是$W_i$。求解一种价值总和最大的装法。</p>
<p><strong>基本思路：</strong></p>
<p>用子问题定义状态：$F[i,v]$表示前$i$件物品恰放入一个容量为$v$的背包可以获得的最大价值。则可得状态转换方程：</p>
<p>$$<br>F[i, v] &#x3D; \max { F[i - 1, v], F[i-1, v - C_i] + W_i }<br>$$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">memset</span>(F,<span class="number">0</span>,<span class="built_in">sizeof</span>(F));</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v=<span class="number">0</span>;v&lt;=V;v++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(v&gt;=C[i]) F[i][v]=<span class="built_in">max</span>(F[i<span class="number">-1</span>][v],F[i<span class="number">-1</span>][v-C[i]]+W[i]);</span><br><span class="line">        <span class="keyword">else</span> F[i][v]=F[i<span class="number">-1</span>][v];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>此方法时间与空间复杂度均为$O(VN)$。</p>
<p><strong>优化空间复杂度：</strong></p>
<p>空间复杂度可优化为$O(V)$。</p>
<p>发现只需要$i-1$个物品的状态$F[i-1, 0 \dots V]$就可以得出$i$个物品时的状态$F[i, 0 \dots V]$，因此可以进行压缩成两行的二维数组。</p>
<p>再次发现只需要的$i-1$个物品容量小于等于$v$的状态$F[i-1, 0 \dots v]$就可以得出的$i$个物品容量为$v$的状态$F[i, v]$，因此可以使用倒序压缩成一行的一维数组。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">memset</span>(F,<span class="number">0</span>,<span class="built_in">sizeof</span>(F));</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v=V;v&gt;=C[i];v--)</span><br><span class="line">        F[v]=<span class="built_in">max</span>(F[v],F[v-C[i]]+W[i]);</span><br></pre></td></tr></table></figure>

<p>由于使用一维数组解01背包的程序在以后会多次用到，所以抽象出一个处理一件01背包中的物品的函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ZeroOnePack</span><span class="params">(<span class="type">int</span> F[],<span class="type">int</span> C,<span class="type">int</span> W)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v=V;v&gt;=C;v--)</span><br><span class="line">        F[v]=<span class="built_in">max</span>(F[v],F[v-C]+W);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此原本的代码可以改写为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">memset</span>(F,<span class="number">0</span>,<span class="built_in">sizeof</span>(F));</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++)</span><br><span class="line">    <span class="built_in">ZeroOnePack</span>(F,C[i],W[i]);</span><br></pre></td></tr></table></figure>

<p><strong>初始化细节问题：</strong></p>
<p>背包问题往往有两种不同的问法。有些要求<strong>必须把背包装满</strong>，有些则不必须。一种区别这两种问法的方法是使用不同的初始化方法。</p>
<ul>
<li>在要求装满时，初始化$F[0] &#x3D; 0$，$F[1..V] &#x3D; - \infty$。</li>
<li>在不要求装满时，初始化$F[0..V] &#x3D; 0$。</li>
</ul>
<p>可以这样理解：初始化的$F$数组就是在没有物品可放时背包的合法状态。当要求装满时，只有背包容量为0时可以在什么都不装时“恰好装满”，而其他容量均无解，属于未定义状态，因此应被赋值为$- \infty$；当不要求装满时，任意容量的背包都有“什么都不装”这一价值为0的合法解，因此初始值应全为$0$。</p>
<p>此技巧完全可以推广到其他类型的背包问题。</p>
<p><strong>一个常数优化：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v=V;v&gt;=C[i];v--)</span><br></pre></td></tr></table></figure>

<p>其中的第二重循环可以优化为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++) sum+=W[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v=V;v&gt;=<span class="built_in">max</span>(V-sum,C[i]);v--)</span><br></pre></td></tr></table></figure>

<p>原理自己思考（提示：使用二维的转移方程思考较易）。</p>
<p><strong>小结：</strong></p>
<p>01背包问题时最基本的背包问题，它包含了背包问题中设计状态、方程的最基本思想。另外，别的类型的背包问题往往也可以转换成01背包问题求解。</p>
<h1 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h1><p><strong>题目：</strong></p>
<p>有$N$种物品和一个容量为$V$的背包，每种物品都有无限件可用。放入第$i$件物品占用的容量为$C_i$，得到的价值是$W_i$。求解一种价值总和最大的装法。</p>
<p><strong>基本思路：</strong></p>
<p>本问题与01背包问题唯一的不同是每种物品有无限件。因此从每种物品的角度考虑时，与它相关的策略不再是取或不取两种，而是取$0$件、取$1$件、取$2$件……直至取$\lfloor V &#x2F; C_i \rfloor$件等许多种。</p>
<p>若仍按照01背包的求解思路，仍然可以按照每种物品不同的策略写出状态转换方程：</p>
<p>$$<br>F[i,v] &#x3D; \max { F[i - 1, v - kC_i] + kW_i | 0 \leq kC_i \leq v }<br>$$</p>
<p>这跟01背包问题一样有$O(VN)$个状态需要求解，但求解每个状态的时间已经不再是常数了，求解状态$F[i,v]$的时间是$O({v \over C_i})$，总的复杂度可以认为是$O(NV \sum {V \over C_i})$，是比较大的。我们还是要试图该进这个复杂度。</p>
<p><strong>一个简单有效的优化：</strong></p>
<p>若两件物品$i$、$j$满足$C_i \leq C_j$且$W_i \geq W_j$，则可以将物品$j$直接去掉，不用考虑。</p>
<p>这个优化的正确性是显然的：任何情况下都可将价值小费用高的$j$换成物美价廉的$i$，得到的方案至少不会更差。对于随机生成的数据，这个方法往往会大大减少物品的件数，从而加快速度。然而这个并不能改善最坏情况的复杂度，因为有可能特别设计的数据可以一件物品也去不掉。</p>
<p>这个优化可以简单的$O(N^2)$地实现，一般都可以承受。另外，针对背包问题而言，比较不错的一种方法是：首先将费用大于V的物品去掉，然后使用类似计数排序的方法，计算出费用相同的物品中价值最高的是哪个，可以$O(V+N)$地完成这个优化。</p>
<p><strong>转化为01背包问题求解：</strong></p>
<p>最简单的想法是，考虑到第$i$种物品最多选$\lfloor V &#x2F; C_i \rfloor$件，于是可以把第$i$件物品转化为$\lfloor V &#x2F; C_i \rfloor$件相同的物品，然后求解此01背包问题。此做法完全没有改进时间复杂度，但其也指明了将完全背包问题转化为01背包问题的思路：将一种物品拆成多件只能选$0$件或$1$件的01背包中的物品。</p>
<p>更高效的转化方法是：把第$i$种物品拆成费用为$C_i2^k$、价值为$W_i2^k$的若干件物品，其中$k$取遍满足$C_i2^k \leq V$的非负整数。这使用了二进制的思想，因为不管最优策略选几件第$i$种物品，其件数写成二进制后，总能表示成若干个$2^k$件物品的和。这样一来每种物品被拆成了$O(\log \lfloor V &#x2F; C_i \rfloor)$件物品，是一个很大的的改进。</p>
<p><strong>$O(VN)$的算法：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">memset</span>(F,<span class="number">0</span>,<span class="built_in">sizeof</span>(F));</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v=C[i];v&lt;=V;v++)</span><br><span class="line">        F[v]=<span class="built_in">max</span>(F[v],F[v-C[i]]+W[i]);</span><br></pre></td></tr></table></figure>

<p>可以发现，此代码与01背包问题的代码只有$v$的循环次序不同而已。</p>
<p>那么为什么这个算法可行？首先思考为什么01背包要按照$v$递减的次序来循环：是为了保证第$i$次循环中的状态$F[i,v]$是由状态$F[i - 1,v - C_i]$递推而来。换句话说，也就是为了保证每件物品只选一次，保证在考虑“选入第$i$件物品”此决策时，依据的是一个尚未选入第$i$件物品的子结果$F[i - 1,v - C_i]$。而在完全背包问题中每件物品可选无限件，因此在考虑“加选一件第$i$种物品”这种策略时，正需要一个可能已经选入第$i$种物品的子结果$F[i,v - C_i]$，所以必须采用正循环。</p>
<p>值得一提的是，两层循环的次序可以颠倒。这个结论可能带来算法时间常数上的优化。</p>
<p>本算法也可由其他思路得出。例如，将<strong>基本思路</strong>中求解$F[i,v - C_i]$的状态转换方程写出来：</p>
<p>$$<br>F[i,v - C_i] &#x3D; \max { F[i - 1, v - (k + 1)C_i] + kW_i | C_i \leq (k + 1)C_i \leq v }<br>$$</p>
<p>回看<strong>基本思路</strong>中的原方程：</p>
<p>$$<br>F[i,v] &#x3D; \max { F[i - 1, v - kC_i] + kW_i | 0 \leq kC_i \leq v }<br>$$</p>
<p>将原本$k &#x3D; 0$的情况抽离出来：</p>
<p>$$<br>F[i,v] &#x3D;\max (F[i-1, v], \max { F[i - 1, v - (k+1)C_i] + (k+1)W_i | C_i \leq (k+1)C_i \leq v })<br>$$</p>
<p>将$W_i$从$\max$中提出：</p>
<p>$$<br>F[i,v] &#x3D;\max (F[i-1, v], \max { F[i - 1, v - (k+1)C_i] + kW_i | C_i \leq (k+1)C_i \leq v } + W_i)<br>$$</p>
<p>注意到式中一部分与求解$F[i,v - C_i]$的状态转换方程完全一致，进行替换，得到：</p>
<p>$$<br>F[i,v] &#x3D; \max ( F[i - 1, v], F[i, v - C_i] + W_i )<br>$$</p>
<p>将这个方程用一维数组实现，便得到了上面的代码。</p>
<p>最后抽象出处理一件完全背包类物品的过程代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CompletePack</span><span class="params">(<span class="type">int</span> F[],<span class="type">int</span> C,<span class="type">int</span> W)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v=C;v&lt;=V;v++)</span><br><span class="line">        F[v]=<span class="built_in">max</span>(F[v],F[v-C]+W);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>小结：</strong></p>
<p>完全背包也是一个相当基础的背包问题，他有两个状态转移方程。</p>
<h1 id="多重背包问题"><a href="#多重背包问题" class="headerlink" title="多重背包问题"></a>多重背包问题</h1><p><strong>题目：</strong></p>
<p>有$N$种物品和一个容量为$V$的背包，第$i$种物品最多有$M_i$件可用。放入第$i$件物品占用的容量为$C_i$，得到的价值是$W_i$。求解一种价值总和最大的装法。</p>
<p><strong>基本思路：</strong></p>
<p>这题目和完全背包问题很类似，只需稍微更改完全背包问题的方程即可。</p>
<p>对于第$i$件物品有$M_i + 1$种策略：取$0$件，取$1$件……取$M_i$件。令$F[i,v]$表示前$i$种物品恰放入一个容量为$v$的背包的最大价值，则有：</p>
<p>$$<br>F[i,v] &#x3D; \max { F[i - 1, v - kC_i] + kW_i | 0 \leq k \leq M_i }<br>$$</p>
<p>复杂度是$O(V \sum M_i)$。</p>
<p><strong>转化为01背包问题：</strong></p>
<p>把第$i$种物品换成$M_i$件01背包种的物品，则得到了物品数为$\sum M_i$的01背包问题。直接求解之，复杂度仍是$O(V \sum M_i)$。但是我们期望转化为01背包问题后，能够像完全背包一样降低复杂度。</p>
<p>仍然考虑二进制的思想，把第$i$种物品分解成若干件01背包中的物品，设一系列系数分别为$2^0, 2^1, 2^2, … , 2^{k - 1}, M_i - 2^k + 1$，且$k$是满足$M_i - 2^k + 1 &gt; 0$的最大整数，每件物品的费用为$系数 * C_i$、价值为$系数 * W_i$。（也就是把$M_i$件物品按照二进制分组了）例如：若$M_i &#x3D; 14$，则相应的$k &#x3D; 3$，这种最多取14件的物品应被分成系数分别为$1, 2, 4, 7$的四件物品。这样就将第$i$种物品分成了$O(\log M_i)$种物品，将原问题转化为了复杂度为$O(V \sum \log M_i)$的01背包问题，是很大的改进。</p>
<p>下面给出$O(\log M)$时间处理一件多重背包中物品的过程：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MultiplePack</span><span class="params">(<span class="type">int</span> F[],<span class="type">int</span> C,<span class="type">int</span> W,<span class="type">int</span> M)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(C*M&gt;=V)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">CompletePack</span>(F,C,W);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> k=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(k&lt;M)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">ZeroOnePack</span>(F,k*C,k*W);</span><br><span class="line">        M-=k;</span><br><span class="line">        k*=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">ZeroOnePack</span>(F,M*C,M*W);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>可行性问题$O(VN)$的算法：</strong></p>
<p>当问题是“每种有若干件的物品能否填满给定容量的背包”，即只需考虑填满背包的可行性，不需考虑每件物品的价值时，多重背包问题同样有$O(VN)$复杂度的算法。</p>
<p>例如，可以使用单调队列的数据结构，优化基本算法的状态转移方程，使每个状态的至可以以均摊$O(1)$的时间求解。</p>
<p>下面介绍另一种算法，其基本思想为：设$F[i,j]$表示“用了前$i$种物品填满容量位$j$的背包后，最多还剩下几个第$i$种物品可用”，如果$F[i,j] &#x3D; -1$则说明这种状态不可行，若可行应满足$0 \leq F[i,j] \leq M_i$。</p>
<p>递推求$F[i,j]$的代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">F[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=V;i++) F[<span class="number">0</span>][i]=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=V;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(F[i<span class="number">-1</span>][j]&gt;=<span class="number">0</span>) F[i][j]=M[i];</span><br><span class="line">        <span class="keyword">else</span> F[i][j]=<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=V-C[i];j++)</span><br><span class="line">        <span class="keyword">if</span>(F[i][j]&gt;<span class="number">0</span>) F[i][j+C[i]]=<span class="built_in">max</span>(F[i][j+C[i]],f[i][j]<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终$F[N][0…V]$便是多重背包可行性问题的答案。</p>
<p><strong>小结：</strong></p>
<p>我们看到了将一个算法的复杂度由$O(V \sum M_i)$改进到$O(V \sum \log M_i)$的过程，还知道了存在复杂度为$O(VN)$的算法。应特别注意“拆分物品”的思想和方法。</p>
<h1 id="混合三种背包问题"><a href="#混合三种背包问题" class="headerlink" title="混合三种背包问题"></a>混合三种背包问题</h1><p><strong>问题：</strong></p>
<p>将前三种背包问题混合起来，有的物品只可以取一次（01背包），有的物品可以取无限次（完全背包），有的物品可以取有限次（多重背包）。</p>
<p><strong>01背包与完全背包的混合：</strong></p>
<p>由于01背包和完全背包的代码中只有一处不同，故在只有这两种物品时，只要根据物品的类别选用循环顺序即可，复杂度是$O(VN)$：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(第i件物品属于<span class="number">01</span>背包)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> v=V;v&gt;=C[i];v--)</span><br><span class="line">            F[v]=<span class="built_in">max</span>(F[v],F[v-C[i]]+W[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(第i件物品属于完全背包)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> v=C[i];v&lt;=V;v++)</span><br><span class="line">            F[v]=<span class="built_in">max</span>(F[v],F[v-C[i]]+W[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>再加上多重背包：</strong></p>
<p>利用单调队列，可以给出均摊$O(VN)$的解法。但如果不考虑单调队列的话，用将每个多重背包的物品分成$O(\log M_i)$个01背包的物品的方法也已经很优了。此时最清晰的写法是调用前面给出的三个过程。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(第i件物品属于<span class="number">01</span>背包)</span><br><span class="line">        <span class="built_in">ZeroOnePack</span>(F,C[i],W[i]);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(第i件物品属于完全背包)</span><br><span class="line">        <span class="built_in">CompletePack</span>(F,C[i],W[i]);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(第i件物品属于多重背包)</span><br><span class="line">        <span class="built_in">MultiplePack</span>(F,C[i],W[i],N[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在最初写出这三个过程的时候，可能完全没有想到它们会在这里混合应用。这似乎就体现了编程中抽象的威力。</p>
<p><strong>小结：</strong></p>
<p>有人说，困难的题目都是由简单的题目叠加而来的。这句话是否公里暂且存之不论，但它在本节中已经得到了充分的体现。只要基础扎实，领会三种基本背包问题的思想，就可以做到把困难的题目拆分成简单的题目来解决。</p>
<h1 id="二维费用的背包问题"><a href="#二维费用的背包问题" class="headerlink" title="二维费用的背包问题"></a>二维费用的背包问题</h1><p><strong>问题：</strong></p>
<p>此问题与01背包问题的不同为：第$i$件物品有两种所需的费用分别为$C_i$和$D_i$，两种费用分别对应的背包容量为$V$和$U$。</p>
<p><strong>思路：</strong></p>
<p>费用增加了一维，状态也增加一维即可。设$F[i, v, u]$表示前$i$件物品符出两种费用分别为$v$和$u$时可获得的最大价值。状态转移方程就是：</p>
<p>$$<br>F[i, v, u] &#x3D; \max { F[i - 1, v, u], F[i - 1, v - C_i, u - D_i] + W_i }<br>$$</p>
<p>如前述优化空间复杂度的方法，可以只使用二维的数组：当每件物品只有一件时变量$v$和$u$采用逆序的循环，当有无限件时采用顺序循环，当有有限件时拆分物品。</p>
<p><strong>物品总个数的限制：</strong></p>
<p>“二维费用”的条件有时会用隐含的方式给出，如：最多只能取$U$件物品。这事实上相当于每件物品多了一种“件数”的费用。每个物品的件数费用均为$1$，可以付出的最大件数费用为$U$。换句话说，设$F[v, u]$表示符出费用$v$，最多选$u$件时可得到的最大价值，则根据物品的类型（01、完全、多重）用不同的方法循环更新，最后在$F[0…V, 0…U]$范围内寻找答案。</p>
<p><strong>复整数域上的背包问题：</strong></p>
<p>另一种看代二维背包问题的思路是：将他看待成复整数域上的背包问题。也就是说，背包的容量以及每件物品的费用都是一个复整数。而常见的一维背包问题则是自然数域上的背包问题。</p>
<p>作为这种思想的练习，可以尝试将后文中提到的“子集和问题”扩展到二维，并试图用同样的复杂度解决。</p>
<p><strong>小结：</strong></p>
<p>面对由熟悉的动态规划题目变形得来的题目时，在原来的状态中加一维以满足新的限制是一种比较通用的方法。</p>
<h1 id="分组的背包问题"><a href="#分组的背包问题" class="headerlink" title="分组的背包问题"></a>分组的背包问题</h1><p><strong>问题：</strong></p>
<p>有$N$件物品和一个容量为$V$的背包。放入第$i$件物品占用的容量为$C_i$，得到的价值是$W_i$。这些物品被划分为$K$组，每组中的物品互相冲突，最多选一件。求解一种价值总和最大的装法。</p>
<p><strong>思路：</strong></p>
<p>这个问题变成了每组物品有若干种策略：是选择本组的某一件，还是一件都不选。也就是说设$F[k, v]$表示前$k$组物品放入一个容量为$v$的背包能取得的最大权值，则有：</p>
<p>$$<br>F[k, v] &#x3D; \max { F[k - 1, v], F[k - 1, v - C_i] + W_i | item \ i \in group \ k }<br>$$</p>
<p>使用一维数组的代码如下（此处$i$不是物品的编号，是物品在链表中的链表编号）：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=K;k++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v=V;v&gt;=<span class="number">0</span>;v--)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=a[k];i;i=e[i].next)</span><br><span class="line">            F[v]=<span class="built_in">max</span>(F[v],f[v-C[i.id])+W[i.id];</span><br></pre></td></tr></table></figure>

<p>这里三层循环的顺序保证了每一组内的物品最多只有一个会被添加到背包中。</p>
<p>另外，显然可以对每组内的物品应用“若两件物品$i$、$j$满足$C_i \leq C_j$且$W_i \geq W_j$，则可以将物品$j$直接去掉，不用考虑。”这个优化。</p>
<p><strong>小结：</strong></p>
<p>分组背包问题将彼此互斥的若干物品成为一个组，这建立了一个很好的模型。不少背包问题的变形都可以转化为分组的背包问题（如下一节的<strong>有依赖的背包问题</strong>），由分组的背包问题进一步可定义“泛化物品”的概念，十分有利于解题。</p>
<h1 id="有依赖的背包问题"><a href="#有依赖的背包问题" class="headerlink" title="有依赖的背包问题"></a>有依赖的背包问题</h1><p><strong>问题：</strong></p>
<p>这种背包问题的物品件存在某种“依赖”的关系。也就是说，物品$i$依赖于物品$j$，表示若选物品$i$，则必须选物品$j$。为了简化起见，我们先设没有某个物品既依赖于别的物品，又被别的物品所依赖；另外，没有某件物品同时依赖多件物品。</p>
<p><strong>思路：</strong></p>
<p>这个问题由NOIP2006中“金明的预算方案”一题扩展而来。遵从该题的提法，将不依赖于别的物品的物品称为“主件”，依赖于某主件的物品称为“附件”。由此可知所有的物品由若干主件和依赖于每个主件的一个附件集合组成。</p>
<p>按照背包问题的一般思路，仅考虑一个主件和它的附件集合。可是，可用的策略非常多，包括：都不选，仅选择主件，选择主件和一个附件，选择主件和两个附件……无法用状态转移方程来表示如此多的策略。事实上，设有n个附件，则策略有$2^n + 1$个，为指数级。</p>
<p>考虑到所有的这些策略都是互斥的（也就是说，你只能选择一种策略），所以一个主件和他的附件集合实际上对应于<strong>分组的背包问题</strong>中的一个物品组，每个选择了主件又选择了若干个附件的策略对应于这个物品组中的一个物品，其费用和价值都是这个策略中物品的值的和。但仅仅是这一步转化并不能给出一个好的算法，因为物品组中的物品还是像原问题的策略一样多。</p>
<p>再考虑对每组内的物品应用“若两件物品$i$、$j$满足$C_i \leq C_j$且$W_i \geq W_j$，则可以将物品$j$直接去掉，不用考虑。”这个优化。我们可以想到，对于第$k$个物品组中的物品，所有费用相同的物品只留一个价值最大的，不影响结果。所以，可以对主件$k$的“附件集合”先进行一次01背包，得到费用依次为$0…V - C_k$所有这些值时相应的最大价值$F_k[0…V - C_k]$。那么，这个主件及它的附件集合相当于$V - C_k + 1$个物品的物品组，其中费用为$v$的物品的价值为$F_k[v - C_k] + W_k$，$v$的取值范围是$C_k \leq v \leq V$。</p>
<p>也就是说，原来指数级的策略中，有很多策略都是冗余的。通过依次01背包后，将主件$k$及其附件转化为$V - C_k + 1$个物品的物品组，就可以直接应用<strong>分组的背包问题</strong>的算法解决问题了。</p>
<p><strong>较一般的问题：</strong></p>
<p>更一般的问题是：依赖关系以图论中“森林”的形式给出。也就是说，主件的附件仍然可以具有自己的附件集合。限制指示每个物品最多只依赖于一个物品（只有一个主件）且不出现循环依赖。</p>
<p>解决这个问题仍然可以用将每个主件及其附件集合转化为物品组的方式。唯一不同的是，由于附件可能还有附件，就不能将每个附件都看作一个一般的01背包中的物品了。若这个附件也有附件集合，则它必定要被先转化为物品组，然后用<strong>分组的背包问题</strong>解出主件及其附件集合所对应的附件组中各个费用的附件所对应的价值。</p>
<p>事实上，这是一种树形动态规划，其特点是，在用动态规划求每个父节点的属性之前，需要对它的各个儿子的属性进行一次动态规划式的求值。这已经触及到了“泛化物品”的思想。看完<strong>泛化物品</strong>后，你会发现这个“依赖关系树”每一个子树都等价于一件泛化物品，求某节点为根的子树对应的泛化物品相当于求其所有儿子的对应的泛化物品之和。</p>
<p><strong>小结：</strong></p>
<p>用物品组的思想考虑那题中及其特殊的依赖关系：物品不能既作主件又作附件，每个主件最多有两个附件，可以发现一个主件和它的两个附件等价于一个由四个物品组成的物品组，这便揭示了问题的某种性质。</p>
<h1 id="泛化物品"><a href="#泛化物品" class="headerlink" title="泛化物品"></a>泛化物品</h1><p><strong>定义：</strong></p>
<p>考虑这样一种物品，它并没有固定的费用和价值，而是它的价值随着你分配给它的费用而变化。这就是泛化物品的概念。、</p>
<p>更严格的定义之。在背包容量为$V$的背包问题中，泛化物品是一个定义域为$0…V$中的整数的函数$h$，当分配给它的费用为$v$时，能得到的价值就是$h(v)$。</p>
<p>这个定义有一点点抽象，另一种理解是一个泛化物品就是一个数组$h[0…V]$，给它费用$v$，可得到价值$h[v]$。</p>
<p>一个费用为$c$价值为$w$的物品，如果它是01背包中的物品，那么把它看成泛化物品，它就是除了$h(c) &#x3D; w$外，其他函数值都为$0$的一个函数，如果它是完全背包中的物品，那么它可以看成这样一个函数，仅当$v$被$c$整除时有$h(v) &#x3D; w \cdot {v \over c}$，其它函数值均为$0$。如果它是多重背包中重复次数最多为$m$的物品，那么它对应的泛化物品的函数有$h(v) &#x3D; w \cdot {v \over c}$仅当$v$被$c$整除且${v \over c} \leq n$，其他情况函数值均为$0$。</p>
<p>一个物品组可以看作一个泛化物品$h$。对于一个$0…V$中的$v$，若物品组中不存在费用为$v$的物品，则$h(v) &#x3D; 0$，否则$h(v)$取值为所有费用为$v$的物品的最大价值。<strong>有依赖的背包问题</strong>中每个主件及其附件集合等价于一个物品组，自然也可看做一个泛化物品。</p>
<p><strong>泛化物品的和：</strong></p>
<p>如果给定了两个泛化物品$h$和$l$，要用一定的费用从这两个泛化物品中获得最大的价值，这个问题怎么求呢？事实上，对于一个给定的费用$v$，只需枚举将这个费用如何分配给两个泛化物品就可以了。同样的，对于$0…V$中的每一个整数$v$，可以求得费用$v$分配到$h$和$l$中的最大价值$f(v)$。也即：</p>
<p>$$<br>f(v) &#x3D; \max { h(k) + l(v - k) | 0 \leq k \leq v }<br>$$</p>
<p>可以看到，这里的$f$是一个由泛化物品$h$和$l$决定的定义域为$0…V$的函数，也就是说，$f$是一个由泛化物品$h$和$l$决定的泛化物品。</p>
<p>我们将$f$定义为泛化物品$h$和$l$的和：$h$、$l$都是泛化物品，若函数$f$满足以上关系式，则称$f$是$h$与$l$的和。泛化物品和运算的时间复杂度取决于背包的容量，是$O(V_2)$。</p>
<p><strong>背包问题的泛化物品：</strong></p>
<p>一个背包问题中，可能会给出很多条件，包括每种物品的费用、价值等属性，物品之间的返祖、依赖等关系等。但肯定能将问题对应于某个泛化物品。也就是说，给定了所有条件以后，就可以对每个非负整数$v$求得：若背包容量为$v$，将物品装入背包可得到的最大价值是多少，这可以认为是定义在非负整数集上的一件泛化物品。这个泛化物品——或者说问题所对应的一个定义域为非负整数的函数——包含了关于问题本身的高度浓缩的信息。一般而言，求得这个泛化物品的一个子定义域（例如$0…V$）的值之后，就可以根据这个函数的取值得到背包问题的最终答案。</p>
<p>综上所述，一般而言，求解背包问题，即求解这个问题所对应的一个函数，即该问题的泛化物品。而求解某个泛化物品的一种常用方法就是将它表示为若干泛化物品的和然后求之。</p>
<p><strong>小结：</strong></p>
<p>本讲是原作者在学习函数式编程的Scheme语言时，用函数编程的眼光审视各类背包问题得出的结论。</p>
<h1 id="背包问题问法的变化"><a href="#背包问题问法的变化" class="headerlink" title="背包问题问法的变化"></a>背包问题问法的变化</h1><p>以上涉及的各种背包问题都是要求在背包容量（费用）的限制下求可以取到的最大价值，但背包问题还有很多灵活的问法，在这里值得提一下。</p>
<p>例如，求解最多可以放多少件物品或者最多可以装满多少背包的空间。这都可以根据具体问题利用前面的方程求出所有状态的值（$F$数组）之后得到。</p>
<p>还有，如果要求的是“总价值最小”“总件数最小”，只需将状态转移方程中的$\max$改成$\min$即可。</p>
<p>下面说一些变化更大的问法。</p>
<p><strong>输出方案：</strong></p>
<p>一般而言，背包问题是要求一个最优值，如果要求输出这个最优值的方案，可以参照一般动态规划问题输出方案的方法：记录下每个状态的最优值是由状态转移方程的哪一项推出来的，换句话说，记录下它是由哪一个策略推出来的。便可根据这条策略找到上一个状态，从上一个状态接着向前推即可。</p>
<p>还是以01背包为例，方程为$F[i, v] &#x3D; \max { F[i - 1, v], F[i-1, v - C_i] + W_i }$。再用一个数组$G[i, v]$，设$G[i, v] &#x3D; 0$表示推出$F[i, v]$的值时是采用了方程的前一项（也即$F[i, v] &#x3D; F[i - 1, v]$），$G[i, v] &#x3D; 1$表示采用了方程的后一项。注意这两项分别表示了两种策略：未选第$i$个物品及选了第$i$个物品。那么输出方案的代码可以这样写：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i=N,v=V;</span><br><span class="line"><span class="keyword">while</span>(i&gt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(G[i][v]==<span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;未选第%d项物品\n&quot;</span>,i);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(G[i][v]==<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;选了第%d项物品\n&quot;</span>,i);</span><br><span class="line">        v-=C[i];</span><br><span class="line">    &#125;</span><br><span class="line">    i--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外，采用方程的前一项或后一项也可以在输出方案的过程中根据$F[i, v]$的值实时地求出来。也即，不须记录$G$数组，将上述代码改为如下形式也可：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i=N,v=V;</span><br><span class="line"><span class="keyword">while</span>(i&gt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(F[i][v]==F[i<span class="number">-1</span>][v]) <span class="built_in">printf</span>(<span class="string">&quot;未选第%d项物品\n&quot;</span>,i);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(F[i][v]==F[i<span class="number">-1</span>][v-C[i]]+W[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;选了第%d项物品\n&quot;</span>,i);</span><br><span class="line">        v-=C[i];</span><br><span class="line">    &#125;</span><br><span class="line">    i--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出字典序最小的最优方案：</strong></p>
<p>这里”字典序最小“的意思是$1…N$号物品的选择方案排列出来以后字典序最小。以输出01背包最小字典序的方案为例。</p>
<p>一般而言，求一个字典序最小的最优方案，只需要在转移时注意策略。</p>
<p>首先，子问题的定义要略改一些。我们注意到，如果存在一个选了物品$1$的最优方案，那么答案一定包含物品$1$，原问题转化为一个背包容量为$V - C_1$，物品为$2…N$的子问题反之，如果答案不包含物品$1$，则转化成背包容量仍为$V$，物品为$2…N$的子问题。</p>
<p>不管答案怎样，子问题的物品都是以$i…N$而非前述的$1…i$的形式来定义的，所以状态的定义和转移方程都需要改一下。</p>
<p>但也许更简易的方法是，先把物品编号做$x &#x3D; N + 1 - x$的变换，在输出方案时再变换回来。再做完物品编号的变换后，可以按照前面经典的转移方程来求值。只是在输出方案时要注意，如果$F[i, v] &#x3D; F[i - 1, v]$和$F[i, v] &#x3D; F[i - 1][v - C_i] + W_i$都成立，应该按照后者来输出方案，即选择了物品$i$，输出其原来的编号$N - 1 - i$。</p>
<p><strong>求总方案数：</strong></p>
<p>对于一个给定了背包容量、物品费用、物品间相互关系（分组、依赖等）的背包问题，除了再给定每个物品的价值后求可得到的最大价值外，还可以得到装满背包或将背包装至某一指定容量的方案总数。</p>
<p>对于这类改变问法的问题，一般只需将状态转移方程中的$\max$改成sum即可。例如若每件物品均是完全背包中的物品，转移方程即为：</p>
<p>$$<br>F[i, v] &#x3D; sum{ F[i - 1, v], F[i, v - C_i] }<br>$$</p>
<p>初始条件是$F[0, 0] &#x3D; 1$。</p>
<p>事实上，这样做可行的原因在于状态转移方程已经考察了所有可能的背包组成方案。</p>
<p><strong>最优方案的总数：</strong></p>
<p>这里的最优方案是指物品总价值最大的方案。以01背包为例。</p>
<p>结合求最大总价值和方案总数两个问题的思路，最优方案的总数可以这样求：$F[i, v]$代表该状态的最大价值，$G[i, v]$表示这个子问题的最优方案的总数，则在求$F[i, v]$的同时求$G[i, v]$的代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">G[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v=V;v&gt;=<span class="number">0</span>;v--)</span><br><span class="line">    &#123;</span><br><span class="line">        F[i][v]=<span class="built_in">max</span>(F[i<span class="number">-1</span>][v],F[i<span class="number">-1</span>][v-C[i]]+W[i]);</span><br><span class="line">        G[i][v]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(F[i][v]==F[i<span class="number">-1</span>][v]) G[i][v]+=G[i<span class="number">-1</span>][v];</span><br><span class="line">        <span class="keyword">if</span>(F[i][v]==F[i<span class="number">-1</span>][v-C[i]]+W[i]) G[i][v]+=G[i<span class="number">-1</span>][v-C[i]];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>求次优解、第$K$优解：</strong></p>
<p>对于求次优解、第$K$优解类的问题，如果相应的最优解问题能写出状态转移方程、用动态规划解决，那么求次优解往往可以相同的复杂度解决，第$K$优解则比求最优解的复杂度上多一个系数$K$。</p>
<p>其基本思想时，将每个状态都表示成有序队列，将状态转移方程中的$\max &#x2F; \min$转化成有序队列的合并。</p>
<p>这里仍以01背包为例进行讲解。</p>
<p>首先看01背包求最优解的状态转移方程：$F[i, v] &#x3D; \max { F[i - 1, v], F[i-1, v - C_i] + W_i }$。如果要求第$K$优解，那么状态$F[i, v]$就应该是一个大小为$K$的队列$F[i, v, 1…K]$。其中$F[i, v, k]$表示前$i$个物品中，背包大小为$v$时，第$k$优解的值。这里也可以简单地理解为在原来的方程中加了一维来表示结果的优先次序。显然$F[i, v, 1…K]$这$K$个数是由大到小排列的，所以它可看作是一个有序队列。</p>
<p>然后原方程就可以解释为：$F[i, v]$这个有序队列是由$F[i - 1, v]$和$F[i - 1, v - C_i] + W_i$这两个有序队列合并得到的。前者$F[i - 1, v]$即$F[i - 1, v, 1…K]$，后者$F[i - 1, v - C_i] + W_i$则理解为在$F[i - 1, v - C_i, 1…K]$的每个数上加上$W_i$后得到的有序队列。合并这两个有序队列并将结果的前$K$项储存到$F[i, v, 1…K]$中的复杂度是$O(K)$。最后的第$K$优解的答案是$F[N, V, K]$。总的时间复杂度是$O(NVK)$。</p>
<p>为什么这个方法正确呢？实际上，一个正确的状态转移方程的求解过程遍历了所有可用的策略，也就覆盖了问题的所有方案。只不过由于是求最优解，所以其它在任何一个策略上达不到最优的方案都被忽略了。如果把每个状态表示成一个大小为$K$的数组，并在这个数组中有序地保存该状态可取到的前$K$个最优值。那么，对于任两个状态的$\max$运算等价于两个由大到小的有序队列的合并。</p>
<p>另外还要注意题目对于“第$K$优解”的定义，是要求将策略不同但权值相同的两个方案是看作同一个解还是不同的解。如果是前者，则维护有序队列时要保证队列里的数没有重复的。</p>
<p><strong>小结：</strong></p>
<p>显然，这里不可能穷尽背包类动态规划问题所有的问法。甚至还存在一类将背包类动态规划问题与其他领域（例如数论、图论）结合起来的问题，在这篇论背包问题的专文中也不会论及。但只要深刻领会前述所有类别的背包问题的思路和状态转移方程，遇到其它的变形问题，应该也不难想出算法。</p>
<p>触类旁通、举一反三，应该也是一个程序员应有的品质吧。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>OI 知识</tag>
      </tags>
  </entry>
</search>
